/* automatically generated by rust-bindgen 0.68.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const HAL_kInvalidHandle: u32 = 0;
pub const HAL_CAN_SEND_PERIOD_NO_REPEAT: u32 = 0;
pub const HAL_CAN_SEND_PERIOD_STOP_REPEATING: i32 = -1;
pub const HAL_CAN_IS_FRAME_REMOTE: u32 = 2147483648;
pub const HAL_CAN_IS_FRAME_11BIT: u32 = 1073741824;
pub const HAL_ERR_CANSessionMux_InvalidBuffer: i32 = -44086;
pub const HAL_ERR_CANSessionMux_MessageNotFound: i32 = -44087;
pub const HAL_WARN_CANSessionMux_NoToken: u32 = 44087;
pub const HAL_ERR_CANSessionMux_NotAllowed: i32 = -44088;
pub const HAL_ERR_CANSessionMux_NotInitialized: i32 = -44089;
pub const HAL_ERR_CANSessionMux_SessionOverrun: u32 = 44050;
pub const HAL_IO_CONFIG_DATA_SIZE: u32 = 32;
pub const HAL_SYS_STATUS_DATA_SIZE: u32 = 44;
pub const HAL_USER_STATUS_DATA_SIZE: u32 = 908;
pub const HAL_kMaxJoystickAxes: u32 = 12;
pub const HAL_kMaxJoystickPOVs: u32 = 12;
pub const HAL_kMaxJoysticks: u32 = 6;
pub const HAL_SUCCESS: u32 = 0;
pub const HAL_INVALID_ACCUMULATOR_CHANNEL: i32 = -1035;
pub const HAL_INVALID_ACCUMULATOR_CHANNEL_MESSAGE: &[u8; 55] =
    b"HAL: The requested input is not an accumulator channel\0";
pub const HAL_COUNTER_NOT_SUPPORTED: i32 = -1058;
pub const HAL_COUNTER_NOT_SUPPORTED_MESSAGE: &[u8; 51] =
    b"HAL: Counter mode not supported for encoder method\0";
pub const HAL_PWM_SCALE_ERROR: i32 = -1072;
pub const HAL_PWM_SCALE_ERROR_MESSAGE: &[u8; 44] = b"HAL: The PWM Scale Factors are out of range\0";
pub const HAL_HANDLE_ERROR: i32 = -1098;
pub const HAL_HANDLE_ERROR_MESSAGE: &[u8; 47] = b"HAL: A handle parameter was passed incorrectly\0";
pub const HAL_LED_CHANNEL_ERROR: i32 = -1099;
pub const HAL_LED_CHANNEL_ERROR_MESSAGE: &[u8; 68] =
    b"HAL: Addressable LEDs only supported on PWM Headers, not MXP or DIO\0";
pub const HAL_INVALID_DMA_ADDITION: i32 = -1102;
pub const HAL_INVALID_DMA_ADDITION_MESSAGE: &[u8; 46] =
    b"HAL_AddDMA() only works before HAL_StartDMA()\0";
pub const HAL_INVALID_DMA_STATE: i32 = -1103;
pub const HAL_INVALID_DMA_STATE_MESSAGE: &[u8; 48] =
    b"HAL_SetPause() only works before HAL_StartDMA()\0";
pub const HAL_SERIAL_PORT_NOT_FOUND: i32 = -1123;
pub const HAL_SERIAL_PORT_NOT_FOUND_MESSAGE: &[u8; 52] =
    b"HAL: The specified serial port device was not found\0";
pub const HAL_SERIAL_PORT_OPEN_ERROR: i32 = -1124;
pub const HAL_SERIAL_PORT_OPEN_ERROR_MESSAGE: &[u8; 41] =
    b"HAL: The serial port could not be opened\0";
pub const HAL_SERIAL_PORT_ERROR: i32 = -1125;
pub const HAL_SERIAL_PORT_ERROR_MESSAGE: &[u8; 43] =
    b"HAL: There was an error on the serial port\0";
pub const HAL_THREAD_PRIORITY_ERROR: i32 = -1152;
pub const HAL_THREAD_PRIORITY_ERROR_MESSAGE: &[u8; 60] =
    b"HAL: Getting or setting the priority of a thread has failed\0";
pub const HAL_THREAD_PRIORITY_RANGE_ERROR: i32 = -1153;
pub const HAL_THREAD_PRIORITY_RANGE_ERROR_MESSAGE: &[u8; 49] =
    b"HAL: The priority requested to be set is invalid\0";
pub const HAL_CAN_TIMEOUT: i32 = -1154;
pub const HAL_CAN_TIMEOUT_MESSAGE: &[u8; 31] = b"HAL: CAN Receive has Timed Out\0";
pub const HAL_SIM_NOT_SUPPORTED: i32 = -1155;
pub const HAL_SIM_NOT_SUPPORTED_MESSAGE: &[u8; 33] = b"HAL: Method not supported in sim\0";
pub const HAL_USE_LAST_ERROR: i32 = -1156;
pub const HAL_USE_LAST_ERROR_MESSAGE: &[u8; 52] =
    b"HAL: Use HAL_GetLastError(status) to get last error\0";
pub const HAL_CONSOLE_OUT_ENABLED_ERROR: i32 = -1157;
pub const HAL_CONSOLE_OUT_ENABLED_ERROR_MESSAGE : & [u8 ; 106] = b"HAL: Onboard serial port is requested, but Console Out is enabled. Disable Console Out using imaging tool\0" ;
pub const HAL_CAN_BUFFER_OVERRUN: i32 = -35007;
pub const HAL_CAN_BUFFER_OVERRUN_MESSAGE: &[u8; 57] =
    b"HAL: CAN Output Buffer Full. Ensure a device is attached\0";
pub type HAL_Handle = i32;
pub type HAL_PortHandle = HAL_Handle;
pub type HAL_AnalogInputHandle = HAL_Handle;
pub type HAL_AnalogOutputHandle = HAL_Handle;
pub type HAL_AnalogTriggerHandle = HAL_Handle;
pub type HAL_CompressorHandle = HAL_Handle;
pub type HAL_CounterHandle = HAL_Handle;
pub type HAL_DigitalHandle = HAL_Handle;
pub type HAL_DigitalPWMHandle = HAL_Handle;
pub type HAL_EncoderHandle = HAL_Handle;
pub type HAL_FPGAEncoderHandle = HAL_Handle;
pub type HAL_GyroHandle = HAL_Handle;
pub type HAL_InterruptHandle = HAL_Handle;
pub type HAL_NotifierHandle = HAL_Handle;
pub type HAL_RelayHandle = HAL_Handle;
pub type HAL_SolenoidHandle = HAL_Handle;
pub type HAL_SerialPortHandle = HAL_Handle;
pub type HAL_CANHandle = HAL_Handle;
pub type HAL_SimDeviceHandle = HAL_Handle;
pub type HAL_SimValueHandle = HAL_Handle;
pub type HAL_DMAHandle = HAL_Handle;
pub type HAL_DutyCycleHandle = HAL_Handle;
pub type HAL_AddressableLEDHandle = HAL_Handle;
pub type HAL_PDPHandle = HAL_CANHandle;
pub type HAL_PowerDistributionHandle = HAL_Handle;
pub type HAL_CTREPCMHandle = HAL_Handle;
pub type HAL_REVPDHHandle = HAL_Handle;
pub type HAL_REVPHHandle = HAL_Handle;
pub type HAL_Bool = i32;
pub const HAL_AccelerometerRange_HAL_AccelerometerRange_k2G: HAL_AccelerometerRange = 0;
pub const HAL_AccelerometerRange_HAL_AccelerometerRange_k4G: HAL_AccelerometerRange = 1;
pub const HAL_AccelerometerRange_HAL_AccelerometerRange_k8G: HAL_AccelerometerRange = 2;
#[doc = " The acceptable accelerometer ranges."]
pub type HAL_AccelerometerRange = i32;
extern "C" {
    #[doc = " Sets the accelerometer to active or standby mode.\n\n It must be in standby mode to change any configuration.\n\n @param active true to set to active, false for standby"]
    pub fn HAL_SetAccelerometerActive(active: HAL_Bool);
}
extern "C" {
    #[doc = " Sets the range of values that can be measured (either 2, 4, or 8 g-forces).\n\n The accelerometer should be in standby mode when this is called.\n\n @param range the accelerometer range"]
    pub fn HAL_SetAccelerometerRange(range: HAL_AccelerometerRange);
}
extern "C" {
    #[doc = " Gets the x-axis acceleration.\n\n This is a floating point value in units of 1 g-force.\n\n @return the X acceleration"]
    pub fn HAL_GetAccelerometerX() -> f64;
}
extern "C" {
    #[doc = " Gets the y-axis acceleration.\n\n This is a floating point value in units of 1 g-force.\n\n @return the Y acceleration"]
    pub fn HAL_GetAccelerometerY() -> f64;
}
extern "C" {
    #[doc = " Gets the z-axis acceleration.\n\n This is a floating point value in units of 1 g-force.\n\n @return the Z acceleration"]
    pub fn HAL_GetAccelerometerZ() -> f64;
}
extern "C" {
    #[doc = " Is the channel attached to an accumulator.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[out] status Error status variable. 0 on success.\n @return The analog channel is attached to an accumulator."]
    pub fn HAL_IsAccumulatorChannel(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Initialize the accumulator.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_InitAccumulator(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Resets the accumulator to the initial value.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_ResetAccumulator(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Set the center value of the accumulator.\n\n The center value is subtracted from each A/D value before it is added to the\n accumulator. This is used for the center value of devices like gyros and\n accelerometers to make integration work and to take the device offset into\n account when integrating.\n\n This center value is based on the output of the oversampled and averaged\n source from channel 1. Because of this, any non-zero oversample bits will\n affect the size of the value for this field.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[in] center The center value of the accumulator.\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetAccumulatorCenter(
        analogPortHandle: HAL_AnalogInputHandle,
        center: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Set the accumulator's deadband.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[in] deadband The deadband of the accumulator.\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetAccumulatorDeadband(
        analogPortHandle: HAL_AnalogInputHandle,
        deadband: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Read the accumulated value.\n\n Read the value that has been accumulating on channel 1.\n The accumulator is attached after the oversample and average engine.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[out] status Error status variable. 0 on success.\n @return The 64-bit value accumulated since the last Reset()."]
    pub fn HAL_GetAccumulatorValue(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Read the number of accumulated values.\n\n Read the count of the accumulated values since the accumulator was last\n Reset().\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[out] status Error status variable. 0 on success.\n @return The number of times samples from the channel were accumulated."]
    pub fn HAL_GetAccumulatorCount(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Read the accumulated value and the number of accumulated values atomically.\n\n This function reads the value and count from the FPGA atomically.\n This can be used for averaging.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[in] value Pointer to the 64-bit accumulated output.\n @param[in] count Pointer to the number of accumulation cycles.\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_GetAccumulatorOutput(
        analogPortHandle: HAL_AnalogInputHandle,
        value: *mut i64,
        count: *mut i64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Initializes an analog gyro.\n\n @param[in] handle handle to the analog input port\n @param[in] allocationLocation the location where the allocation is occurring\n                                (can be null)\n @param[out] status the error code, or 0 for success\n @return the initialized gyro handle"]
    pub fn HAL_InitializeAnalogGyro(
        handle: HAL_AnalogInputHandle,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_GyroHandle;
}
extern "C" {
    #[doc = " Sets up an analog gyro with the proper offsets and settings for the KOP\n analog gyro.\n\n @param[in] handle the gyro handle\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetupAnalogGyro(handle: HAL_GyroHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Frees an analog gyro.\n\n @param[in,out] handle the gyro handle"]
    pub fn HAL_FreeAnalogGyro(handle: HAL_GyroHandle);
}
extern "C" {
    #[doc = " Sets the analog gyro parameters to the specified values.\n\n This is meant to be used if you want to reuse the values from a previous\n calibration.\n\n @param[in] handle                  the gyro handle\n @param[in] voltsPerDegreePerSecond the gyro volts scaling\n @param[in] offset                  the gyro offset\n @param[in] center                  the gyro center\n @param[out] status                  the error code, or 0 for success"]
    pub fn HAL_SetAnalogGyroParameters(
        handle: HAL_GyroHandle,
        voltsPerDegreePerSecond: f64,
        offset: f64,
        center: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the analog gyro volts per degrees per second scaling.\n\n @param[in] handle                  the gyro handle\n @param[in] voltsPerDegreePerSecond the gyro volts scaling\n @param[out] status                  the error code, or 0 for success"]
    pub fn HAL_SetAnalogGyroVoltsPerDegreePerSecond(
        handle: HAL_GyroHandle,
        voltsPerDegreePerSecond: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Resets the analog gyro value to 0.\n\n @param[in] handle the gyro handle\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_ResetAnalogGyro(handle: HAL_GyroHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Calibrates the analog gyro.\n\n This happens by calculating the average value of the gyro over 5 seconds, and\n setting that as the center. Note that this call blocks for 5 seconds to\n perform this.\n\n @param[in] handle the gyro handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_CalibrateAnalogGyro(handle: HAL_GyroHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the deadband of the analog gyro.\n\n @param[in] handle the gyro handle\n @param[in] volts  the voltage deadband\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetAnalogGyroDeadband(handle: HAL_GyroHandle, volts: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the gyro angle in degrees.\n\n @param[in] handle the gyro handle\n @param[out] status Error status variable. 0 on success.\n @return the gyro angle in degrees"]
    pub fn HAL_GetAnalogGyroAngle(handle: HAL_GyroHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the gyro rate in degrees/second.\n\n @param[in] handle the gyro handle\n @param[out] status Error status variable. 0 on success.\n @return the gyro rate in degrees/second"]
    pub fn HAL_GetAnalogGyroRate(handle: HAL_GyroHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the calibrated gyro offset.\n\n Can be used to not repeat a calibration but reconstruct the gyro object.\n\n @param[in] handle the gyro handle\n @param[out] status Error status variable. 0 on success.\n @return the gryo offset"]
    pub fn HAL_GetAnalogGyroOffset(handle: HAL_GyroHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the calibrated gyro center.\n\n Can be used to not repeat a calibration but reconstruct the gyro object.\n\n @param[in] handle the gyro handle\n @param[out] status Error status variable. 0 on success.\n @return the gyro center"]
    pub fn HAL_GetAnalogGyroCenter(handle: HAL_GyroHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Initializes the analog input port using the given port object.\n\n @param[in] portHandle Handle to the port to initialize.\n @param[in] allocationLocation the location where the allocation is occurring\n                               (can be null)\n @param[out] status the error code, or 0 for success\n @return the created analog input handle"]
    pub fn HAL_InitializeAnalogInputPort(
        portHandle: HAL_PortHandle,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_AnalogInputHandle;
}
extern "C" {
    #[doc = " Frees an analog input port.\n\n @param[in,out] analogPortHandle Handle to the analog port."]
    pub fn HAL_FreeAnalogInputPort(analogPortHandle: HAL_AnalogInputHandle);
}
extern "C" {
    #[doc = " Checks that the analog module number is valid.\n\n @param[in] module The analog module number.\n @return Analog module is valid and present"]
    pub fn HAL_CheckAnalogModule(module: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Checks that the analog output channel number is valid.\n Verifies that the analog channel number is one of the legal channel numbers.\n Channel numbers are 0-based.\n\n @param[in] channel The analog output channel number.\n @return Analog channel is valid"]
    pub fn HAL_CheckAnalogInputChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Indicates the analog input is used by a simulated device.\n\n @param handle the analog input handle\n @param device simulated device handle"]
    pub fn HAL_SetAnalogInputSimDevice(handle: HAL_AnalogInputHandle, device: HAL_SimDeviceHandle);
}
extern "C" {
    #[doc = " Sets the sample rate.\n\n This is a global setting for the Athena and effects all channels.\n\n @param[in] samplesPerSecond The number of samples per channel per second.\n @param[out] status          the error code, or 0 for success"]
    pub fn HAL_SetAnalogSampleRate(samplesPerSecond: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the current sample rate.\n\n This assumes one entry in the scan list.\n This is a global setting for the Athena and effects all channels.\n\n @param[out] status the error code, or 0 for success\n @return Sample rate."]
    pub fn HAL_GetAnalogSampleRate(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Sets the number of averaging bits.\n\n This sets the number of averaging bits. The actual number of averaged samples\n is 2**bits. Use averaging to improve the stability of your measurement at the\n expense of sampling rate. The averaging is done automatically in the FPGA.\n\n @param[in] analogPortHandle Handle to the analog port to configure.\n @param[in] bits Number of bits to average.\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetAnalogAverageBits(
        analogPortHandle: HAL_AnalogInputHandle,
        bits: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the number of averaging bits.\n\n This gets the number of averaging bits from the FPGA. The actual number of\n averaged samples is 2**bits. The averaging is done automatically in the FPGA.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status the error code, or 0 for success\n @return Bits to average."]
    pub fn HAL_GetAnalogAverageBits(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Sets the number of oversample bits.\n\n This sets the number of oversample bits. The actual number of oversampled\n values is 2**bits. Use oversampling to improve the resolution of your\n measurements at the expense of sampling rate. The oversampling is done\n automatically in the FPGA.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[in] bits Number of bits to oversample.\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetAnalogOversampleBits(
        analogPortHandle: HAL_AnalogInputHandle,
        bits: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the number of oversample bits.\n\n This gets the number of oversample bits from the FPGA. The actual number of\n oversampled values is 2**bits. The oversampling is done automatically in the\n FPGA.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status          the error code, or 0 for success\n @return Bits to oversample."]
    pub fn HAL_GetAnalogOversampleBits(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets a sample straight from the channel on this module.\n\n The sample is a 12-bit value representing the 0V to 5V range of the A/D\n converter in the module. The units are in A/D converter codes.  Use\n GetVoltage() to get the analog value in calibrated units.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status the error code, or 0 for success\n @return A sample straight from the channel on this module."]
    pub fn HAL_GetAnalogValue(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets a sample from the output of the oversample and average engine for the\n channel.\n\n The sample is 12-bit + the value configured in SetOversampleBits().\n The value configured in SetAverageBits() will cause this value to be averaged\n 2**bits number of samples. This is not a sliding window.  The sample will not\n change until 2**(OversampleBits + AverageBits) samples have been acquired\n from the module on this channel. Use GetAverageVoltage() to get the analog\n value in calibrated units.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status the error code, or 0 for success\n @return A sample from the oversample and average engine for the channel."]
    pub fn HAL_GetAnalogAverageValue(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Converts a voltage to a raw value for a specified channel.\n\n This process depends on the calibration of each channel, so the channel must\n be specified.\n\n @todo This assumes raw values.  Oversampling not supported as is.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[in] voltage The voltage to convert.\n @param[out] status the error code, or 0 for success\n @return The raw value for the channel."]
    pub fn HAL_GetAnalogVoltsToValue(
        analogPortHandle: HAL_AnalogInputHandle,
        voltage: f64,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets a scaled sample straight from the channel on this module.\n\n The value is scaled to units of Volts using the calibrated scaling data from\n GetLSBWeight() and GetOffset().\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status the error code, or 0 for success\n @return A scaled sample straight from the channel on this module."]
    pub fn HAL_GetAnalogVoltage(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets a scaled sample from the output of the oversample and average engine for\n the channel.\n\n The value is scaled to units of Volts using the calibrated scaling data from\n GetLSBWeight() and GetOffset(). Using oversampling will cause this value to\n be higher resolution, but it will update more slowly. Using averaging will\n cause this value to be more stable, but it will update more slowly.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status the error code, or 0 for success\n @return A scaled sample from the output of the oversample and average engine\n for the channel."]
    pub fn HAL_GetAnalogAverageVoltage(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Gets the factory scaling least significant bit weight constant.\n The least significant bit weight constant for the channel that was calibrated\n in manufacturing and stored in an eeprom in the module.\n\n Volts = ((LSB_Weight * 1e-9) * raw) - (Offset * 1e-9)\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status the error code, or 0 for success\n @return Least significant bit weight."]
    pub fn HAL_GetAnalogLSBWeight(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32)
        -> i32;
}
extern "C" {
    #[doc = " Gets the factory scaling offset constant.\n The offset constant for the channel that was calibrated in manufacturing and\n stored in an eeprom in the module.\n\n Volts = ((LSB_Weight * 1e-9) * raw) - (Offset * 1e-9)\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status Error status variable. 0 on success.\n @return Offset constant."]
    pub fn HAL_GetAnalogOffset(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = "  Get the analog voltage from a raw value.\n\n @param[in] analogPortHandle  Handle to the analog port the values were read\n                              from.\n @param[in] rawValue          The raw analog value\n @param[out] status           Error status variable. 0 on success.\n @return The voltage relating to the value"]
    pub fn HAL_GetAnalogValueToVolts(
        analogPortHandle: HAL_AnalogInputHandle,
        rawValue: i32,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Initializes the analog output port using the given port object.\n\n @param[in] portHandle handle to the port\n @param[in] allocationLocation the location where the allocation is occurring\n                               (can be null)\n @param[out] status Error status variable. 0 on success.\n @return the created analog output handle"]
    pub fn HAL_InitializeAnalogOutputPort(
        portHandle: HAL_PortHandle,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_AnalogOutputHandle;
}
extern "C" {
    #[doc = " Frees an analog output port.\n\n @param analogOutputHandle the analog output handle"]
    pub fn HAL_FreeAnalogOutputPort(analogOutputHandle: HAL_AnalogOutputHandle);
}
extern "C" {
    #[doc = " Sets an analog output value.\n\n @param[in] analogOutputHandle the analog output handle\n @param[in] voltage            the voltage (0-5v) to output\n @param[out] status            Error status variable. 0 on success."]
    pub fn HAL_SetAnalogOutput(
        analogOutputHandle: HAL_AnalogOutputHandle,
        voltage: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the current analog output value.\n\n @param[in] analogOutputHandle the analog output handle\n @param[out] status            Error status variable. 0 on success.\n @return the current output voltage (0-5v)"]
    pub fn HAL_GetAnalogOutput(analogOutputHandle: HAL_AnalogOutputHandle, status: *mut i32)
        -> f64;
}
extern "C" {
    #[doc = " Checks that the analog output channel number is valid.\n\n Verifies that the analog channel number is one of the legal channel numbers.\n Channel numbers are 0-based.\n\n @return Analog channel is valid"]
    pub fn HAL_CheckAnalogOutputChannel(channel: i32) -> HAL_Bool;
}
pub const HAL_AnalogTriggerType_HAL_Trigger_kInWindow: HAL_AnalogTriggerType = 0;
pub const HAL_AnalogTriggerType_HAL_Trigger_kState: HAL_AnalogTriggerType = 1;
pub const HAL_AnalogTriggerType_HAL_Trigger_kRisingPulse: HAL_AnalogTriggerType = 2;
pub const HAL_AnalogTriggerType_HAL_Trigger_kFallingPulse: HAL_AnalogTriggerType = 3;
#[doc = " The type of analog trigger to trigger on."]
pub type HAL_AnalogTriggerType = i32;
extern "C" {
    #[doc = " Initializes an analog trigger.\n\n @param[in] portHandle the analog input to use for triggering\n @param[out] status     Error status variable. 0 on success.\n @return the created analog trigger handle"]
    pub fn HAL_InitializeAnalogTrigger(
        portHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> HAL_AnalogTriggerHandle;
}
extern "C" {
    #[doc = " Initializes an analog trigger with a Duty Cycle input\n\n @param[in] dutyCycleHandle the analog input to use for duty cycle\n @param[out] status          Error status variable. 0 on success.\n @return tbe created analog trigger handle"]
    pub fn HAL_InitializeAnalogTriggerDutyCycle(
        dutyCycleHandle: HAL_DutyCycleHandle,
        status: *mut i32,
    ) -> HAL_AnalogTriggerHandle;
}
extern "C" {
    #[doc = " Frees an analog trigger.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_CleanAnalogTrigger(analogTriggerHandle: HAL_AnalogTriggerHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the raw ADC upper and lower limits of the analog trigger.\n\n HAL_SetAnalogTriggerLimitsVoltage or HAL_SetAnalogTriggerLimitsDutyCycle\n is likely better in most cases.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[in] lower               the lower ADC value\n @param[in] upper               the upper ADC value\n @param[out] status              Error status variable. 0 on success."]
    pub fn HAL_SetAnalogTriggerLimitsRaw(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        lower: i32,
        upper: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the upper and lower limits of the analog trigger.\n\n The limits are given as floating point voltage values.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[in] lower               the lower voltage value\n @param[in] upper               the upper voltage value\n @param[out] status              Error status variable. 0 on success."]
    pub fn HAL_SetAnalogTriggerLimitsVoltage(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        lower: f64,
        upper: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the upper and lower limits of the analog trigger.\n\n The limits are given as floating point duty cycle values.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[in] lower               the lower duty cycle value\n @param[in] upper               the upper duty cycle value\n @param[out] status              Error status variable. 0 on success."]
    pub fn HAL_SetAnalogTriggerLimitsDutyCycle(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        lower: f64,
        upper: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Configures the analog trigger to use the averaged vs. raw values.\n\n If the value is true, then the averaged value is selected for the analog\n trigger, otherwise the immediate value is used.\n\n This is not allowed to be used if filtered mode is set.\n This is not allowed to be used with Duty Cycle based inputs.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[in] useAveragedValue    true to use averaged values, false for raw\n @param[out] status              Error status variable. 0 on success."]
    pub fn HAL_SetAnalogTriggerAveraged(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        useAveragedValue: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Configures the analog trigger to use a filtered value.\n\n The analog trigger will operate with a 3 point average rejection filter. This\n is designed to help with 360 degree pot applications for the period where the\n pot crosses through zero.\n\n This is not allowed to be used if averaged mode is set.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[in] useFilteredValue    true to use filtered values, false for average\n                                or raw\n @param[out] status             Error status variable. 0 on success."]
    pub fn HAL_SetAnalogTriggerFiltered(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        useFilteredValue: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Returns the InWindow output of the analog trigger.\n\n True if the analog input is between the upper and lower limits.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[out] status Error status variable. 0 on success.\n @return the InWindow output of the analog trigger"]
    pub fn HAL_GetAnalogTriggerInWindow(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns the TriggerState output of the analog trigger.\n\n True if above upper limit.\n False if below lower limit.\n If in Hysteresis, maintain previous state.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[out] status              Error status variable. 0 on success.\n @return the TriggerState output of the analog trigger"]
    pub fn HAL_GetAnalogTriggerTriggerState(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the state of the analog trigger output.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[in] type                the type of trigger to trigger on\n @param[out] status              Error status variable. 0 on success.\n @return the state of the analog trigger output"]
    pub fn HAL_GetAnalogTriggerOutput(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        type_: HAL_AnalogTriggerType,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Get the FPGA index for the AnlogTrigger.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[out] status              Error status variable. 0 on success.\n @return the FPGA index"]
    pub fn HAL_GetAnalogTriggerFPGAIndex(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        status: *mut i32,
    ) -> i32;
}
#[doc = " Storage for CAN Stream Messages."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_CANStreamMessage {
    pub messageID: u32,
    pub timeStamp: u32,
    pub data: [u8; 8usize],
    pub dataSize: u8,
}
#[test]
fn bindgen_test_layout_HAL_CANStreamMessage() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_CANStreamMessage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_CANStreamMessage>(),
        20usize,
        concat!("Size of: ", stringify!(HAL_CANStreamMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_CANStreamMessage>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_CANStreamMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).messageID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_CANStreamMessage),
            "::",
            stringify!(messageID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_CANStreamMessage),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_CANStreamMessage),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_CANStreamMessage),
            "::",
            stringify!(dataSize)
        )
    );
}
extern "C" {
    #[doc = " Sends a CAN message.\n\n @param[in] messageID the CAN ID to send\n @param[in] data      the data to send (0-8 bytes)\n @param[in] dataSize  the size of the data to send (0-8 bytes)\n @param[in] periodMs  the period to repeat the packet at. Use\n                       HAL_CAN_SEND_PERIOD_NO_REPEAT to not repeat.\n @param[out] status    Error status variable. 0 on success."]
    pub fn HAL_CAN_SendMessage(
        messageID: u32,
        data: *const u8,
        dataSize: u8,
        periodMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Receives a CAN message.\n\n @param[out] messageID     store for the received message ID\n @param[in] messageIDMask the message ID mask to look for\n @param[out] data          data output (8 bytes)\n @param[out] dataSize      data length (0-8 bytes)\n @param[out] timeStamp     the packet received timestamp (based off of\n                           CLOCK_MONOTONIC)\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_CAN_ReceiveMessage(
        messageID: *mut u32,
        messageIDMask: u32,
        data: *mut u8,
        dataSize: *mut u8,
        timeStamp: *mut u32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Opens a CAN stream.\n\n @param[out] sessionHandle output for the session handle\n @param[in] messageID     the message ID to read\n @param[in] messageIDMask the mssage ID mask\n @param[in] maxMessages   the maximum number of messages to stream\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_CAN_OpenStreamSession(
        sessionHandle: *mut u32,
        messageID: u32,
        messageIDMask: u32,
        maxMessages: u32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Closes a CAN stream.\n\n @param sessionHandle the session to close"]
    pub fn HAL_CAN_CloseStreamSession(sessionHandle: u32);
}
extern "C" {
    #[doc = " Reads a CAN stream message.\n\n @param[in] sessionHandle  the session handle\n @param[in] messages       array of messages\n @param[in] messagesToRead the max number of messages to read\n @param[out] messagesRead   the number of messages actually read\n @param[out] status         Error status variable. 0 on success."]
    pub fn HAL_CAN_ReadStreamSession(
        sessionHandle: u32,
        messages: *mut HAL_CANStreamMessage,
        messagesToRead: u32,
        messagesRead: *mut u32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets CAN status information.\n\n @param[out] percentBusUtilization the bus utilization\n @param[out] busOffCount           the number of bus off errors\n @param[out] txFullCount           the number of tx full errors\n @param[out] receiveErrorCount     the number of receive errors\n @param[out] transmitErrorCount    the number of transmit errors\n @param[out] status                Error status variable. 0 on success."]
    pub fn HAL_CAN_GetCANStatus(
        percentBusUtilization: *mut f32,
        busOffCount: *mut u32,
        txFullCount: *mut u32,
        receiveErrorCount: *mut u32,
        transmitErrorCount: *mut u32,
        status: *mut i32,
    );
}
#[doc = " Broadcast."]
pub const HAL_CANDeviceType_HAL_CAN_Dev_kBroadcast: HAL_CANDeviceType = 0;
#[doc = " Robot controller."]
pub const HAL_CANDeviceType_HAL_CAN_Dev_kRobotController: HAL_CANDeviceType = 1;
#[doc = " Motor controller."]
pub const HAL_CANDeviceType_HAL_CAN_Dev_kMotorController: HAL_CANDeviceType = 2;
#[doc = " Relay controller."]
pub const HAL_CANDeviceType_HAL_CAN_Dev_kRelayController: HAL_CANDeviceType = 3;
#[doc = " Gyro sensor."]
pub const HAL_CANDeviceType_HAL_CAN_Dev_kGyroSensor: HAL_CANDeviceType = 4;
#[doc = " Accelerometer."]
pub const HAL_CANDeviceType_HAL_CAN_Dev_kAccelerometer: HAL_CANDeviceType = 5;
#[doc = " Ultrasonic sensor."]
pub const HAL_CANDeviceType_HAL_CAN_Dev_kUltrasonicSensor: HAL_CANDeviceType = 6;
#[doc = " Gear tooth sensor."]
pub const HAL_CANDeviceType_HAL_CAN_Dev_kGearToothSensor: HAL_CANDeviceType = 7;
#[doc = " Power distribution."]
pub const HAL_CANDeviceType_HAL_CAN_Dev_kPowerDistribution: HAL_CANDeviceType = 8;
#[doc = " Pneumatics."]
pub const HAL_CANDeviceType_HAL_CAN_Dev_kPneumatics: HAL_CANDeviceType = 9;
#[doc = " Miscellaneous."]
pub const HAL_CANDeviceType_HAL_CAN_Dev_kMiscellaneous: HAL_CANDeviceType = 10;
#[doc = " IO breakout."]
pub const HAL_CANDeviceType_HAL_CAN_Dev_kIOBreakout: HAL_CANDeviceType = 11;
#[doc = " Firmware update."]
pub const HAL_CANDeviceType_HAL_CAN_Dev_kFirmwareUpdate: HAL_CANDeviceType = 31;
#[doc = " The CAN device type.\n\n Teams should use HAL_CAN_Dev_kMiscellaneous"]
pub type HAL_CANDeviceType = i32;
#[doc = " Broadcast."]
pub const HAL_CANManufacturer_HAL_CAN_Man_kBroadcast: HAL_CANManufacturer = 0;
#[doc = " National Instruments."]
pub const HAL_CANManufacturer_HAL_CAN_Man_kNI: HAL_CANManufacturer = 1;
#[doc = " Luminary Micro."]
pub const HAL_CANManufacturer_HAL_CAN_Man_kLM: HAL_CANManufacturer = 2;
#[doc = " DEKA Research and Development Corp."]
pub const HAL_CANManufacturer_HAL_CAN_Man_kDEKA: HAL_CANManufacturer = 3;
#[doc = " Cross the Road Electronics."]
pub const HAL_CANManufacturer_HAL_CAN_Man_kCTRE: HAL_CANManufacturer = 4;
#[doc = " REV robotics."]
pub const HAL_CANManufacturer_HAL_CAN_Man_kREV: HAL_CANManufacturer = 5;
#[doc = " Grapple."]
pub const HAL_CANManufacturer_HAL_CAN_Man_kGrapple: HAL_CANManufacturer = 6;
#[doc = " MindSensors."]
pub const HAL_CANManufacturer_HAL_CAN_Man_kMS: HAL_CANManufacturer = 7;
#[doc = " Team use."]
pub const HAL_CANManufacturer_HAL_CAN_Man_kTeamUse: HAL_CANManufacturer = 8;
#[doc = " Kauai Labs."]
pub const HAL_CANManufacturer_HAL_CAN_Man_kKauaiLabs: HAL_CANManufacturer = 9;
#[doc = " Copperforge."]
pub const HAL_CANManufacturer_HAL_CAN_Man_kCopperforge: HAL_CANManufacturer = 10;
#[doc = " Playing With Fusion."]
pub const HAL_CANManufacturer_HAL_CAN_Man_kPWF: HAL_CANManufacturer = 11;
#[doc = " Studica."]
pub const HAL_CANManufacturer_HAL_CAN_Man_kStudica: HAL_CANManufacturer = 12;
#[doc = " TheThriftyBot."]
pub const HAL_CANManufacturer_HAL_CAN_Man_kTheThriftyBot: HAL_CANManufacturer = 13;
#[doc = " Redux Robotics."]
pub const HAL_CANManufacturer_HAL_CAN_Man_kReduxRobotics: HAL_CANManufacturer = 14;
#[doc = " AndyMark."]
pub const HAL_CANManufacturer_HAL_CAN_Man_kAndyMark: HAL_CANManufacturer = 15;
#[doc = " Vivid-Hosting."]
pub const HAL_CANManufacturer_HAL_CAN_Man_kVividHosting: HAL_CANManufacturer = 16;
#[doc = " The CAN manufacturer ID.\n\n Teams should use HAL_CAN_Man_kTeamUse."]
pub type HAL_CANManufacturer = i32;
extern "C" {
    #[doc = " Reads the current value of the millisecond-resolution timer that the CAN API\n functions use as a time base.\n\n @return Current value of timer used as a base time by the CAN API in\n milliseconds."]
    pub fn HAL_GetCANPacketBaseTime() -> u32;
}
extern "C" {
    #[doc = " Initializes a CAN device.\n\n These follow the FIRST standard CAN layout.\n https://docs.wpilib.org/en/stable/docs/software/can-devices/can-addressing.html\n\n @param[in] manufacturer the can manufacturer\n @param[in] deviceId     the device ID (0-63)\n @param[in] deviceType   the device type\n @param[out] status      Error status variable. 0 on success.\n @return the created CAN handle"]
    pub fn HAL_InitializeCAN(
        manufacturer: HAL_CANManufacturer,
        deviceId: i32,
        deviceType: HAL_CANDeviceType,
        status: *mut i32,
    ) -> HAL_CANHandle;
}
extern "C" {
    #[doc = " Frees a CAN device\n\n @param[in,out] handle the CAN handle"]
    pub fn HAL_CleanCAN(handle: HAL_CANHandle);
}
extern "C" {
    #[doc = " Writes a packet to the CAN device with a specific ID.\n\n This ID is 10 bits.\n\n @param[in] handle  the CAN handle\n @param[in] data    the data to write (0-8 bytes)\n @param[in] length  the length of data (0-8)\n @param[in] apiId   the ID to write (0-1023 bits)\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_WriteCANPacket(
        handle: HAL_CANHandle,
        data: *const u8,
        length: i32,
        apiId: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Writes a repeating packet to the CAN device with a specific ID.\n\n This ID is 10 bits.\n\n The RoboRIO will automatically repeat the packet at the specified interval\n\n @param[in] handle   the CAN handle\n @param[in] data     the data to write (0-8 bytes)\n @param[in] length   the length of data (0-8)\n @param[in] apiId    the ID to write (0-1023)\n @param[in] repeatMs the period to repeat in ms\n @param[out] status  Error status variable. 0 on success."]
    pub fn HAL_WriteCANPacketRepeating(
        handle: HAL_CANHandle,
        data: *const u8,
        length: i32,
        apiId: i32,
        repeatMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Writes an RTR frame of the specified length to the CAN device with the\n specific ID.\n\n By spec, the length must be equal to the length sent by the other device,\n otherwise behavior is unspecified.\n\n @param[in] handle   the CAN handle\n @param[in] length   the length of data to request (0-8)\n @param[in] apiId    the ID to write (0-1023)\n @param[out] status  Error status variable. 0 on success."]
    pub fn HAL_WriteCANRTRFrame(handle: HAL_CANHandle, length: i32, apiId: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Stops a repeating packet with a specific ID.\n\n This ID is 10 bits.\n\n @param[in] handle  the CAN handle\n @param[in] apiId   the ID to stop repeating (0-1023)\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_StopCANPacketRepeating(handle: HAL_CANHandle, apiId: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Reads a new CAN packet.\n\n This will only return properly once per packet received. Multiple calls\n without receiving another packet will return an error code.\n\n @param[in] handle             the CAN handle\n @param[in] apiId              the ID to read (0-1023)\n @param[out] data              the packet data (8 bytes)\n @param[out] length            the received length (0-8 bytes)\n @param[out] receivedTimestamp the packet received timestamp in ms (based off\n                               of CLOCK_MONOTONIC)\n @param[out] status            Error status variable. 0 on success."]
    pub fn HAL_ReadCANPacketNew(
        handle: HAL_CANHandle,
        apiId: i32,
        data: *mut u8,
        length: *mut i32,
        receivedTimestamp: *mut u64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Reads a CAN packet. The will continuously return the last packet received,\n without accounting for packet age.\n\n @param[in] handle             the CAN handle\n @param[in] apiId              the ID to read (0-1023)\n @param[out] data              the packet data (8 bytes)\n @param[out] length            the received length (0-8 bytes)\n @param[out] receivedTimestamp the packet received timestamp in ms (based off\n                               of CLOCK_MONOTONIC)\n @param[out] status            Error status variable. 0 on success."]
    pub fn HAL_ReadCANPacketLatest(
        handle: HAL_CANHandle,
        apiId: i32,
        data: *mut u8,
        length: *mut i32,
        receivedTimestamp: *mut u64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Reads a CAN packet. The will return the last packet received until the\n packet is older then the requested timeout. Then it will return an error\n code.\n\n @param[in] handle             the CAN handle\n @param[in] apiId              the ID to read (0-1023)\n @param[out] data              the packet data (8 bytes)\n @param[out] length            the received length (0-8 bytes)\n @param[out] receivedTimestamp the packet received timestamp in ms (based off\n                               of CLOCK_MONOTONIC)\n @param[out] timeoutMs         the timeout time for the packet\n @param[out] status            Error status variable. 0 on success."]
    pub fn HAL_ReadCANPacketTimeout(
        handle: HAL_CANHandle,
        apiId: i32,
        data: *mut u8,
        length: *mut i32,
        receivedTimestamp: *mut u64,
        timeoutMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Initializes a PCM.\n\n @param[in] module             the CAN ID to initialize\n @param[in] allocationLocation the location where the allocation is occurring\n                               (can be null)\n @param[out] status            Error status variable. 0 on success.\n @return the created PH handle"]
    pub fn HAL_InitializeCTREPCM(
        module: i32,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_CTREPCMHandle;
}
extern "C" {
    #[doc = " Frees a PCM handle.\n\n @param[in] handle the PCMhandle"]
    pub fn HAL_FreeCTREPCM(handle: HAL_CTREPCMHandle);
}
extern "C" {
    #[doc = " Checks if a solenoid channel number is valid.\n\n @param[in] channel the channel to check\n @return true if the channel is valid, otherwise false"]
    pub fn HAL_CheckCTREPCMSolenoidChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Get whether compressor is turned on.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return true if the compressor is turned on"]
    pub fn HAL_GetCTREPCMCompressor(handle: HAL_CTREPCMHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Enables the compressor closed loop control using the digital pressure switch.\n The compressor will turn on when the pressure switch indicates that the\n system is not full, and will turn off when the pressure switch indicates that\n the system is full.\n\n @param[in] handle  the PCM handle\n @param[in] enabled true to enable closed loop control\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetCTREPCMClosedLoopControl(
        handle: HAL_CTREPCMHandle,
        enabled: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Get whether the PCM closed loop control is enabled.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return True if closed loop control is enabled, otherwise false."]
    pub fn HAL_GetCTREPCMClosedLoopControl(handle: HAL_CTREPCMHandle, status: *mut i32)
        -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns the state of the pressure switch.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return True if pressure switch indicates that the system is full,\n otherwise false."]
    pub fn HAL_GetCTREPCMPressureSwitch(handle: HAL_CTREPCMHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns the current drawn by the compressor.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return The current drawn by the compressor in amps."]
    pub fn HAL_GetCTREPCMCompressorCurrent(handle: HAL_CTREPCMHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Return whether the compressor current is currently too high.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return True if the compressor current is too high, otherwise false.\n @see HAL_GetCTREPCMCompressorShortedStickyFault"]
    pub fn HAL_GetCTREPCMCompressorCurrentTooHighFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns whether the compressor current has been too high since sticky\n faults were last cleared. This fault is persistent and can be cleared by\n HAL_ClearAllCTREPCMStickyFaults()\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return True if the compressor current has been too high since sticky\n faults were last cleared.\n @see HAL_GetCTREPCMCompressorCurrentTooHighFault()"]
    pub fn HAL_GetCTREPCMCompressorCurrentTooHighStickyFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns whether the compressor has been shorted since sticky faults were\n last cleared. This fault is persistent and can be cleared by\n HAL_ClearAllCTREPCMStickyFaults()\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return True if the compressor has been shorted since sticky faults were\n last cleared, otherwise false.\n @see HAL_GetCTREPCMCompressorShortedFault()"]
    pub fn HAL_GetCTREPCMCompressorShortedStickyFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns whether the compressor is currently shorted.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return True if the compressor is currently shorted, otherwise false.\n @see HAL_GetCTREPCMCompressorShortedStickyFault"]
    pub fn HAL_GetCTREPCMCompressorShortedFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns whether the compressor has been disconnected since sticky faults\n were last cleared. This fault is persistent and can be cleared by\n HAL_ClearAllCTREPCMStickyFaults()\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return True if the compressor has been disconnected since sticky faults\n were last cleared, otherwise false.\n @see HAL_GetCTREPCMCompressorShortedFault()"]
    pub fn HAL_GetCTREPCMCompressorNotConnectedStickyFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns whether the compressor is currently disconnected.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return True if compressor is currently disconnected, otherwise false.\n @see HAL_GetCTREPCMCompressorNotConnectedStickyFault()"]
    pub fn HAL_GetCTREPCMCompressorNotConnectedFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets a bitmask of solenoid values.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return solenoid values"]
    pub fn HAL_GetCTREPCMSolenoids(handle: HAL_CTREPCMHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Sets solenoids on a pneumatics module.\n\n @param[in] handle  the PCM handle\n @param[in] mask bitmask to set\n @param[in] values solenoid values\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetCTREPCMSolenoids(
        handle: HAL_CTREPCMHandle,
        mask: i32,
        values: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Get a bitmask of disabled solenoids.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return bitmask of disabled solenoids"]
    pub fn HAL_GetCTREPCMSolenoidDisabledList(handle: HAL_CTREPCMHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Returns whether the solenoid has reported a voltage fault since sticky faults\n were last cleared. This fault is persistent and can be cleared by\n HAL_ClearAllCTREPCMStickyFaults()\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return True if solenoid is reporting a fault, otherwise false.\n @see HAL_GetCTREPCMSolenoidVoltageFault()"]
    pub fn HAL_GetCTREPCMSolenoidVoltageStickyFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns whether the solenoid is currently reporting a voltage fault.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return True if solenoid is reporting a fault, otherwise false.\n @see HAL_GetCTREPCMSolenoidVoltageStickyFault()"]
    pub fn HAL_GetCTREPCMSolenoidVoltageFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Clears all sticky faults on this device.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_ClearAllCTREPCMStickyFaults(handle: HAL_CTREPCMHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Fire a single solenoid shot.\n\n @param[in] handle  the PCM handle\n @param[in] index solenoid index\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_FireCTREPCMOneShot(handle: HAL_CTREPCMHandle, index: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Set the duration for a single solenoid shot.\n\n @param[in] handle  the PCM handle\n @param[in] index solenoid index\n @param[in] durMs shot duration in ms\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetCTREPCMOneShotDuration(
        handle: HAL_CTREPCMHandle,
        index: i32,
        durMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the number of FPGA system clock ticks per microsecond.\n\n @return the number of clock ticks per microsecond"]
    pub fn HAL_GetSystemClockTicksPerMicrosecond() -> i32;
}
pub const HAL_Counter_Mode_HAL_Counter_kTwoPulse: HAL_Counter_Mode = 0;
pub const HAL_Counter_Mode_HAL_Counter_kSemiperiod: HAL_Counter_Mode = 1;
pub const HAL_Counter_Mode_HAL_Counter_kPulseLength: HAL_Counter_Mode = 2;
pub const HAL_Counter_Mode_HAL_Counter_kExternalDirection: HAL_Counter_Mode = 3;
#[doc = " The counter mode."]
pub type HAL_Counter_Mode = i32;
extern "C" {
    #[doc = " Initializes a counter.\n\n @param[in] mode    the counter mode\n @param[in] index   the compressor index (output)\n @param[out] status Error status variable. 0 on success.\n @return the created handle"]
    pub fn HAL_InitializeCounter(
        mode: HAL_Counter_Mode,
        index: *mut i32,
        status: *mut i32,
    ) -> HAL_CounterHandle;
}
extern "C" {
    #[doc = " Frees a counter.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_FreeCounter(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the average sample size of a counter.\n\n @param[in] counterHandle  the counter handle\n @param[in] size           the size of samples to average\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_SetCounterAverageSize(counterHandle: HAL_CounterHandle, size: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the source object that causes the counter to count up.\n\n @param[in] counterHandle       the counter handle\n @param[in] digitalSourceHandle the digital source handle (either a\n                                HAL_AnalogTriggerHandle or a\n                                HAL_DigitalHandle)\n @param[in] analogTriggerType   the analog trigger type if the source is an\n                                analog trigger\n @param[out] status             Error status variable. 0 on success."]
    pub fn HAL_SetCounterUpSource(
        counterHandle: HAL_CounterHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the up source to either detect rising edges or falling edges.\n\n Note that both are allowed to be set true at the same time without issues.\n\n @param[in] counterHandle  the counter handle\n @param[in] risingEdge     true to trigger on rising\n @param[in] fallingEdge    true to trigger on falling\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_SetCounterUpSourceEdge(
        counterHandle: HAL_CounterHandle,
        risingEdge: HAL_Bool,
        fallingEdge: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Disables the up counting source to the counter.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_ClearCounterUpSource(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the source object that causes the counter to count down.\n\n @param[in] counterHandle       the counter handle\n @param[in] digitalSourceHandle the digital source handle (either a\n                                HAL_AnalogTriggerHandle or a\n                                HAL_DigitalHandle)\n @param[in] analogTriggerType   the analog trigger type if the source is an\n                                analog trigger\n @param[out] status             Error status variable. 0 on success."]
    pub fn HAL_SetCounterDownSource(
        counterHandle: HAL_CounterHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the down source to either detect rising edges or falling edges.\n Note that both are allowed to be set true at the same time without issues.\n\n @param[in] counterHandle  the counter handle\n @param[in] risingEdge     true to trigger on rising\n @param[in] fallingEdge    true to trigger on falling\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_SetCounterDownSourceEdge(
        counterHandle: HAL_CounterHandle,
        risingEdge: HAL_Bool,
        fallingEdge: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Disables the down counting source to the counter.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_ClearCounterDownSource(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets standard up / down counting mode on this counter.\n\n Up and down counts are sourced independently from two inputs.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetCounterUpDownMode(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets directional counting mode on this counter.\n\n The direction is determined by the B input, with counting happening with the\n A input.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetCounterExternalDirectionMode(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets Semi-period mode on this counter.\n\n The counter counts up based on the time the input is triggered. High or Low\n depends on the highSemiPeriod parameter.\n\n @param[in] counterHandle  the counter handle\n @param[in] highSemiPeriod true for counting when the input is high, false for\n                           low\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_SetCounterSemiPeriodMode(
        counterHandle: HAL_CounterHandle,
        highSemiPeriod: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Configures the counter to count in up or down based on the length of the\n input pulse.\n\n This mode is most useful for direction sensitive gear tooth sensors.\n\n @param[in] counterHandle the counter handle\n @param[in] threshold     The pulse length beyond which the counter counts the\n                          opposite direction (seconds)\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetCounterPulseLengthMode(
        counterHandle: HAL_CounterHandle,
        threshold: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the Samples to Average which specifies the number of samples of the\n timer to average when calculating the period. Perform averaging to account\n for mechanical imperfections or as oversampling to increase resolution.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success.\n @return SamplesToAverage The number of samples being averaged (from 1 to 127)"]
    pub fn HAL_GetCounterSamplesToAverage(
        counterHandle: HAL_CounterHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Sets the Samples to Average which specifies the number of samples of the\n timer to average when calculating the period. Perform averaging to account\n for mechanical imperfections or as oversampling to increase resolution.\n\n @param[in] counterHandle    the counter handle\n @param[in] samplesToAverage The number of samples to average from 1 to 127\n @param[out] status          Error status variable. 0 on success."]
    pub fn HAL_SetCounterSamplesToAverage(
        counterHandle: HAL_CounterHandle,
        samplesToAverage: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Resets the Counter to zero.\n\n Sets the counter value to zero. This does not effect the running state of the\n counter, just sets the current value to zero.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_ResetCounter(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Reads the current counter value.\n\n Reads the value at this instant. It may still be running, so it reflects the\n current value. Next time it is read, it might have a different value.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success.\n @return the current counter value"]
    pub fn HAL_GetCounter(counterHandle: HAL_CounterHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the Period of the most recent count.\n\n Returns the time interval of the most recent count. This can be used for\n velocity calculations to determine shaft speed.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success.\n @return the period of the last two pulses in units of seconds"]
    pub fn HAL_GetCounterPeriod(counterHandle: HAL_CounterHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Sets the maximum period where the device is still considered \"moving\".\n\n Sets the maximum period where the device is considered moving. This value is\n used to determine the \"stopped\" state of the counter using the\n HAL_GetCounterStopped method.\n\n @param[in] counterHandle the counter handle\n @param[in] maxPeriod     the maximum period where the counted device is\n                          considered moving in seconds\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetCounterMaxPeriod(
        counterHandle: HAL_CounterHandle,
        maxPeriod: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Selects whether you want to continue updating the event timer output when\n there are no samples captured.\n\n The output of the event timer has a buffer of periods that are averaged and\n posted to a register on the FPGA.  When the timer detects that the event\n source has stopped (based on the MaxPeriod) the buffer of samples to be\n averaged is emptied.\n\n If you enable the update when empty, you will be\n notified of the stopped source and the event time will report 0 samples.\n\n If you disable update when empty, the most recent average will remain on the\n output until a new sample is acquired.\n\n You will never see 0 samples output (except when there have been no events\n since an FPGA reset) and you will likely not see the stopped bit become true\n (since it is updated at the end of an average and there are no samples to\n average).\n\n @param[in] counterHandle the counter handle\n @param[in] enabled       true to enable counter updating with no samples\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetCounterUpdateWhenEmpty(
        counterHandle: HAL_CounterHandle,
        enabled: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Determines if the clock is stopped.\n\n Determine if the clocked input is stopped based on the MaxPeriod value set\n using the SetMaxPeriod method. If the clock exceeds the MaxPeriod, then the\n device (and counter) are assumed to be stopped and it returns true.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success.\n @return true if the most recent counter period exceeds the MaxPeriod value\n         set by SetMaxPeriod"]
    pub fn HAL_GetCounterStopped(counterHandle: HAL_CounterHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the last direction the counter value changed.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success.\n @return the last direction the counter value changed"]
    pub fn HAL_GetCounterDirection(counterHandle: HAL_CounterHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets the Counter to return reversed sensing on the direction.\n\n This allows counters to change the direction they are counting in the case of\n 1X and 2X quadrature encoding only. Any other counter mode isn't supported.\n\n @param[in] counterHandle    the counter handle\n @param[in] reverseDirection true if the value counted should be negated.\n @param[out] status          Error status variable. 0 on success."]
    pub fn HAL_SetCounterReverseDirection(
        counterHandle: HAL_CounterHandle,
        reverseDirection: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Creates a new instance of a digital port.\n\n @param[in] portHandle         the port handle to create from\n @param[in] input              true for input, false for output\n @param[in] allocationLocation the location where the allocation is occurring\n                               (can be null)\n @param[out] status            Error status variable. 0 on success.\n @return the created digital handle"]
    pub fn HAL_InitializeDIOPort(
        portHandle: HAL_PortHandle,
        input: HAL_Bool,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_DigitalHandle;
}
extern "C" {
    #[doc = " Checks if a DIO channel is valid.\n\n @param channel the channel number to check\n @return true if the channel is valid, otherwise false"]
    pub fn HAL_CheckDIOChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Frees a DIO port.\n\n @param dioPortHandle the DIO channel handle"]
    pub fn HAL_FreeDIOPort(dioPortHandle: HAL_DigitalHandle);
}
extern "C" {
    #[doc = " Indicates the DIO channel is used by a simulated device.\n\n @param handle the DIO channel handle\n @param device simulated device handle"]
    pub fn HAL_SetDIOSimDevice(handle: HAL_DigitalHandle, device: HAL_SimDeviceHandle);
}
extern "C" {
    #[doc = " Allocates a DO PWM Generator.\n\n @param[out] status Error status variable. 0 on success.\n @return the allocated digital PWM handle"]
    pub fn HAL_AllocateDigitalPWM(status: *mut i32) -> HAL_DigitalPWMHandle;
}
extern "C" {
    #[doc = " Frees the resource associated with a DO PWM generator.\n\n @param[in] pwmGenerator the digital PWM handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_FreeDigitalPWM(pwmGenerator: HAL_DigitalPWMHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Changes the frequency of the DO PWM generator.\n\n The valid range is from 0.6 Hz to 19 kHz.\n\n The frequency resolution is logarithmic.\n\n @param[in] rate the frequency to output all digital output PWM signals\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetDigitalPWMRate(rate: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Configures the duty-cycle of the PWM generator.\n\n @param[in] pwmGenerator the digital PWM handle\n @param[in] dutyCycle    the percent duty cycle to output [0..1]\n @param[out] status      Error status variable. 0 on success."]
    pub fn HAL_SetDigitalPWMDutyCycle(
        pwmGenerator: HAL_DigitalPWMHandle,
        dutyCycle: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Configures the digital PWM to be a PPS signal with specified duty cycle.\n\n @param[in] pwmGenerator the digital PWM handle\n @param[in] dutyCycle    the percent duty cycle to output [0..1]\n @param[out] status      Error status variable. 0 on success."]
    pub fn HAL_SetDigitalPWMPPS(
        pwmGenerator: HAL_DigitalPWMHandle,
        dutyCycle: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Configures which DO channel the PWM signal is output on.\n\n @param[in] pwmGenerator the digital PWM handle\n @param[in] channel      the channel to output on\n @param[out] status      Error status variable. 0 on success."]
    pub fn HAL_SetDigitalPWMOutputChannel(
        pwmGenerator: HAL_DigitalPWMHandle,
        channel: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Writes a digital value to a DIO channel.\n\n @param[in] dioPortHandle the digital port handle\n @param[in] value         the state to set the digital channel (if it is\n                          configured as an output)\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetDIO(dioPortHandle: HAL_DigitalHandle, value: HAL_Bool, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the direction of a DIO channel.\n\n @param[in] dioPortHandle the digital port handle\n @param[in] input         true to set input, false for output\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetDIODirection(dioPortHandle: HAL_DigitalHandle, input: HAL_Bool, status: *mut i32);
}
extern "C" {
    #[doc = " Reads a digital value from a DIO channel.\n\n @param[in] dioPortHandle the digital port handle\n @param[out] status       Error status variable. 0 on success.\n @return the state of the specified channel"]
    pub fn HAL_GetDIO(dioPortHandle: HAL_DigitalHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Reads the direction of a DIO channel.\n\n @param[in] dioPortHandle the digital port handle\n @param[out] status       Error status variable. 0 on success.\n @return true for input, false for output"]
    pub fn HAL_GetDIODirection(dioPortHandle: HAL_DigitalHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Generates a single digital pulse.\n\n Write a pulse to the specified digital output channel. There can only be a\n single pulse going at any time.\n\n @param[in] dioPortHandle the digital port handle\n @param[in] pulseLengthSeconds   the active length of the pulse (in seconds)\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_Pulse(dioPortHandle: HAL_DigitalHandle, pulseLengthSeconds: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Generates a single digital pulse on multiple channels.\n\n Write a pulse to the channels enabled by the mask. There can only be a\n single pulse going at any time.\n\n @param[in] channelMask the channel mask\n @param[in] pulseLengthSeconds   the active length of the pulse (in seconds)\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_PulseMultiple(channelMask: u32, pulseLengthSeconds: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Checks a DIO line to see if it is currently generating a pulse.\n\n @param[in] dioPortHandle the digital port handle\n @param[out] status Error status variable. 0 on success.\n @return true if a pulse is in progress, otherwise false"]
    pub fn HAL_IsPulsing(dioPortHandle: HAL_DigitalHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Checks if any DIO line is currently generating a pulse.\n\n @param[out] status Error status variable. 0 on success.\n @return true if a pulse on some line is in progress"]
    pub fn HAL_IsAnyPulsing(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Writes the filter index from the FPGA.\n\n Set the filter index used to filter out short pulses.\n\n @param[in] dioPortHandle the digital port handle\n @param[in] filterIndex   the filter index (Must be in the range 0 - 3, where\n                          0 means \"none\" and 1 - 3 means filter # filterIndex\n                          - 1)\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetFilterSelect(
        dioPortHandle: HAL_DigitalHandle,
        filterIndex: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Reads the filter index from the FPGA.\n\n Gets the filter index used to filter out short pulses.\n\n @param[in] dioPortHandle the digital port handle\n @param[out] status       Error status variable. 0 on success.\n @return filterIndex  the filter index (Must be in the range 0 - 3, where 0\n                      means \"none\" and 1 - 3 means filter # filterIndex - 1)"]
    pub fn HAL_GetFilterSelect(dioPortHandle: HAL_DigitalHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Sets the filter period for the specified filter index.\n\n Sets the filter period in FPGA cycles.  Even though there are 2 different\n filter index domains (MXP vs HDR), ignore that distinction for now since it\n complicates the interface.  That can be changed later.\n\n @param[in] filterIndex the filter index, 0 - 2\n @param[in] value       the number of cycles that the signal must not\n                        transition to be counted as a transition.\n @param[out] status     Error status variable. 0 on success."]
    pub fn HAL_SetFilterPeriod(filterIndex: i32, value: i64, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the filter period for the specified filter index.\n\n Gets the filter period in FPGA cycles.  Even though there are 2 different\n filter index domains (MXP vs HDR), ignore that distinction for now since it\n complicates the interface.  Set status to NiFpga_Status_SoftwareFault if the\n filter values mismatch.\n\n @param[in] filterIndex the filter index, 0 - 2\n @param[out] status     Error status variable. 0 on success.\n @return                The number of FPGA cycles of the filter period."]
    pub fn HAL_GetFilterPeriod(filterIndex: i32, status: *mut i32) -> i64;
}
#[doc = " Generic handle for all WPI handle-based interfaces.\n\n Handle data layout:\n - Bits 0-23:  Type-specific\n - Bits 24-30: Type\n - Bit 31:     Error"]
pub type WPI_Handle = ::std::os::raw::c_uint;
#[doc = " An event handle."]
pub type WPI_EventHandle = WPI_Handle;
#[doc = " A semaphore handle."]
pub type WPI_SemaphoreHandle = WPI_Handle;
extern "C" {
    #[doc = " Creates an event.  Events have binary state (signaled or not signaled) and\n may be either automatically reset or manually reset.  Automatic-reset events\n go to non-signaled state when a WaitForObject is woken up by the event;\n manual-reset events require ResetEvent() to be called to set the event to\n non-signaled state; if ResetEvent() is not called, any waiter on that event\n will immediately wake when called.\n\n @param manual_reset true for manual reset, false for automatic reset\n @param initial_state true to make the event initially in signaled state\n @return Event handle"]
    pub fn WPI_CreateEvent(
        manual_reset: ::std::os::raw::c_int,
        initial_state: ::std::os::raw::c_int,
    ) -> WPI_EventHandle;
}
extern "C" {
    #[doc = " Destroys an event.  Destruction wakes up any waiters.\n\n @param handle event handle"]
    pub fn WPI_DestroyEvent(handle: WPI_EventHandle);
}
extern "C" {
    #[doc = " Sets an event to signaled state.\n\n @param handle event handle"]
    pub fn WPI_SetEvent(handle: WPI_EventHandle);
}
extern "C" {
    #[doc = " Sets an event to non-signaled state.\n\n @param handle event handle"]
    pub fn WPI_ResetEvent(handle: WPI_EventHandle);
}
extern "C" {
    #[doc = " Creates a semaphore.  Semaphores keep an internal counter.  Releasing the\n semaphore increases the count.  A semaphore with a non-zero count is\n considered signaled.  When a waiter wakes up it atomically decrements the\n count by 1.  This is generally useful in a single-supplier,\n multiple-consumer scenario.\n\n @param initial_count initial value for the semaphore's internal counter\n @param maximum_count maximum value for the samephore's internal counter\n @return Semaphore handle"]
    pub fn WPI_CreateSemaphore(
        initial_count: ::std::os::raw::c_int,
        maximum_count: ::std::os::raw::c_int,
    ) -> WPI_SemaphoreHandle;
}
extern "C" {
    #[doc = " Destroys a semaphore.  Destruction wakes up any waiters.\n\n @param handle semaphore handle"]
    pub fn WPI_DestroySemaphore(handle: WPI_SemaphoreHandle);
}
extern "C" {
    #[doc = " Releases N counts of a semaphore.\n\n @param handle semaphore handle\n @param release_count amount to add to semaphore's internal counter;\n        must be positive\n @param prev_count if non-null, previous count (output parameter)\n @return Non-zero on successful release, zero on failure (e.g. release count\n         would exceed maximum value, or handle invalid)"]
    pub fn WPI_ReleaseSemaphore(
        handle: WPI_SemaphoreHandle,
        release_count: ::std::os::raw::c_int,
        prev_count: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Waits for an handle to be signaled.\n\n @param handle handle to wait on\n @return Non-zero if handle was signaled, zero otherwise (e.g. object was\n         destroyed)"]
    pub fn WPI_WaitForObject(handle: WPI_Handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Waits for an handle to be signaled, with timeout.\n\n @param handle handle to wait on\n @param timeout timeout in seconds\n @param timed_out if non-null, set to non-zero if timeout reached without\n        handle being signaled; set to zero otherwise (output)\n @return Non-zero if handle was signaled, zero otherwise (e.g. object was\n         destroyed or timed out)"]
    pub fn WPI_WaitForObjectTimeout(
        handle: WPI_Handle,
        timeout: f64,
        timed_out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Waits for one or more handles to be signaled.\n\n Invalid handles are treated as signaled; the returned array will have the\n handle error bit set for any invalid handles.\n\n @param handles array of handles to wait on\n @param handles_count length of the handles array\n @param signaled output array for storage of signaled handles; must be at\n        least the size of the handles input array\n @return number of signaled handles"]
    pub fn WPI_WaitForObjects(
        handles: *const WPI_Handle,
        handles_count: ::std::os::raw::c_int,
        signaled: *mut WPI_Handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Waits for one or more handles to be signaled, with timeout.\n\n Invalid handles are treated as signaled; the returned array will have the\n handle error bit set for any invalid handles.\n\n @param handles array of handles to wait on\n @param handles_count length of the handles array\n @param signaled output array for storage of signaled handles; must be at\n        least the size of the handles input array\n @param timeout timeout in seconds\n @param timed_out if non-null, set to non-zero if timeout reached without any\n        handle being signaled; set to zero otherwise (output)\n @return number of signaled handles"]
    pub fn WPI_WaitForObjectsTimeout(
        handles: *const WPI_Handle,
        handles_count: ::std::os::raw::c_int,
        signaled: *mut WPI_Handle,
        timeout: f64,
        timed_out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets up signaling for an arbitrary handle.  With this function, any handle\n can operate like an event handle.\n\n @param handle handle\n @param manual_reset true for manual reset, false for automatic reset\n @param initial_state true to make the handle initially in signaled state"]
    pub fn WPI_CreateSignalObject(
        handle: WPI_Handle,
        manual_reset: ::std::os::raw::c_int,
        initial_state: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Sets a handle to signaled state.\n\n @param handle handle"]
    pub fn WPI_SetSignalObject(handle: WPI_Handle);
}
extern "C" {
    #[doc = " Sets a handle to non-signaled state.\n\n @param handle handle"]
    pub fn WPI_ResetSignalObject(handle: WPI_Handle);
}
extern "C" {
    #[doc = " Cleans up signaling for a handle.  Destruction wakes up any waiters.\n\n @param handle handle"]
    pub fn WPI_DestroySignalObject(handle: WPI_Handle);
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct HAL_ControlWord {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_HAL_ControlWord() {
    assert_eq!(
        ::std::mem::size_of::<HAL_ControlWord>(),
        4usize,
        concat!("Size of: ", stringify!(HAL_ControlWord))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_ControlWord>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_ControlWord))
    );
}
impl HAL_ControlWord {
    #[inline]
    pub fn enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autonomous(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autonomous(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn test(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_test(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn eStop(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eStop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fmsAttached(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fmsAttached(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsAttached(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsAttached(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn control_reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_control_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled: u32,
        autonomous: u32,
        test: u32,
        eStop: u32,
        fmsAttached: u32,
        dsAttached: u32,
        control_reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u32 = unsafe { ::std::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let autonomous: u32 = unsafe { ::std::mem::transmute(autonomous) };
            autonomous as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let test: u32 = unsafe { ::std::mem::transmute(test) };
            test as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let eStop: u32 = unsafe { ::std::mem::transmute(eStop) };
            eStop as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let fmsAttached: u32 = unsafe { ::std::mem::transmute(fmsAttached) };
            fmsAttached as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dsAttached: u32 = unsafe { ::std::mem::transmute(dsAttached) };
            dsAttached as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let control_reserved: u32 = unsafe { ::std::mem::transmute(control_reserved) };
            control_reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const HAL_AllianceStationID_HAL_AllianceStationID_kUnknown: HAL_AllianceStationID = 0;
pub const HAL_AllianceStationID_HAL_AllianceStationID_kRed1: HAL_AllianceStationID = 1;
pub const HAL_AllianceStationID_HAL_AllianceStationID_kRed2: HAL_AllianceStationID = 2;
pub const HAL_AllianceStationID_HAL_AllianceStationID_kRed3: HAL_AllianceStationID = 3;
pub const HAL_AllianceStationID_HAL_AllianceStationID_kBlue1: HAL_AllianceStationID = 4;
pub const HAL_AllianceStationID_HAL_AllianceStationID_kBlue2: HAL_AllianceStationID = 5;
pub const HAL_AllianceStationID_HAL_AllianceStationID_kBlue3: HAL_AllianceStationID = 6;
pub type HAL_AllianceStationID = i32;
pub const HAL_MatchType_HAL_kMatchType_none: HAL_MatchType = 0;
pub const HAL_MatchType_HAL_kMatchType_practice: HAL_MatchType = 1;
pub const HAL_MatchType_HAL_kMatchType_qualification: HAL_MatchType = 2;
pub const HAL_MatchType_HAL_kMatchType_elimination: HAL_MatchType = 3;
pub type HAL_MatchType = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_JoystickAxes {
    pub count: i16,
    pub axes: [f32; 12usize],
    pub raw: [u8; 12usize],
}
#[test]
fn bindgen_test_layout_HAL_JoystickAxes() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_JoystickAxes> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_JoystickAxes>(),
        64usize,
        concat!("Size of: ", stringify!(HAL_JoystickAxes))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_JoystickAxes>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_JoystickAxes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickAxes),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).axes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickAxes),
            "::",
            stringify!(axes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickAxes),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_JoystickPOVs {
    pub count: i16,
    pub povs: [i16; 12usize],
}
#[test]
fn bindgen_test_layout_HAL_JoystickPOVs() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_JoystickPOVs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_JoystickPOVs>(),
        26usize,
        concat!("Size of: ", stringify!(HAL_JoystickPOVs))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_JoystickPOVs>(),
        2usize,
        concat!("Alignment of ", stringify!(HAL_JoystickPOVs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickPOVs),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).povs) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickPOVs),
            "::",
            stringify!(povs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_JoystickButtons {
    pub buttons: u32,
    pub count: u8,
}
#[test]
fn bindgen_test_layout_HAL_JoystickButtons() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_JoystickButtons> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_JoystickButtons>(),
        8usize,
        concat!("Size of: ", stringify!(HAL_JoystickButtons))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_JoystickButtons>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_JoystickButtons))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buttons) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickButtons),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickButtons),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_JoystickDescriptor {
    pub isXbox: u8,
    pub type_: u8,
    pub name: [::std::os::raw::c_char; 256usize],
    pub axisCount: u8,
    pub axisTypes: [u8; 12usize],
    pub buttonCount: u8,
    pub povCount: u8,
}
#[test]
fn bindgen_test_layout_HAL_JoystickDescriptor() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_JoystickDescriptor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_JoystickDescriptor>(),
        273usize,
        concat!("Size of: ", stringify!(HAL_JoystickDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_JoystickDescriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(HAL_JoystickDescriptor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isXbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(isXbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).axisCount) as usize - ptr as usize },
        258usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(axisCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).axisTypes) as usize - ptr as usize },
        259usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(axisTypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buttonCount) as usize - ptr as usize },
        271usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(buttonCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).povCount) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(povCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_MatchInfo {
    pub eventName: [::std::os::raw::c_char; 64usize],
    pub matchType: HAL_MatchType,
    pub matchNumber: u16,
    pub replayNumber: u8,
    pub gameSpecificMessage: [u8; 64usize],
    pub gameSpecificMessageSize: u16,
}
#[test]
fn bindgen_test_layout_HAL_MatchInfo() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_MatchInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_MatchInfo>(),
        140usize,
        concat!("Size of: ", stringify!(HAL_MatchInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_MatchInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_MatchInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(eventName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matchType) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(matchType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matchNumber) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(matchNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replayNumber) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(replayNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gameSpecificMessage) as usize - ptr as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(gameSpecificMessage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gameSpecificMessageSize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(gameSpecificMessageSize)
        )
    );
}
extern "C" {
    #[doc = " Sends an error to the driver station.\n\n @param isError   true for error, false for warning\n @param errorCode the error code\n @param isLVCode  true for a LV error code, false for a standard error code\n @param details   the details of the error\n @param location  the file location of the error\n @param callStack the callstack of the error\n @param printMsg  true to print the error message to stdout as well as to the\n DS\n @return the error code, or 0 for success"]
    pub fn HAL_SendError(
        isError: HAL_Bool,
        errorCode: i32,
        isLVCode: HAL_Bool,
        details: *const ::std::os::raw::c_char,
        location: *const ::std::os::raw::c_char,
        callStack: *const ::std::os::raw::c_char,
        printMsg: HAL_Bool,
    ) -> i32;
}
extern "C" {
    #[doc = " Set the print function used by HAL_SendError\n\n @param func Function called by HAL_SendError when stderr is printed"]
    pub fn HAL_SetPrintErrorImpl(
        func: ::std::option::Option<
            unsafe extern "C" fn(line: *const ::std::os::raw::c_char, size: usize),
        >,
    );
}
extern "C" {
    #[doc = " Sends a line to the driver station console.\n\n @param line the line to send (null terminated)\n @return the error code, or 0 for success"]
    pub fn HAL_SendConsoleLine(line: *const ::std::os::raw::c_char) -> i32;
}
extern "C" {
    #[doc = " Gets the current control word of the driver station.\n\n The control word contains the robot state.\n\n @param controlWord the control word (out)\n @return the error code, or 0 for success"]
    pub fn HAL_GetControlWord(controlWord: *mut HAL_ControlWord) -> i32;
}
extern "C" {
    #[doc = " Gets the current alliance station ID.\n\n @param[out] status the error code, or 0 for success\n @return the alliance station ID"]
    pub fn HAL_GetAllianceStation(status: *mut i32) -> HAL_AllianceStationID;
}
extern "C" {
    #[doc = " Gets the axes of a specific joystick.\n\n @param joystickNum the joystick number\n @param axes        the axes values (output)\n @return the error code, or 0 for success"]
    pub fn HAL_GetJoystickAxes(joystickNum: i32, axes: *mut HAL_JoystickAxes) -> i32;
}
extern "C" {
    #[doc = " Gets the POVs of a specific joystick.\n\n @param joystickNum the joystick number\n @param povs        the POV values (output)\n @return the error code, or 0 for success"]
    pub fn HAL_GetJoystickPOVs(joystickNum: i32, povs: *mut HAL_JoystickPOVs) -> i32;
}
extern "C" {
    #[doc = " Gets the buttons of a specific joystick.\n\n @param joystickNum the joystick number\n @param buttons     the button values (output)\n @return the error code, or 0 for success"]
    pub fn HAL_GetJoystickButtons(joystickNum: i32, buttons: *mut HAL_JoystickButtons) -> i32;
}
extern "C" {
    pub fn HAL_GetAllJoystickData(
        axes: *mut HAL_JoystickAxes,
        povs: *mut HAL_JoystickPOVs,
        buttons: *mut HAL_JoystickButtons,
    );
}
extern "C" {
    #[doc = " Retrieves the Joystick Descriptor for particular slot.\n\n @param joystickNum the joystick number\n @param[out] desc   descriptor (data transfer object) to fill in. desc is\n                    filled in regardless of success. In other words, if\n                    descriptor is not available, desc is filled in with\n                    default values matching the init-values in Java and C++\n                    Driver Station for when caller requests a too-large\n                    joystick index.\n @return error code reported from Network Comm back-end.  Zero is good,\n         nonzero is bad."]
    pub fn HAL_GetJoystickDescriptor(joystickNum: i32, desc: *mut HAL_JoystickDescriptor) -> i32;
}
extern "C" {
    #[doc = " Gets whether a specific joystick is considered to be an XBox controller.\n\n @param joystickNum the joystick number\n @return true if xbox, false otherwise"]
    pub fn HAL_GetJoystickIsXbox(joystickNum: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the type of joystick connected.\n\n This is device specific, and different depending on what system input type\n the joystick uses.\n\n @param joystickNum the joystick number\n @return the enumerated joystick type"]
    pub fn HAL_GetJoystickType(joystickNum: i32) -> i32;
}
extern "C" {
    #[doc = " Gets the name of a joystick.\n\n The returned array must be freed with HAL_FreeJoystickName.\n\n Will be null terminated.\n\n @param joystickNum the joystick number\n @return the joystick name"]
    pub fn HAL_GetJoystickName(joystickNum: i32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Frees a joystick name received with HAL_GetJoystickName\n\n @param name the name storage"]
    pub fn HAL_FreeJoystickName(name: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Gets the type of a specific joystick axis.\n\n This is device specific, and different depending on what system input type\n the joystick uses.\n\n @param joystickNum the joystick number\n @param axis        the axis number\n @return the enumerated axis type"]
    pub fn HAL_GetJoystickAxisType(joystickNum: i32, axis: i32) -> i32;
}
extern "C" {
    #[doc = " Set joystick outputs.\n\n @param joystickNum the joystick number\n @param outputs     bitmask of outputs, 1 for on 0 for off\n @param leftRumble  the left rumble value (0-FFFF)\n @param rightRumble the right rumble value (0-FFFF)\n @return the error code, or 0 for success"]
    pub fn HAL_SetJoystickOutputs(
        joystickNum: i32,
        outputs: i64,
        leftRumble: i32,
        rightRumble: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Return the approximate match time. The FMS does not send an official match\n time to the robots, but does send an approximate match time. The value will\n count down the time remaining in the current period (auto or teleop).\n Warning: This is not an official time (so it cannot be used to dispute ref\n calls or guarantee that a function will trigger before the match ends).\n\n <p>When connected to the real field, this number only changes in full integer\n increments, and always counts down.\n\n <p>When the DS is in practice mode, this number is a floating point number,\n and counts down.\n\n <p>When the DS is in teleop or autonomous mode, this number is a floating\n point number, and counts up.\n\n <p>Simulation matches DS behavior without an FMS connected.\n\n @param[out] status the error code, or 0 for success\n @return Time remaining in current match period (auto or teleop) in seconds"]
    pub fn HAL_GetMatchTime(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets if outputs are enabled by the control system.\n\n @return true if outputs are enabled"]
    pub fn HAL_GetOutputsEnabled() -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets info about a specific match.\n\n @param[in] info the match info (output)\n @return the error code, or 0 for success"]
    pub fn HAL_GetMatchInfo(info: *mut HAL_MatchInfo) -> i32;
}
extern "C" {
    #[doc = " Refresh the DS control word.\n\n @return true if updated"]
    pub fn HAL_RefreshDSData() -> HAL_Bool;
}
extern "C" {
    pub fn HAL_ProvideNewDataEventHandle(handle: WPI_EventHandle);
}
extern "C" {
    pub fn HAL_RemoveNewDataEventHandle(handle: WPI_EventHandle);
}
extern "C" {
    #[doc = " Sets the program starting flag in the DS.\n\n This is what changes the DS to showing robot code ready."]
    pub fn HAL_ObserveUserProgramStarting();
}
extern "C" {
    #[doc = " Sets the disabled flag in the DS.\n\n This is used for the DS to ensure the robot is properly responding to its\n state request. Ensure this gets called about every 50ms, or the robot will be\n disabled by the DS."]
    pub fn HAL_ObserveUserProgramDisabled();
}
extern "C" {
    #[doc = " Sets the autonomous enabled flag in the DS.\n\n This is used for the DS to ensure the robot is properly responding to its\n state request. Ensure this gets called about every 50ms, or the robot will be\n disabled by the DS."]
    pub fn HAL_ObserveUserProgramAutonomous();
}
extern "C" {
    #[doc = " Sets the teleoperated enabled flag in the DS.\n\n This is used for the DS to ensure the robot is properly responding to its\n state request. Ensure this gets called about every 50ms, or the robot will be\n disabled by the DS."]
    pub fn HAL_ObserveUserProgramTeleop();
}
extern "C" {
    #[doc = " Sets the test mode flag in the DS.\n\n This is used for the DS to ensure the robot is properly responding to its\n state request. Ensure this gets called about every 50ms, or the robot will be\n disabled by the DS."]
    pub fn HAL_ObserveUserProgramTest();
}
pub const HAL_EncoderIndexingType_HAL_kResetWhileHigh: HAL_EncoderIndexingType = 0;
pub const HAL_EncoderIndexingType_HAL_kResetWhileLow: HAL_EncoderIndexingType = 1;
pub const HAL_EncoderIndexingType_HAL_kResetOnFallingEdge: HAL_EncoderIndexingType = 2;
pub const HAL_EncoderIndexingType_HAL_kResetOnRisingEdge: HAL_EncoderIndexingType = 3;
#[doc = " The type of index pulse for the encoder."]
pub type HAL_EncoderIndexingType = i32;
pub const HAL_EncoderEncodingType_HAL_Encoder_k1X: HAL_EncoderEncodingType = 0;
pub const HAL_EncoderEncodingType_HAL_Encoder_k2X: HAL_EncoderEncodingType = 1;
pub const HAL_EncoderEncodingType_HAL_Encoder_k4X: HAL_EncoderEncodingType = 2;
#[doc = " The encoding scaling of the encoder."]
pub type HAL_EncoderEncodingType = i32;
extern "C" {
    #[doc = " Initializes an encoder.\n\n @param[in] digitalSourceHandleA the A source (either a HAL_DigitalHandle or a\n                                 HAL_AnalogTriggerHandle)\n @param[in] analogTriggerTypeA   the analog trigger type of the A source if it\n                                 is an analog trigger\n @param[in] digitalSourceHandleB the B source (either a HAL_DigitalHandle or a\n                                 HAL_AnalogTriggerHandle)\n @param[in] analogTriggerTypeB   the analog trigger type of the B source if it\n                                 is an analog trigger\n @param[in] reverseDirection     true to reverse the counting direction from\n                                 standard, otherwise false\n @param[in] encodingType         the encoding type\n @param[out] status              Error status variable. 0 on success.\n @return the created encoder handle"]
    pub fn HAL_InitializeEncoder(
        digitalSourceHandleA: HAL_Handle,
        analogTriggerTypeA: HAL_AnalogTriggerType,
        digitalSourceHandleB: HAL_Handle,
        analogTriggerTypeB: HAL_AnalogTriggerType,
        reverseDirection: HAL_Bool,
        encodingType: HAL_EncoderEncodingType,
        status: *mut i32,
    ) -> HAL_EncoderHandle;
}
extern "C" {
    #[doc = " Frees an encoder.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_FreeEncoder(encoderHandle: HAL_EncoderHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Indicates the encoder is used by a simulated device.\n\n @param handle the encoder handle\n @param device simulated device handle"]
    pub fn HAL_SetEncoderSimDevice(handle: HAL_EncoderHandle, device: HAL_SimDeviceHandle);
}
extern "C" {
    #[doc = " Gets the current counts of the encoder after encoding type scaling.\n\n This is scaled by the value passed during initialization to encodingType.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status Error status variable. 0 on success.\n @return the current scaled count"]
    pub fn HAL_GetEncoder(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the raw counts of the encoder.\n\n This is not scaled by any values.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status Error status variable. 0 on success.\n @return the raw encoder count"]
    pub fn HAL_GetEncoderRaw(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the encoder scale value.\n\n This is set by the value passed during initialization to encodingType.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the encoder scale value"]
    pub fn HAL_GetEncoderEncodingScale(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Reads the current encoder value.\n\n Read the value at this instant. It may still be running, so it reflects the\n current value. Next time it is read, it might have a different value.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_ResetEncoder(encoderHandle: HAL_EncoderHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the Period of the most recent count.\n\n Returns the time interval of the most recent count. This can be used for\n velocity calculations to determine shaft speed.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @returns the period of the last two pulses in units of seconds"]
    pub fn HAL_GetEncoderPeriod(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Sets the maximum period where the device is still considered \"moving\".\n\n Sets the maximum period where the device is considered moving. This value is\n used to determine the \"stopped\" state of the encoder using the\n HAL_GetEncoderStopped method.\n\n @param[in] encoderHandle the encoder handle\n @param[in] maxPeriod     the maximum period where the counted device is\n                          considered moving in seconds\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetEncoderMaxPeriod(
        encoderHandle: HAL_EncoderHandle,
        maxPeriod: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Determines if the clock is stopped.\n\n Determines if the clocked input is stopped based on the MaxPeriod value set\n using the SetMaxPeriod method. If the clock exceeds the MaxPeriod, then the\n device (and encoder) are assumed to be stopped and it returns true.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return true if the most recent encoder period exceeds the MaxPeriod value\n         set by SetMaxPeriod"]
    pub fn HAL_GetEncoderStopped(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the last direction the encoder value changed.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the last direction the encoder value changed"]
    pub fn HAL_GetEncoderDirection(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the current distance traveled by the encoder.\n\n This is the encoder count scaled by the distance per pulse set for the\n encoder.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the encoder distance (units are determined by the units\n                      passed to HAL_SetEncoderDistancePerPulse)"]
    pub fn HAL_GetEncoderDistance(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the current rate of the encoder.\n\n This is the encoder period scaled by the distance per pulse set for the\n encoder.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the encoder rate (units are determined by the units passed to\n         HAL_SetEncoderDistancePerPulse, time value is seconds)"]
    pub fn HAL_GetEncoderRate(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Sets the minimum rate to be considered moving by the encoder.\n\n Units need to match what is set by HAL_SetEncoderDistancePerPulse, with time\n as seconds.\n\n @param[in] encoderHandle the encoder handle\n @param[in] minRate       the minimum rate to be considered moving (units are\n                          determined by the units passed to\n                          HAL_SetEncoderDistancePerPulse, time value is\n                          seconds)\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetEncoderMinRate(encoderHandle: HAL_EncoderHandle, minRate: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the distance traveled per encoder pulse. This is used as a scaling\n factor for the rate and distance calls.\n\n @param[in] encoderHandle    the encoder handle\n @param[in] distancePerPulse the distance traveled per encoder pulse (units\n                             user defined)\n @param[out] status          Error status variable. 0 on success."]
    pub fn HAL_SetEncoderDistancePerPulse(
        encoderHandle: HAL_EncoderHandle,
        distancePerPulse: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets if to reverse the direction of the encoder.\n\n Note that this is not a toggle. It is an absolute set.\n\n @param[in] encoderHandle    the encoder handle\n @param[in] reverseDirection true to reverse the direction, false to not.\n @param[out] status          Error status variable. 0 on success."]
    pub fn HAL_SetEncoderReverseDirection(
        encoderHandle: HAL_EncoderHandle,
        reverseDirection: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the number of encoder samples to average when calculating encoder rate.\n\n @param[in] encoderHandle    the encoder handle\n @param[in] samplesToAverage the number of samples to average\n @param[out] status          Error status variable. 0 on success."]
    pub fn HAL_SetEncoderSamplesToAverage(
        encoderHandle: HAL_EncoderHandle,
        samplesToAverage: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the current samples to average value.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the current samples to average value"]
    pub fn HAL_GetEncoderSamplesToAverage(
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Sets the source for an index pulse on the encoder.\n\n The index pulse can be used to cause an encoder to reset based on an external\n input.\n\n @param[in] encoderHandle       the encoder handle\n @param[in] digitalSourceHandle the index source handle (either a\n                                HAL_AnalogTriggerHandle or a\n                                HAL_DigitalHandle)\n @param[in] analogTriggerType   the analog trigger type if the source is an\n                                analog trigger\n @param[in] type                the index triggering type\n @param[out] status             Error status variable. 0 on success."]
    pub fn HAL_SetEncoderIndexSource(
        encoderHandle: HAL_EncoderHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        type_: HAL_EncoderIndexingType,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the FPGA index of the encoder.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the FPGA index of the encoder"]
    pub fn HAL_GetEncoderFPGAIndex(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the decoding scale factor of the encoder.\n\n This is used to perform the scaling from raw to type scaled values.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the scale value for the encoder"]
    pub fn HAL_GetEncoderDecodingScaleFactor(
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Gets the user set distance per pulse of the encoder.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the set distance per pulse"]
    pub fn HAL_GetEncoderDistancePerPulse(
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Gets the encoding type of the encoder.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the encoding type"]
    pub fn HAL_GetEncoderEncodingType(
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> HAL_EncoderEncodingType;
}
extern "C" {
    #[doc = " Reports a hardware usage to the HAL.\n\n @param resource       the used resource\n @param instanceNumber the instance of the resource\n @param context        a user specified context index\n @param feature        a user specified feature string\n @return               the index of the added value in NetComm"]
    pub fn HAL_Report(
        resource: i32,
        instanceNumber: i32,
        context: i32,
        feature: *const ::std::os::raw::c_char,
    ) -> i64;
}
pub const HAL_RuntimeType_HAL_Runtime_RoboRIO: HAL_RuntimeType = 0;
pub const HAL_RuntimeType_HAL_Runtime_RoboRIO2: HAL_RuntimeType = 1;
pub const HAL_RuntimeType_HAL_Runtime_Simulation: HAL_RuntimeType = 2;
#[doc = " @defgroup hal_capi WPILib HAL API\n Hardware Abstraction Layer (HAL) to hardware or simulator\n @{"]
pub type HAL_RuntimeType = i32;
extern "C" {
    #[doc = " Gets the last error set on this thread, or the message for the status code.\n\n If passed HAL_USE_LAST_ERROR, the last error set on the thread will be\n returned.\n\n @param[out] status the status code, set to the error status code if input is\n               HAL_USE_LAST_ERROR\n @return the error message for the code. This does not need to be freed,\n               but can be overwritten by another hal call on the same thread."]
    pub fn HAL_GetLastError(status: *mut i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gets the error message for a specific status code.\n\n @param code the status code\n @return the error message for the code. This does not need to be freed."]
    pub fn HAL_GetErrorMessage(code: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the FPGA Version number.\n\n For now, expect this to be competition year.\n\n @param[out] status the error code, or 0 for success\n @return FPGA Version number."]
    pub fn HAL_GetFPGAVersion(status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Returns the FPGA Revision number.\n\n The format of the revision is 3 numbers.\n The 12 most significant bits are the Major Revision.\n the next 8 bits are the Minor Revision.\n The 12 least significant bits are the Build Number.\n\n @param[out] status the error code, or 0 for success\n @return FPGA Revision number."]
    pub fn HAL_GetFPGARevision(status: *mut i32) -> i64;
}
extern "C" {
    #[doc = " Returns the roboRIO serial number.\n\n @param[out] buffer The roboRIO serial number.\n @param size The maximum characters to copy into buffer.\n @return Number of characters copied into buffer."]
    pub fn HAL_GetSerialNumber(buffer: *mut ::std::os::raw::c_char, size: usize) -> usize;
}
extern "C" {
    #[doc = " Returns the comments from the roboRIO web interface.\n\n @param[out] buffer The comments string.\n @param size The maximum characters to copy into buffer.\n @return Number of characters copied into buffer."]
    pub fn HAL_GetComments(buffer: *mut ::std::os::raw::c_char, size: usize) -> usize;
}
extern "C" {
    #[doc = " Returns the team number configured for the robot controller.\n @return team number, or 0 if not found."]
    pub fn HAL_GetTeamNumber() -> i32;
}
extern "C" {
    #[doc = " Returns the runtime type of the HAL.\n\n @return HAL Runtime Type"]
    pub fn HAL_GetRuntimeType() -> HAL_RuntimeType;
}
extern "C" {
    #[doc = " Gets the state of the \"USER\" button on the roboRIO.\n\n @warning the User Button is used to stop user programs from automatically\n loading if it is held for more then 5 seconds. Because of this, it's not\n recommended to be used by teams for any other purpose.\n\n @param[out] status the error code, or 0 for success\n @return true if the button is currently pressed down"]
    pub fn HAL_GetFPGAButton(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets if the system outputs are currently active.\n\n @param[out] status the error code, or 0 for success\n @return true if the system outputs are active, false if disabled"]
    pub fn HAL_GetSystemActive(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets if the system is in a browned out state.\n\n @param[out] status the error code, or 0 for success\n @return true if the system is in a low voltage brown out, false otherwise"]
    pub fn HAL_GetBrownedOut(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets a port handle for a specific channel.\n\n The created handle does not need to be freed.\n\n @param channel the channel number\n @return the created port"]
    pub fn HAL_GetPort(channel: i32) -> HAL_PortHandle;
}
extern "C" {
    #[doc = " Gets a port handle for a specific channel and module.\n\n This is expected to be used for PCMs, as the roboRIO does not work with\n modules anymore.\n\n The created handle does not need to be freed.\n\n @param module  the module number\n @param channel the channel number\n @return the created port"]
    pub fn HAL_GetPortWithModule(module: i32, channel: i32) -> HAL_PortHandle;
}
extern "C" {
    #[doc = " Reads the microsecond-resolution timer on the FPGA.\n\n @param[out] status the error code, or 0 for success\n @return The current time in microseconds according to the FPGA (since FPGA\n reset)."]
    pub fn HAL_GetFPGATime(status: *mut i32) -> u64;
}
extern "C" {
    #[doc = " Given an 32 bit FPGA time, expand it to the nearest likely 64 bit FPGA time.\n\n Note: This is making the assumption that the timestamp being converted is\n always in the past.  If you call this with a future timestamp, it probably\n will make it in the past.  If you wait over 70 minutes between capturing the\n bottom 32 bits of the timestamp and expanding it, you will be off by\n multiples of 1<<32 microseconds.\n\n @param[in] unexpandedLower 32 bit FPGA time\n @param[out] status the error code, or 0 for success\n @return The current time in microseconds according to the FPGA (since FPGA\n         reset) as a 64 bit number."]
    pub fn HAL_ExpandFPGATime(unexpandedLower: u32, status: *mut i32) -> u64;
}
extern "C" {
    #[doc = " Gets the current state of the Robot Signal Light (RSL).\n\n @param[out] status the error code, or 0 for success\n @return The current state of the RSL- true if on, false if off"]
    pub fn HAL_GetRSLState(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets if the system time is valid.\n\n @param[out] status the error code, or 0 for success\n @return True if the system time is valid, false otherwise"]
    pub fn HAL_GetSystemTimeValid(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Call this to start up HAL. This is required for robot programs.\n\n This must be called before any other HAL functions. Failure to do so will\n result in undefined behavior, and likely segmentation faults. This means that\n any statically initialized variables in a program MUST call this function in\n their constructors if they want to use other HAL calls.\n\n The common parameters are 500 for timeout and 0 for mode.\n\n This function is safe to call from any thread, and as many times as you wish.\n It internally guards from any reentrancy.\n\n The applicable modes are:\n   0: Try to kill an existing HAL from another program, if not successful,\n error.\n   1: Force kill a HAL from another program.\n   2: Just warn if another hal exists and cannot be killed. Will likely result\n in undefined behavior.\n\n @param timeout the initialization timeout (ms)\n @param mode    the initialization mode (see remarks)\n @return true if initialization was successful, otherwise false."]
    pub fn HAL_Initialize(timeout: i32, mode: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Call this to shut down HAL.\n\n This must be called at termination of the robot program to avoid potential\n segmentation faults with simulation extensions at exit."]
    pub fn HAL_Shutdown();
}
extern "C" {
    #[doc = " Calls registered SimPeriodic \"before\" callbacks (only in simulation mode).\n This should be called prior to user code periodic simulation functions."]
    pub fn HAL_SimPeriodicBefore();
}
extern "C" {
    #[doc = " Calls registered SimPeriodic \"after\" callbacks (only in simulation mode).\n This should be called after user code periodic simulation functions."]
    pub fn HAL_SimPeriodicAfter();
}
pub const HAL_I2CPort_HAL_I2C_kInvalid: HAL_I2CPort = -1;
pub const HAL_I2CPort_HAL_I2C_kOnboard: HAL_I2CPort = 0;
pub const HAL_I2CPort_HAL_I2C_kMXP: HAL_I2CPort = 1;
#[doc = " @defgroup hal_i2c I2C Functions\n @ingroup hal_capi\n @{"]
pub type HAL_I2CPort = i32;
extern "C" {
    #[doc = " Initializes the I2C port.\n\n Opens the port if necessary and saves the handle.\n If opening the MXP port, also sets up the channel functions appropriately.\n\n @param[in] port    The port to open, 0 for the on-board, 1 for the MXP.\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_InitializeI2C(port: HAL_I2CPort, status: *mut i32);
}
extern "C" {
    #[doc = " Generic I2C read/write transaction.\n\n This is a lower-level interface to the I2C hardware giving you more control\n over each transaction.\n\n @param port The I2C port, 0 for the on-board, 1 for the MXP.\n @param deviceAddress The address of the register on the device to be\n                      read/written.\n @param dataToSend Buffer of data to send as part of the transaction.\n @param sendSize Number of bytes to send as part of the transaction.\n @param dataReceived Buffer to read data into.\n @param receiveSize Number of bytes to read from the device.\n @return >= 0 on success or -1 on transfer abort."]
    pub fn HAL_TransactionI2C(
        port: HAL_I2CPort,
        deviceAddress: i32,
        dataToSend: *const u8,
        sendSize: i32,
        dataReceived: *mut u8,
        receiveSize: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Executes a write transaction with the device.\n\n Writes a single byte to a register on a device and wait until the\n   transaction is complete.\n\n @param port The I2C port, 0 for the on-board, 1 for the MXP.\n @param deviceAddress The address of the register on the device to be\n                      written.\n @param dataToSend The byte to write to the register on the device.\n @param sendSize Number of bytes to send.\n @return >= 0 on success or -1 on transfer abort."]
    pub fn HAL_WriteI2C(
        port: HAL_I2CPort,
        deviceAddress: i32,
        dataToSend: *const u8,
        sendSize: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Executes a read transaction with the device.\n\n Reads bytes from a device.\n Most I2C devices will auto-increment the register pointer internally allowing\n   you to read consecutive registers on a device in a single transaction.\n\n @param port The I2C port, 0 for the on-board, 1 for the MXP.\n @param deviceAddress The register to read first in the transaction.\n @param count The number of bytes to read in the transaction.\n @param buffer A pointer to the array of bytes to store the data read from the\n device.\n @return >= 0 on success or -1 on transfer abort."]
    pub fn HAL_ReadI2C(port: HAL_I2CPort, deviceAddress: i32, buffer: *mut u8, count: i32) -> i32;
}
extern "C" {
    #[doc = " Closes an I2C port\n\n @param port The I2C port, 0 for the on-board, 1 for the MXP."]
    pub fn HAL_CloseI2C(port: HAL_I2CPort);
}
extern "C" {
    #[doc = " Initializes an interrupt.\n\n @param[out] status Error status variable. 0 on success.\n @return the created interrupt handle"]
    pub fn HAL_InitializeInterrupts(status: *mut i32) -> HAL_InterruptHandle;
}
extern "C" {
    #[doc = " Frees an interrupt.\n\n @param interruptHandle the interrupt handle"]
    pub fn HAL_CleanInterrupts(interruptHandle: HAL_InterruptHandle);
}
extern "C" {
    #[doc = " Waits for the defined interrupt to occur.\n\n @param[in] interruptHandle the interrupt handle\n @param[in] timeout         timeout in seconds\n @param[in] ignorePrevious  if true, ignore interrupts that happened before\n                            waitForInterrupt was called\n @param[out] status         Error status variable. 0 on success.\n @return the mask of interrupts that fired"]
    pub fn HAL_WaitForInterrupt(
        interruptHandle: HAL_InterruptHandle,
        timeout: f64,
        ignorePrevious: HAL_Bool,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Waits for any interrupt covered by the mask to occur.\n\n @param[in] interruptHandle the interrupt handle to use for the context\n @param[in] mask            the mask of interrupts to wait for\n @param[in] timeout         timeout in seconds\n @param[in] ignorePrevious  if true, ignore interrupts that happened before\n                            waitForInterrupt was called\n @param[out] status         Error status variable. 0 on success.\n @return the mask of interrupts that fired"]
    pub fn HAL_WaitForMultipleInterrupts(
        interruptHandle: HAL_InterruptHandle,
        mask: i64,
        timeout: f64,
        ignorePrevious: HAL_Bool,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Returns the timestamp for the rising interrupt that occurred most recently.\n\n This is in the same time domain as HAL_GetFPGATime().  It only contains the\n bottom 32 bits of the timestamp.  If your robot has been running for over 1\n hour, you will need to fill in the upper 32 bits yourself.\n\n @param[in] interruptHandle the interrupt handle\n @param[out] status         Error status variable. 0 on success.\n @return timestamp in microseconds since FPGA Initialization"]
    pub fn HAL_ReadInterruptRisingTimestamp(
        interruptHandle: HAL_InterruptHandle,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Returns the timestamp for the falling interrupt that occurred most recently.\n\n This is in the same time domain as HAL_GetFPGATime().  It only contains the\n bottom 32 bits of the timestamp.  If your robot has been running for over 1\n hour, you will need to fill in the upper 32 bits yourself.\n\n @param[in] interruptHandle the interrupt handle\n @param[out] status         Error status variable. 0 on success.\n @return timestamp in microseconds since FPGA Initialization"]
    pub fn HAL_ReadInterruptFallingTimestamp(
        interruptHandle: HAL_InterruptHandle,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Requests interrupts on a specific digital source.\n\n @param[in] interruptHandle     the interrupt handle\n @param[in] digitalSourceHandle the digital source handle (either a\n                                HAL_AnalogTriggerHandle or a\n                                HAL_DigitalHandle)\n @param[in] analogTriggerType   the trigger type if the source is an\n                                AnalogTrigger\n @param[out] status             Error status variable. 0 on success."]
    pub fn HAL_RequestInterrupts(
        interruptHandle: HAL_InterruptHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the edges to trigger the interrupt on.\n\n Note that both edges triggered is a valid configuration.\n\n @param[in] interruptHandle the interrupt handle\n @param[in] risingEdge      true for triggering on rising edge\n @param[in] fallingEdge     true for triggering on falling edge\n @param[out] status         Error status variable. 0 on success."]
    pub fn HAL_SetInterruptUpSourceEdge(
        interruptHandle: HAL_InterruptHandle,
        risingEdge: HAL_Bool,
        fallingEdge: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Releases a waiting interrupt.\n\n This will release both rising and falling waiters.\n\n @param[in] interruptHandle the interrupt handle to release\n @param[out] status         Error status variable. 0 on success."]
    pub fn HAL_ReleaseWaitingInterrupt(interruptHandle: HAL_InterruptHandle, status: *mut i32);
}
pub const HAL_RadioLEDState_HAL_RadioLED_kOff: HAL_RadioLEDState = 0;
pub const HAL_RadioLEDState_HAL_RadioLED_kGreen: HAL_RadioLEDState = 1;
pub const HAL_RadioLEDState_HAL_RadioLED_kRed: HAL_RadioLEDState = 2;
pub const HAL_RadioLEDState_HAL_RadioLED_kOrange: HAL_RadioLEDState = 3;
pub type HAL_RadioLEDState = i32;
extern "C" {
    #[doc = " Set the state of the \"Radio\" LED.\n @param state The state to set the LED to.\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetRadioLEDState(state: HAL_RadioLEDState, status: *mut i32);
}
extern "C" {
    #[doc = " Get the state of the \"Radio\" LED.\n\n @param[out] status the error code, or 0 for success\n @return The state of the LED."]
    pub fn HAL_GetRadioLEDState(status: *mut i32) -> HAL_RadioLEDState;
}
extern "C" {
    #[doc = " Sets up the system to run the provided main loop in the main thread (e.g.\n the thread in which main() starts execution) and run the robot code in a\n separate thread.\n\n Normally the robot code runs in the main thread, but some GUI systems\n require the GUI be run in the main thread.\n\n To be effective, this function must be called before the robot code starts\n the main loop (e.g. by frc::StartRobot()).\n\n @param param parameter data to pass to mainFunc and exitFunc\n @param mainFunc the function to be run when HAL_RunMain() is called.\n @param exitFunc the function to be run when HAL_ExitMain() is called."]
    pub fn HAL_SetMain(
        param: *mut ::std::os::raw::c_void,
        mainFunc: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        exitFunc: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    #[doc = " Returns true if HAL_SetMain() has been called.\n\n @return True if HAL_SetMain() has been called, false otherwise."]
    pub fn HAL_HasMain() -> HAL_Bool;
}
extern "C" {
    #[doc = " Runs the main function provided to HAL_SetMain().\n\n If HAL_SetMain() has not been called, simply sleeps until HAL_ExitMain()\n is called."]
    pub fn HAL_RunMain();
}
extern "C" {
    #[doc = " Causes HAL_RunMain() to exit.\n\n If HAL_SetMain() has been called, this calls the exit function provided\n to that function."]
    pub fn HAL_ExitMain();
}
extern "C" {
    #[doc = " Initializes a notifier.\n\n A notifier is an FPGA controller timer that triggers at requested intervals\n based on the FPGA time. This can be used to make precise control loops.\n\n @param[out] status Error status variable. 0 on success.\n @return the created notifier"]
    pub fn HAL_InitializeNotifier(status: *mut i32) -> HAL_NotifierHandle;
}
extern "C" {
    #[doc = " Sets the HAL notifier thread priority.\n\n The HAL notifier thread is responsible for managing the FPGA's notifier\n interrupt and waking up user's Notifiers when it's their time to run.\n Giving the HAL notifier thread real-time priority helps ensure the user's\n real-time Notifiers, if any, are notified to run in a timely manner.\n\n @param[in] realTime Set to true to set a real-time priority, false for\n                     standard priority.\n @param[in] priority Priority to set the thread to. For real-time, this is\n                     1-99 with 99 being highest. For non-real-time, this is\n                     forced to 0. See \"man 7 sched\" for more details.\n @param[out] status  Error status variable. 0 on success.\n @return True on success."]
    pub fn HAL_SetNotifierThreadPriority(
        realTime: HAL_Bool,
        priority: i32,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets the name of a notifier.\n\n @param[in] notifierHandle the notifier handle\n @param[in] name name\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetNotifierName(
        notifierHandle: HAL_NotifierHandle,
        name: *const ::std::os::raw::c_char,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Stops a notifier from running.\n\n This will cause any call into HAL_WaitForNotifierAlarm to return with time =\n 0.\n\n @param[in] notifierHandle the notifier handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_StopNotifier(notifierHandle: HAL_NotifierHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Cleans a notifier.\n\n Note this also stops a notifier if it is already running.\n\n @param[in] notifierHandle the notifier handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_CleanNotifier(notifierHandle: HAL_NotifierHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Updates the trigger time for a notifier.\n\n Note that this time is an absolute time relative to HAL_GetFPGATime()\n\n @param[in] notifierHandle the notifier handle\n @param[in] triggerTime    the updated trigger time\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_UpdateNotifierAlarm(
        notifierHandle: HAL_NotifierHandle,
        triggerTime: u64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Cancels the next notifier alarm.\n\n This does not cause HAL_WaitForNotifierAlarm to return.\n\n @param[in] notifierHandle the notifier handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_CancelNotifierAlarm(notifierHandle: HAL_NotifierHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Waits for the next alarm for the specific notifier.\n\n This is a blocking call until either the time elapses or HAL_StopNotifier\n gets called. If the latter occurs, this function will return zero and any\n loops using this function should exit. Failing to do so can lead to\n use-after-frees.\n\n @param[in] notifierHandle the notifier handle\n @param[out] status        Error status variable. 0 on success.\n @return the FPGA time the notifier returned"]
    pub fn HAL_WaitForNotifierAlarm(notifierHandle: HAL_NotifierHandle, status: *mut i32) -> u64;
}
extern "C" {
    #[doc = " Initializes a PWM port.\n\n @param[in] portHandle the port to initialize\n @param[in] allocationLocation  the location where the allocation is occurring\n                                (can be null)\n @param[out] status             Error status variable. 0 on success.\n @return the created pwm handle"]
    pub fn HAL_InitializePWMPort(
        portHandle: HAL_PortHandle,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_DigitalHandle;
}
extern "C" {
    #[doc = " Frees a PWM port.\n\n @param[in] pwmPortHandle the pwm handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_FreePWMPort(pwmPortHandle: HAL_DigitalHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Checks if a pwm channel is valid.\n\n @param channel the channel to check\n @return true if the channel is valid, otherwise false"]
    pub fn HAL_CheckPWMChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets the configuration settings for the PWM channel.\n\n All values are in microseconds.\n\n @param[in] pwmPortHandle  the PWM handle\n @param[in] maxPwm         the maximum PWM value\n @param[in] deadbandMaxPwm the high range of the center deadband\n @param[in] centerPwm      the center PWM value\n @param[in] deadbandMinPwm the low range of the center deadband\n @param[in] minPwm         the minimum PWM value\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_SetPWMConfigMicroseconds(
        pwmPortHandle: HAL_DigitalHandle,
        maxPwm: i32,
        deadbandMaxPwm: i32,
        centerPwm: i32,
        deadbandMinPwm: i32,
        minPwm: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the pwm configuration settings for the PWM channel.\n\n Values are in microseconds.\n\n @param[in] pwmPortHandle  the PWM handle\n @param[in] maxPwm         the maximum PWM value\n @param[in] deadbandMaxPwm the high range of the center deadband\n @param[in] centerPwm      the center PWM value\n @param[in] deadbandMinPwm the low range of the center deadband\n @param[in] minPwm         the minimum PWM value\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_GetPWMConfigMicroseconds(
        pwmPortHandle: HAL_DigitalHandle,
        maxPwm: *mut i32,
        deadbandMaxPwm: *mut i32,
        centerPwm: *mut i32,
        deadbandMinPwm: *mut i32,
        minPwm: *mut i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets if the FPGA should output the center value if the input value is within\n the deadband.\n\n @param[in] pwmPortHandle     the PWM handle\n @param[in] eliminateDeadband true to eliminate deadband, otherwise false\n @param[out] status           Error status variable. 0 on success."]
    pub fn HAL_SetPWMEliminateDeadband(
        pwmPortHandle: HAL_DigitalHandle,
        eliminateDeadband: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the current eliminate deadband value.\n\n @param[in] pwmPortHandle the PWM handle\n @param[out] status       Error status variable. 0 on success.\n @return true if set, otherwise false"]
    pub fn HAL_GetPWMEliminateDeadband(
        pwmPortHandle: HAL_DigitalHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets a PWM channel to the desired pulse width in microseconds.\n\n\n @param[in] pwmPortHandle the PWM handle\n @param[in] microsecondPulseTime  the PWM value to set\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetPWMPulseTimeMicroseconds(
        pwmPortHandle: HAL_DigitalHandle,
        microsecondPulseTime: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets a PWM channel to the desired scaled value.\n\n The values range from -1 to 1 and the period is controlled by the PWM Period\n and MinHigh registers.\n\n @param[in] pwmPortHandle the PWM handle\n @param[in] speed         the scaled PWM value to set\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetPWMSpeed(pwmPortHandle: HAL_DigitalHandle, speed: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Sets a PWM channel to the desired position value.\n\n The values range from 0 to 1 and the period is controlled by the PWM Period\n and MinHigh registers.\n\n @param[in] pwmPortHandle the PWM handle\n @param[in] position      the positional PWM value to set\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetPWMPosition(pwmPortHandle: HAL_DigitalHandle, position: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Sets a PWM channel to be disabled.\n\n The channel is disabled until the next time it is set. Note this is different\n from just setting a 0 speed, as this will actively stop all signaling on the\n channel.\n\n @param[in] pwmPortHandle the PWM handle.\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetPWMDisabled(pwmPortHandle: HAL_DigitalHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the current microsecond pulse time from a PWM channel.\n\n @param[in] pwmPortHandle the PWM handle\n @param[out] status       Error status variable. 0 on success.\n @return the current PWM microsecond pulse time"]
    pub fn HAL_GetPWMPulseTimeMicroseconds(
        pwmPortHandle: HAL_DigitalHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets a scaled value from a PWM channel.\n\n The values range from -1 to 1.\n\n @param[in] pwmPortHandle the PWM handle\n @param[out] status       Error status variable. 0 on success.\n @return the current speed PWM value"]
    pub fn HAL_GetPWMSpeed(pwmPortHandle: HAL_DigitalHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets a position value from a PWM channel.\n\n The values range from 0 to 1.\n\n @param[in] pwmPortHandle the PWM handle\n @param[out] status       Error status variable. 0 on success.\n @return the current positional PWM value"]
    pub fn HAL_GetPWMPosition(pwmPortHandle: HAL_DigitalHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Forces a PWM signal to go to 0 temporarily.\n\n @param[in] pwmPortHandle the PWM handle.\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_LatchPWMZero(pwmPortHandle: HAL_DigitalHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets how how often the PWM signal is squelched, thus scaling the period.\n\n @param[in] pwmPortHandle the PWM handle.\n @param[in] squelchMask   the 2-bit mask of outputs to squelch\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetPWMPeriodScale(
        pwmPortHandle: HAL_DigitalHandle,
        squelchMask: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the PWM output to be a continuous high signal while enabled.\n\n @param[in] pwmPortHandle the PWM handle.\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetPWMAlwaysHighMode(pwmPortHandle: HAL_DigitalHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the loop timing of the PWM system.\n\n @param[out] status Error status variable. 0 on success.\n @return the loop time"]
    pub fn HAL_GetPWMLoopTiming(status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the pwm starting cycle time.\n\n This time is relative to the FPGA time.\n\n @param[out] status Error status variable. 0 on success.\n @return the pwm cycle start time"]
    pub fn HAL_GetPWMCycleStartTime(status: *mut i32) -> u64;
}
extern "C" {
    #[doc = " Gets the number of analog accumulators in the current system.\n\n @return the number of analog accumulators"]
    pub fn HAL_GetNumAccumulators() -> i32;
}
extern "C" {
    #[doc = " Gets the number of analog triggers in the current system.\n\n @return the number of analog triggers"]
    pub fn HAL_GetNumAnalogTriggers() -> i32;
}
extern "C" {
    #[doc = " Gets the number of analog inputs in the current system.\n\n @return the number of analog inputs"]
    pub fn HAL_GetNumAnalogInputs() -> i32;
}
extern "C" {
    #[doc = " Gets the number of analog outputs in the current system.\n\n @return the number of analog outputs"]
    pub fn HAL_GetNumAnalogOutputs() -> i32;
}
extern "C" {
    #[doc = " Gets the number of counters in the current system.\n\n @return the number of counters"]
    pub fn HAL_GetNumCounters() -> i32;
}
extern "C" {
    #[doc = " Gets the number of digital headers in the current system.\n\n @return the number of digital headers"]
    pub fn HAL_GetNumDigitalHeaders() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PWM headers in the current system.\n\n @return the number of PWM headers"]
    pub fn HAL_GetNumPWMHeaders() -> i32;
}
extern "C" {
    #[doc = " Gets the number of digital channels in the current system.\n\n @return the number of digital channels"]
    pub fn HAL_GetNumDigitalChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PWM channels in the current system.\n\n @return the number of PWM channels"]
    pub fn HAL_GetNumPWMChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of digital IO PWM outputs in the current system.\n\n @return the number of digital IO PWM outputs"]
    pub fn HAL_GetNumDigitalPWMOutputs() -> i32;
}
extern "C" {
    #[doc = " Gets the number of quadrature encoders in the current system.\n\n @return the number of quadrature encoders"]
    pub fn HAL_GetNumEncoders() -> i32;
}
extern "C" {
    #[doc = " Gets the number of interrupts in the current system.\n\n @return the number of interrupts"]
    pub fn HAL_GetNumInterrupts() -> i32;
}
extern "C" {
    #[doc = " Gets the number of relay channels in the current system.\n\n @return the number of relay channels"]
    pub fn HAL_GetNumRelayChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of relay headers in the current system.\n\n @return the number of relay headers"]
    pub fn HAL_GetNumRelayHeaders() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PCM modules in the current system.\n\n @return the number of PCM modules"]
    pub fn HAL_GetNumCTREPCMModules() -> i32;
}
extern "C" {
    #[doc = " Gets the number of solenoid channels in the current system.\n\n @return the number of solenoid channels"]
    pub fn HAL_GetNumCTRESolenoidChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PDP modules in the current system.\n\n @return the number of PDP modules"]
    pub fn HAL_GetNumCTREPDPModules() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PDP channels in the current system.\n\n @return the number of PDP channels"]
    pub fn HAL_GetNumCTREPDPChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PDH modules in the current system.\n\n @return the number of PDH modules"]
    pub fn HAL_GetNumREVPDHModules() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PDH channels in the current system.\n\n @return the number of PDH channels"]
    pub fn HAL_GetNumREVPDHChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PH modules in the current system.\n\n @return the number of PH modules"]
    pub fn HAL_GetNumREVPHModules() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PH channels in the current system.\n\n @return the number of PH channels"]
    pub fn HAL_GetNumREVPHChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of duty cycle inputs in the current system.\n\n @return the number of Duty Cycle inputs"]
    pub fn HAL_GetNumDutyCycles() -> i32;
}
extern "C" {
    #[doc = " Gets the number of addressable LED generators in the current system.\n\n @return the number of Addressable LED generators"]
    pub fn HAL_GetNumAddressableLEDs() -> i32;
}
extern "C" {
    #[doc = " Gets the roboRIO input voltage.\n\n @param[out] status the error code, or 0 for success\n @return the input voltage (volts)"]
    pub fn HAL_GetVinVoltage(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the roboRIO input current.\n\n @param[out] status the error code, or 0 for success\n @return the input current (amps)"]
    pub fn HAL_GetVinCurrent(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the 6V rail voltage.\n\n @param[out] status the error code, or 0 for success\n @return the 6V rail voltage (volts)"]
    pub fn HAL_GetUserVoltage6V(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the 6V rail current.\n\n @param[out] status the error code, or 0 for success\n @return the 6V rail current (amps)"]
    pub fn HAL_GetUserCurrent6V(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the active state of the 6V rail.\n\n @param[out] status the error code, or 0 for success\n @return true if the rail is active, otherwise false"]
    pub fn HAL_GetUserActive6V(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the fault count for the 6V rail.\n\n @param[out] status the error code, or 0 for success\n @return the number of 6V fault counts"]
    pub fn HAL_GetUserCurrentFaults6V(status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Enables or disables the 6V rail.\n\n @param enabled whether the rail should be enabled\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetUserRailEnabled6V(enabled: HAL_Bool, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the 5V rail voltage.\n\n @param[out] status the error code, or 0 for success\n @return the 5V rail voltage (volts)"]
    pub fn HAL_GetUserVoltage5V(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the 5V rail current.\n\n @param[out] status the error code, or 0 for success\n @return the 5V rail current (amps)"]
    pub fn HAL_GetUserCurrent5V(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the active state of the 5V rail.\n\n @param[out] status the error code, or 0 for success\n @return true if the rail is active, otherwise false"]
    pub fn HAL_GetUserActive5V(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the fault count for the 5V rail.\n\n @param[out] status the error code, or 0 for success\n @return the number of 5V fault counts"]
    pub fn HAL_GetUserCurrentFaults5V(status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Enables or disables the 5V rail.\n\n @param enabled whether the rail should be enabled\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetUserRailEnabled5V(enabled: HAL_Bool, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the 3V3 rail voltage.\n\n @param[out] status the error code, or 0 for success\n @return the 3V3 rail voltage (volts)"]
    pub fn HAL_GetUserVoltage3V3(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the 3V3 rail current.\n\n @param[out] status the error code, or 0 for success\n @return the 3V3 rail current (amps)"]
    pub fn HAL_GetUserCurrent3V3(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the active state of the 3V3 rail.\n\n @param[out] status the error code, or 0 for success\n @return true if the rail is active, otherwise false"]
    pub fn HAL_GetUserActive3V3(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the fault count for the 3V3 rail.\n\n @param[out] status the error code, or 0 for success\n @return the number of 3V3 fault counts"]
    pub fn HAL_GetUserCurrentFaults3V3(status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Enables or disables the 3V3 rail.\n\n @param enabled whether the rail should be enabled\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetUserRailEnabled3V3(enabled: HAL_Bool, status: *mut i32);
}
extern "C" {
    #[doc = " Get the current brownout voltage setting.\n\n @param[out] status the error code, or 0 for success\n @return The brownout voltage"]
    pub fn HAL_GetBrownoutVoltage(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Set the voltage the roboRIO will brownout and disable all outputs.\n\n Note that this only does anything on the roboRIO 2.\n On the roboRIO it is a no-op.\n\n @param[in] voltage The brownout voltage\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetBrownoutVoltage(voltage: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Get the current CPU temperature in degrees Celsius\n\n @param[out] status the error code, or 0 for success\n @return current CPU temperature in degrees Celsius"]
    pub fn HAL_GetCPUTemp(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Initializes a relay.\n\n Note this call will only initialize either the forward or reverse port of the\n relay. If you need both, you will need to initialize 2 relays.\n\n @param[in] portHandle         the port handle to initialize\n @param[in] fwd                true for the forward port, false for the\n                               reverse port\n @param[in] allocationLocation the location where the allocation is occurring\n                               (can be null)\n @param[out] status            Error status variable. 0 on success.\n @return the created relay handle"]
    pub fn HAL_InitializeRelayPort(
        portHandle: HAL_PortHandle,
        fwd: HAL_Bool,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_RelayHandle;
}
extern "C" {
    #[doc = " Frees a relay port.\n\n @param relayPortHandle the relay handle"]
    pub fn HAL_FreeRelayPort(relayPortHandle: HAL_RelayHandle);
}
extern "C" {
    #[doc = " Checks if a relay channel is valid.\n\n @param channel the channel to check\n @return true if the channel is valid, otherwise false"]
    pub fn HAL_CheckRelayChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets the state of a relay output.\n\n @param[in] relayPortHandle the relay handle\n @param[in] on              true for on, false for off\n @param[out] status         Error status variable. 0 on success."]
    pub fn HAL_SetRelay(relayPortHandle: HAL_RelayHandle, on: HAL_Bool, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the current state of the relay channel.\n\n @param[in] relayPortHandle the relay handle\n @param[out] status         Error status variable. 0 on success.\n @return true for on, false for off"]
    pub fn HAL_GetRelay(relayPortHandle: HAL_RelayHandle, status: *mut i32) -> HAL_Bool;
}
pub const HAL_SPIPort_HAL_SPI_kInvalid: HAL_SPIPort = -1;
pub const HAL_SPIPort_HAL_SPI_kOnboardCS0: HAL_SPIPort = 0;
pub const HAL_SPIPort_HAL_SPI_kOnboardCS1: HAL_SPIPort = 1;
pub const HAL_SPIPort_HAL_SPI_kOnboardCS2: HAL_SPIPort = 2;
pub const HAL_SPIPort_HAL_SPI_kOnboardCS3: HAL_SPIPort = 3;
pub const HAL_SPIPort_HAL_SPI_kMXP: HAL_SPIPort = 4;
#[doc = " @defgroup hal_spi SPI Functions\n @ingroup hal_capi\n @{"]
pub type HAL_SPIPort = i32;
pub const HAL_SPIMode_HAL_SPI_kMode0: HAL_SPIMode = 0;
pub const HAL_SPIMode_HAL_SPI_kMode1: HAL_SPIMode = 1;
pub const HAL_SPIMode_HAL_SPI_kMode2: HAL_SPIMode = 2;
pub const HAL_SPIMode_HAL_SPI_kMode3: HAL_SPIMode = 3;
pub type HAL_SPIMode = i32;
extern "C" {
    #[doc = " Initializes the SPI port. Opens the port if necessary and saves the handle.\n\n If opening the MXP port, also sets up the channel functions appropriately.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS3, 4\n                    for MXP\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_InitializeSPI(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    #[doc = " Performs an SPI send/receive transaction.\n\n This is a lower-level interface to the spi hardware giving you more control\n over each transaction.\n\n @param port         The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                     for MXP\n @param dataToSend   Buffer of data to send as part of the transaction.\n @param dataReceived Buffer to read data into.\n @param size         Number of bytes to transfer. [0..7]\n @return Number of bytes transferred, -1 for error"]
    pub fn HAL_TransactionSPI(
        port: HAL_SPIPort,
        dataToSend: *const u8,
        dataReceived: *mut u8,
        size: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Executes a write transaction with the device.\n\n Writes to a device and wait until the transaction is complete.\n\n @param port       The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                   for MXP\n @param dataToSend The data to write to the register on the device.\n @param sendSize   The number of bytes to be written\n @return The number of bytes written. -1 for an error"]
    pub fn HAL_WriteSPI(port: HAL_SPIPort, dataToSend: *const u8, sendSize: i32) -> i32;
}
extern "C" {
    #[doc = " Executes a read from the device.\n\n This method does not write any data out to the device.\n\n Most spi devices will require a register address to be written before they\n begin returning data.\n\n @param port   The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n               MXP\n @param buffer A pointer to the array of bytes to store the data read from the\n               device.\n @param count  The number of bytes to read in the transaction. [1..7]\n @return Number of bytes read. -1 for error."]
    pub fn HAL_ReadSPI(port: HAL_SPIPort, buffer: *mut u8, count: i32) -> i32;
}
extern "C" {
    #[doc = " Closes the SPI port.\n\n @param port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for MXP"]
    pub fn HAL_CloseSPI(port: HAL_SPIPort);
}
extern "C" {
    #[doc = " Sets the clock speed for the SPI bus.\n\n @param port  The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n              MXP\n @param speed The speed in Hz (500KHz-10MHz)"]
    pub fn HAL_SetSPISpeed(port: HAL_SPIPort, speed: i32);
}
extern "C" {
    #[doc = " Sets the SPI Mode.\n\n @param port  The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n MXP\n @param mode  The SPI mode to use"]
    pub fn HAL_SetSPIMode(port: HAL_SPIPort, mode: HAL_SPIMode);
}
extern "C" {
    #[doc = " Gets the SPI Mode.\n\n @param port  The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n MXP\n @return      The SPI mode currently set"]
    pub fn HAL_GetSPIMode(port: HAL_SPIPort) -> HAL_SPIMode;
}
extern "C" {
    #[doc = " Sets the CS Active high for a SPI port.\n\n @param[in] port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n                 MXP\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSPIChipSelectActiveHigh(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the CS Active low for a SPI port.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                    for MXP\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSPIChipSelectActiveLow(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the stored handle for a SPI port.\n\n @param port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for MXP\n @return The stored handle for the SPI port. 0 represents no stored\n         handle."]
    pub fn HAL_GetSPIHandle(port: HAL_SPIPort) -> i32;
}
extern "C" {
    #[doc = " Sets the stored handle for a SPI port.\n\n @param port   The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n               MXP.\n @param handle The value of the handle for the port."]
    pub fn HAL_SetSPIHandle(port: HAL_SPIPort, handle: i32);
}
extern "C" {
    #[doc = " Initializes the SPI automatic accumulator.\n\n @param[in] port       The number of the port to use. 0-3 for Onboard CS0-CS2,\n                       4 for MXP.\n @param[in] bufferSize The accumulator buffer size.\n @param[out] status    the error code, or 0 for success"]
    pub fn HAL_InitSPIAuto(port: HAL_SPIPort, bufferSize: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Frees an SPI automatic accumulator.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                    for MXP.\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_FreeSPIAuto(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the period for automatic SPI accumulation.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                    for MXP.\n @param[in] period  The accumulation period (seconds).\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_StartSPIAutoRate(port: HAL_SPIPort, period: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Starts the auto SPI accumulator on a specific trigger.\n\n Note that triggering on both rising and falling edges is a valid\n configuration.\n\n @param[in] port                The number of the port to use. 0-3 for Onboard\n                                CS0-CS2, 4 for MXP.\n @param[in] digitalSourceHandle The trigger source to use (Either\n                                HAL_AnalogTriggerHandle or HAL_DigitalHandle).\n @param[in] analogTriggerType   The analog trigger type, if the source is an\n                                analog trigger.\n @param[in] triggerRising       Trigger on the rising edge if true.\n @param[in] triggerFalling      Trigger on the falling edge if true.\n @param[out] status             the error code, or 0 for success"]
    pub fn HAL_StartSPIAutoTrigger(
        port: HAL_SPIPort,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        triggerRising: HAL_Bool,
        triggerFalling: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Stops an automatic SPI accumulation.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                    for MXP.\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_StopSPIAuto(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the data to be transmitted to the device to initiate a read.\n\n @param[in] port       The number of the port to use. 0-3 for Onboard CS0-CS2,\n                       4 for MXP.\n @param[in] dataToSend Pointer to the data to send (Gets copied for continue\n                       use, so no need to keep alive).\n @param[in] dataSize   The length of the data to send.\n @param[in] zeroSize   The number of zeros to send after the data.\n @param[out] status    the error code, or 0 for success"]
    pub fn HAL_SetSPIAutoTransmitData(
        port: HAL_SPIPort,
        dataToSend: *const u8,
        dataSize: i32,
        zeroSize: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Immediately forces an SPI read to happen.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                    for MXP.\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_ForceSPIAutoRead(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    #[doc = " Reads data received by the SPI accumulator.  Each received data sequence\n consists of a timestamp followed by the received data bytes, one byte per\n word (in the least significant byte).  The length of each received data\n sequence is the same as the combined dataSize + zeroSize set in\n HAL_SetSPIAutoTransmitData.\n\n @param[in] port      The number of the port to use. 0-3 for Onboard CS0-CS2,\n                      4 for MXP.\n @param[out] buffer   The buffer to store the data into.\n @param[in] numToRead The number of words to read.\n @param[in] timeout   The read timeout (in seconds).\n @param[out] status   the error code, or 0 for success\n @return The number of words actually read."]
    pub fn HAL_ReadSPIAutoReceivedData(
        port: HAL_SPIPort,
        buffer: *mut u32,
        numToRead: i32,
        timeout: f64,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets the count of how many SPI accumulations have been missed.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                    for MXP.\n @param[out] status the error code, or 0 for success\n @return The number of missed accumulations."]
    pub fn HAL_GetSPIAutoDroppedCount(port: HAL_SPIPort, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Configure the Auto SPI Stall time between reads.\n\n @param[in] port             The number of the port to use. 0-3 for Onboard\n                             CS0-CS2, 4 for MXP.\n @param[in] csToSclkTicks    the number of ticks to wait before asserting the\n                             cs pin\n @param[in] stallTicks       the number of ticks to stall for\n @param[in] pow2BytesPerRead the number of bytes to read before stalling\n @param[out] status          the error code, or 0 for success"]
    pub fn HAL_ConfigureSPIAutoStall(
        port: HAL_SPIPort,
        csToSclkTicks: i32,
        stallTicks: i32,
        pow2BytesPerRead: i32,
        status: *mut i32,
    );
}
pub const HAL_SerialPort_HAL_SerialPort_Onboard: HAL_SerialPort = 0;
pub const HAL_SerialPort_HAL_SerialPort_MXP: HAL_SerialPort = 1;
pub const HAL_SerialPort_HAL_SerialPort_USB1: HAL_SerialPort = 2;
pub const HAL_SerialPort_HAL_SerialPort_USB2: HAL_SerialPort = 3;
#[doc = " @defgroup hal_serialport Serial Port Functions\n @ingroup hal_capi\n @{"]
pub type HAL_SerialPort = i32;
extern "C" {
    #[doc = " Initializes a serial port.\n\n The channels are either the onboard RS232, the MXP UART, or 2 USB ports. The\n top port is USB1, the bottom port is USB2.\n\n @param[in] port the serial port to initialize\n @param[out] status the error code, or 0 for success\n @return Serial Port Handle"]
    pub fn HAL_InitializeSerialPort(port: HAL_SerialPort, status: *mut i32)
        -> HAL_SerialPortHandle;
}
extern "C" {
    #[doc = " Initializes a serial port with a direct name.\n\n This name is the /dev name for a specific port.\n Note these are not always consistent between roboRIO reboots.\n\n @param[in] port     the serial port to initialize\n @param[in] portName the dev port name\n @param[out] status  the error code, or 0 for success\n @return Serial Port Handle"]
    pub fn HAL_InitializeSerialPortDirect(
        port: HAL_SerialPort,
        portName: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_SerialPortHandle;
}
extern "C" {
    #[doc = " Gets the raw serial port file descriptor from a handle.\n\n @param[in] handle the serial port handle\n @param[out] status the error code, or 0 for success\n @return the raw port descriptor"]
    pub fn HAL_GetSerialFD(handle: HAL_SerialPortHandle, status: *mut i32)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the baud rate of a serial port.\n\n Any value between 0 and 0xFFFFFFFF may be used. Default is 9600.\n\n @param[in] handle  the serial port handle\n @param[in] baud    the baud rate to set\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialBaudRate(handle: HAL_SerialPortHandle, baud: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the number of data bits on a serial port.\n\n Defaults to 8.\n\n @param[in] handle  the serial port handle\n @param[in] bits    the number of data bits (5-8)\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialDataBits(handle: HAL_SerialPortHandle, bits: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the number of parity bits on a serial port.\n\n Valid values are:\n   0: None (default)\n   1: Odd\n   2: Even\n   3: Mark - Means exists and always 1\n   4: Space - Means exists and always 0\n\n @param[in] handle  the serial port handle\n @param[in] parity  the parity bit mode (see remarks for valid values)\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialParity(handle: HAL_SerialPortHandle, parity: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the number of stop bits on a serial port.\n\n Valid values are:\n   10: One stop bit (default)\n   15: One and a half stop bits\n   20: Two stop bits\n\n @param[in] handle    the serial port handle\n @param[in] stopBits  the stop bit value (see remarks for valid values)\n @param[out] status   the error code, or 0 for success"]
    pub fn HAL_SetSerialStopBits(handle: HAL_SerialPortHandle, stopBits: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the write mode on a serial port.\n\n Valid values are:\n   1: Flush on access\n   2: Flush when full (default)\n\n @param[in] handle  the serial port handle\n @param[in] mode    the mode to set (see remarks for valid values)\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialWriteMode(handle: HAL_SerialPortHandle, mode: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the flow control mode of a serial port.\n\n Valid values are:\n   0: None (default)\n   1: XON-XOFF\n   2: RTS-CTS\n   3: DTR-DSR\n\n @param[in] handle  the serial port handle\n @param[in] flow    the mode to set (see remarks for valid values)\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialFlowControl(handle: HAL_SerialPortHandle, flow: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the minimum serial read timeout of a port.\n\n @param[in] handle   the serial port handle\n @param[in] timeout  the timeout in milliseconds\n @param[out] status  the error code, or 0 for success"]
    pub fn HAL_SetSerialTimeout(handle: HAL_SerialPortHandle, timeout: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the termination character that terminates a read.\n\n By default this is disabled.\n\n @param[in] handle      the serial port handle\n @param[in] terminator  the termination character to set\n @param[out] status     the error code, or 0 for success"]
    pub fn HAL_EnableSerialTermination(
        handle: HAL_SerialPortHandle,
        terminator: ::std::os::raw::c_char,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Disables a termination character for reads.\n\n @param[in] handle  the serial port handle\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_DisableSerialTermination(handle: HAL_SerialPortHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the size of the read buffer.\n\n @param[in] handle  the serial port handle\n @param[in] size    the read buffer size\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialReadBufferSize(handle: HAL_SerialPortHandle, size: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the size of the write buffer.\n\n @param[in] handle  the serial port handle\n @param[in] size    the write buffer size\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialWriteBufferSize(handle: HAL_SerialPortHandle, size: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the number of bytes currently in the read buffer.\n\n @param[in] handle  the serial port handle\n @param[out] status the error code, or 0 for success\n @return the number of bytes in the read buffer"]
    pub fn HAL_GetSerialBytesReceived(handle: HAL_SerialPortHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Reads data from the serial port.\n\n Will wait for either timeout (if set), the termination char (if set), or the\n count to be full. Whichever one comes first.\n\n @param[in] handle  the serial port handle\n @param[out] buffer the buffer in which to store bytes read\n @param[in] count   the number of bytes maximum to read\n @param[out] status the error code, or 0 for success\n @return the number of bytes actually read"]
    pub fn HAL_ReadSerial(
        handle: HAL_SerialPortHandle,
        buffer: *mut ::std::os::raw::c_char,
        count: i32,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Writes data to the serial port.\n\n @param[in] handle  the serial port handle\n @param[in] buffer  the buffer to write\n @param[in] count   the number of bytes to write from the buffer\n @param[out] status the error code, or 0 for success\n @return the number of bytes actually written"]
    pub fn HAL_WriteSerial(
        handle: HAL_SerialPortHandle,
        buffer: *const ::std::os::raw::c_char,
        count: i32,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Flushes the serial write buffer out to the port.\n\n @param[in] handle  the serial port handle\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_FlushSerial(handle: HAL_SerialPortHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Clears the receive buffer of the serial port.\n\n @param[in] handle  the serial port handle\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_ClearSerial(handle: HAL_SerialPortHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Closes a serial port.\n\n @param[in] handle  the serial port handle to close\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_CloseSerial(handle: HAL_SerialPortHandle, status: *mut i32);
}
pub const HAL_Type_HAL_UNASSIGNED: HAL_Type = 0;
pub const HAL_Type_HAL_BOOLEAN: HAL_Type = 1;
pub const HAL_Type_HAL_DOUBLE: HAL_Type = 2;
pub const HAL_Type_HAL_ENUM: HAL_Type = 4;
pub const HAL_Type_HAL_INT: HAL_Type = 8;
pub const HAL_Type_HAL_LONG: HAL_Type = 16;
#[doc = " HAL data types."]
pub type HAL_Type = ::std::os::raw::c_uint;
#[doc = " HAL Entry Value.  Note this is a typed union."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HAL_Value {
    pub data: HAL_Value__bindgen_ty_1,
    pub type_: HAL_Type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HAL_Value__bindgen_ty_1 {
    pub v_boolean: HAL_Bool,
    pub v_enum: i32,
    pub v_int: i32,
    pub v_long: i64,
    pub v_double: f64,
}
#[test]
fn bindgen_test_layout_HAL_Value__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_Value__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_Value__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(HAL_Value__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_Value__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(HAL_Value__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_boolean) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_enum) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_enum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_long) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_long)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_double) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_double)
        )
    );
}
#[test]
fn bindgen_test_layout_HAL_Value() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_Value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_Value>(),
        16usize,
        concat!("Size of: ", stringify!(HAL_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(HAL_Value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = "< input to user code from the simulator"]
pub const HAL_SimValueDirection_HAL_SimValueInput: HAL_SimValueDirection = 0;
#[doc = "< output from user code to the simulator"]
pub const HAL_SimValueDirection_HAL_SimValueOutput: HAL_SimValueDirection = 1;
#[doc = "< bidirectional between user code and simulator"]
pub const HAL_SimValueDirection_HAL_SimValueBidir: HAL_SimValueDirection = 2;
#[doc = " Direction of a simulated value (from the perspective of user code)."]
pub type HAL_SimValueDirection = i32;
extern "C" {
    #[doc = " Creates a simulated device.\n\n The device name must be unique.  0 is returned if the device name already\n exists.  If multiple instances of the same device are desired, recommend\n appending the instance/unique identifier in brackets to the base name,\n e.g. \"device[1]\".\n\n 0 is returned if not in simulation.\n\n @param name device name\n @return simulated device handle"]
    pub fn HAL_CreateSimDevice(name: *const ::std::os::raw::c_char) -> HAL_SimDeviceHandle;
}
extern "C" {
    #[doc = " Frees a simulated device.\n\n This also allows the same device name to be used again.\n This also frees all the simulated values created on the device.\n\n @param handle simulated device handle"]
    pub fn HAL_FreeSimDevice(handle: HAL_SimDeviceHandle);
}
extern "C" {
    #[doc = " Get the name of a simulated device\n\n @param handle simulated device handle\n @return name of the simulated device"]
    pub fn HAL_GetSimDeviceName(handle: HAL_SimDeviceHandle) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Creates a value on a simulated device.\n\n Returns 0 if not in simulation; this can be used to avoid calls\n to Set/Get functions.\n\n @param device simulated device handle\n @param name value name\n @param direction input/output/bidir (from perspective of user code)\n @param initialValue initial value\n @return simulated value handle"]
    pub fn HAL_CreateSimValue(
        device: HAL_SimDeviceHandle,
        name: *const ::std::os::raw::c_char,
        direction: i32,
        initialValue: *const HAL_Value,
    ) -> HAL_SimValueHandle;
}
extern "C" {
    #[doc = " Creates an enumerated value on a simulated device.\n\n Enumerated values are always in the range 0 to numOptions-1.\n\n Returns 0 if not in simulation; this can be used to avoid calls\n to Set/Get functions.\n\n @param device simulated device handle\n @param name value name\n @param direction input/output/bidir (from perspective of user code)\n @param numOptions number of enumerated value options (length of options)\n @param options array of option descriptions\n @param initialValue initial value (selection)\n @return simulated value handle"]
    pub fn HAL_CreateSimValueEnum(
        device: HAL_SimDeviceHandle,
        name: *const ::std::os::raw::c_char,
        direction: i32,
        numOptions: i32,
        options: *mut *const ::std::os::raw::c_char,
        initialValue: i32,
    ) -> HAL_SimValueHandle;
}
extern "C" {
    #[doc = " Creates an enumerated value on a simulated device with double values.\n\n Enumerated values are always in the range 0 to numOptions-1.\n\n Returns 0 if not in simulation; this can be used to avoid calls\n to Set/Get functions.\n\n @param device simulated device handle\n @param name value name\n @param direction input/output/bidir (from perspective of user code)\n @param numOptions number of enumerated value options (length of options)\n @param options array of option descriptions\n @param optionValues array of option double values\n @param initialValue initial value (selection)\n @return simulated value handle"]
    pub fn HAL_CreateSimValueEnumDouble(
        device: HAL_SimDeviceHandle,
        name: *const ::std::os::raw::c_char,
        direction: i32,
        numOptions: i32,
        options: *mut *const ::std::os::raw::c_char,
        optionValues: *const f64,
        initialValue: i32,
    ) -> HAL_SimValueHandle;
}
extern "C" {
    #[doc = " Gets a simulated value.\n\n @param handle simulated value handle\n @param value value (output parameter)"]
    pub fn HAL_GetSimValue(handle: HAL_SimValueHandle, value: *mut HAL_Value);
}
extern "C" {
    #[doc = " Sets a simulated value.\n\n @param handle simulated value handle\n @param value the value to set"]
    pub fn HAL_SetSimValue(handle: HAL_SimValueHandle, value: *const HAL_Value);
}
extern "C" {
    #[doc = " Resets a simulated double or integral value to 0.\n Has no effect on other value types.\n Use this instead of Set(0) for resetting incremental sensor values like\n encoder counts or gyro accumulated angle to ensure correct behavior in a\n distributed system (e.g. WebSockets).\n\n @param handle simulated value handle"]
    pub fn HAL_ResetSimValue(handle: HAL_SimValueHandle);
}
#[doc = " @defgroup hal_threads Threads Functions\n @ingroup hal_capi\n @{"]
pub type NativeThreadHandle = *const ::std::os::raw::c_void;
extern "C" {
    #[doc = " Gets the thread priority for the specified thread.\n\n @param[in] handle      Native handle pointer to the thread to get the\n                        priority for.\n @param[out] isRealTime Set to true if thread is real-time, otherwise false.\n @param[out] status     Error status variable. 0 on success.\n @return The current thread priority. For real-time, this is 1-99 with 99\n         being highest. For non-real-time, this is 0. See \"man 7 sched\" for\n         details."]
    pub fn HAL_GetThreadPriority(
        handle: NativeThreadHandle,
        isRealTime: *mut HAL_Bool,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets the thread priority for the current thread.\n\n @param[out] isRealTime Set to true if thread is real-time, otherwise false.\n @param[out] status     Error status variable. 0 on success.\n @return The current thread priority. For real-time, this is 1-99 with 99\n         being highest. For non-real-time, this is 0. See \"man 7 sched\" for\n         details."]
    pub fn HAL_GetCurrentThreadPriority(isRealTime: *mut HAL_Bool, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Sets the thread priority for the specified thread.\n\n @param[in] handle   Reference to the thread to set the priority of.\n @param[in] realTime Set to true to set a real-time priority, false for\n                     standard priority.\n @param[in] priority Priority to set the thread to. For real-time, this is\n                     1-99 with 99 being highest. For non-real-time, this is\n                     forced to 0. See \"man 7 sched\" for more details.\n @param[out] status  Error status variable. 0 on success.\n @return True on success."]
    pub fn HAL_SetThreadPriority(
        handle: NativeThreadHandle,
        realTime: HAL_Bool,
        priority: i32,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets the thread priority for the current thread.\n\n @param[in] realTime Set to true to set a real-time priority, false for\n                     standard priority.\n @param[in] priority Priority to set the thread to. For real-time, this is\n                     1-99 with 99 being highest. For non-real-time, this is\n                     forced to 0. See \"man 7 sched\" for more details.\n @param[out] status  Error status variable. 0 on success.\n @return True on success."]
    pub fn HAL_SetCurrentThreadPriority(
        realTime: HAL_Bool,
        priority: i32,
        status: *mut i32,
    ) -> HAL_Bool;
}
