/* automatically generated by rust-bindgen 0.68.1 */

pub const NT_DEFAULT_PORT3: u32 = 1735;
pub const NT_DEFAULT_PORT4: u32 = 5810;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WPI_DataLog {
    _unused: [u8; 0],
}
#[doc = " Typedefs"]
pub type NT_Bool = ::std::os::raw::c_int;
pub type NT_Handle = ::std::os::raw::c_uint;
pub type NT_ConnectionDataLogger = NT_Handle;
pub type NT_DataLogger = NT_Handle;
pub type NT_Entry = NT_Handle;
pub type NT_Inst = NT_Handle;
pub type NT_Listener = NT_Handle;
pub type NT_ListenerPoller = NT_Handle;
pub type NT_MultiSubscriber = NT_Handle;
pub type NT_Topic = NT_Handle;
pub type NT_Subscriber = NT_Handle;
pub type NT_Publisher = NT_Handle;
pub const NT_Type_NT_UNASSIGNED: NT_Type = 0;
pub const NT_Type_NT_BOOLEAN: NT_Type = 1;
pub const NT_Type_NT_DOUBLE: NT_Type = 2;
pub const NT_Type_NT_STRING: NT_Type = 4;
pub const NT_Type_NT_RAW: NT_Type = 8;
pub const NT_Type_NT_BOOLEAN_ARRAY: NT_Type = 16;
pub const NT_Type_NT_DOUBLE_ARRAY: NT_Type = 32;
pub const NT_Type_NT_STRING_ARRAY: NT_Type = 64;
pub const NT_Type_NT_RPC: NT_Type = 128;
pub const NT_Type_NT_INTEGER: NT_Type = 256;
pub const NT_Type_NT_FLOAT: NT_Type = 512;
pub const NT_Type_NT_INTEGER_ARRAY: NT_Type = 1024;
pub const NT_Type_NT_FLOAT_ARRAY: NT_Type = 2048;
#[doc = " NetworkTables data types."]
pub type NT_Type = ::std::os::raw::c_uint;
pub const NT_EntryFlags_NT_PERSISTENT: NT_EntryFlags = 1;
pub const NT_EntryFlags_NT_RETAINED: NT_EntryFlags = 2;
pub const NT_EntryFlags_NT_UNCACHED: NT_EntryFlags = 4;
#[doc = " NetworkTables entry flags."]
pub type NT_EntryFlags = ::std::os::raw::c_uint;
pub const NT_LogLevel_NT_LOG_CRITICAL: NT_LogLevel = 50;
pub const NT_LogLevel_NT_LOG_ERROR: NT_LogLevel = 40;
pub const NT_LogLevel_NT_LOG_WARNING: NT_LogLevel = 30;
pub const NT_LogLevel_NT_LOG_INFO: NT_LogLevel = 20;
pub const NT_LogLevel_NT_LOG_DEBUG: NT_LogLevel = 10;
pub const NT_LogLevel_NT_LOG_DEBUG1: NT_LogLevel = 9;
pub const NT_LogLevel_NT_LOG_DEBUG2: NT_LogLevel = 8;
pub const NT_LogLevel_NT_LOG_DEBUG3: NT_LogLevel = 7;
pub const NT_LogLevel_NT_LOG_DEBUG4: NT_LogLevel = 6;
#[doc = " NetworkTables logging levels."]
pub type NT_LogLevel = ::std::os::raw::c_uint;
pub const NT_NetworkMode_NT_NET_MODE_NONE: NT_NetworkMode = 0;
pub const NT_NetworkMode_NT_NET_MODE_SERVER: NT_NetworkMode = 1;
pub const NT_NetworkMode_NT_NET_MODE_CLIENT3: NT_NetworkMode = 2;
pub const NT_NetworkMode_NT_NET_MODE_CLIENT4: NT_NetworkMode = 4;
pub const NT_NetworkMode_NT_NET_MODE_STARTING: NT_NetworkMode = 8;
pub const NT_NetworkMode_NT_NET_MODE_LOCAL: NT_NetworkMode = 16;
#[doc = " Client/server modes"]
pub type NT_NetworkMode = ::std::os::raw::c_uint;
pub const NT_EventFlags_NT_EVENT_NONE: NT_EventFlags = 0;
#[doc = " Initial listener addition."]
pub const NT_EventFlags_NT_EVENT_IMMEDIATE: NT_EventFlags = 1;
#[doc = " Client connected (on server, any client connected)."]
pub const NT_EventFlags_NT_EVENT_CONNECTED: NT_EventFlags = 2;
#[doc = " Client disconnected (on server, any client disconnected)."]
pub const NT_EventFlags_NT_EVENT_DISCONNECTED: NT_EventFlags = 4;
#[doc = " Any connection event (connect or disconnect)."]
pub const NT_EventFlags_NT_EVENT_CONNECTION: NT_EventFlags = 6;
#[doc = " New topic published."]
pub const NT_EventFlags_NT_EVENT_PUBLISH: NT_EventFlags = 8;
#[doc = " Topic unpublished."]
pub const NT_EventFlags_NT_EVENT_UNPUBLISH: NT_EventFlags = 16;
#[doc = " Topic properties changed."]
pub const NT_EventFlags_NT_EVENT_PROPERTIES: NT_EventFlags = 32;
#[doc = " Any topic event (publish, unpublish, or properties changed)."]
pub const NT_EventFlags_NT_EVENT_TOPIC: NT_EventFlags = 56;
#[doc = " Topic value updated (via network)."]
pub const NT_EventFlags_NT_EVENT_VALUE_REMOTE: NT_EventFlags = 64;
#[doc = " Topic value updated (local)."]
pub const NT_EventFlags_NT_EVENT_VALUE_LOCAL: NT_EventFlags = 128;
#[doc = " Topic value updated (network or local)."]
pub const NT_EventFlags_NT_EVENT_VALUE_ALL: NT_EventFlags = 192;
#[doc = " Log message."]
pub const NT_EventFlags_NT_EVENT_LOGMESSAGE: NT_EventFlags = 256;
#[doc = " Time synchronized with server."]
pub const NT_EventFlags_NT_EVENT_TIMESYNC: NT_EventFlags = 512;
#[doc = " Event notification flags."]
pub type NT_EventFlags = ::std::os::raw::c_uint;
#[doc = " A NetworkTables string."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_String {
    #[doc = " String contents (UTF-8).\n The string is NOT required to be zero-terminated.\n When returned by the library, this is zero-terminated and allocated with\n std::malloc()."]
    pub str_: *mut ::std::os::raw::c_char,
    #[doc = " Length of the string in bytes.  If the string happens to be zero\n terminated, this does not include the zero-termination."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_String() {
    const UNINIT: ::std::mem::MaybeUninit<NT_String> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_String>(),
        16usize,
        concat!("Size of: ", stringify!(NT_String))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_String>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_String))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_String),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_String),
            "::",
            stringify!(len)
        )
    );
}
#[doc = " NetworkTables Entry Value.  Note this is a typed union."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NT_Value {
    pub type_: NT_Type,
    pub last_change: i64,
    pub server_time: i64,
    pub data: NT_Value__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NT_Value__bindgen_ty_1 {
    pub v_boolean: NT_Bool,
    pub v_int: i64,
    pub v_float: f32,
    pub v_double: f64,
    pub v_string: NT_String,
    pub v_raw: NT_Value__bindgen_ty_1__bindgen_ty_1,
    pub arr_boolean: NT_Value__bindgen_ty_1__bindgen_ty_2,
    pub arr_double: NT_Value__bindgen_ty_1__bindgen_ty_3,
    pub arr_float: NT_Value__bindgen_ty_1__bindgen_ty_4,
    pub arr_int: NT_Value__bindgen_ty_1__bindgen_ty_5,
    pub arr_string: NT_Value__bindgen_ty_1__bindgen_ty_6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Value__bindgen_ty_1__bindgen_ty_1 {
    pub data: *mut u8,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Value__bindgen_ty_1__bindgen_ty_2 {
    pub arr: *mut NT_Bool,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(arr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Value__bindgen_ty_1__bindgen_ty_3 {
    pub arr: *mut f64,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(arr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Value__bindgen_ty_1__bindgen_ty_4 {
    pub arr: *mut f32,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(arr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Value__bindgen_ty_1__bindgen_ty_5 {
    pub arr: *mut i64,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1__bindgen_ty_5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1__bindgen_ty_5>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(arr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Value__bindgen_ty_1__bindgen_ty_6 {
    pub arr: *mut NT_String,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1__bindgen_ty_6() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1__bindgen_ty_6> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1__bindgen_ty_6>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(arr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(size)
        )
    );
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(NT_Value__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Value__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_boolean) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(v_boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_double) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(v_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(v_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(v_raw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr_boolean) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(arr_boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr_double) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(arr_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(arr_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(arr_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr_string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(arr_string)
        )
    );
}
#[test]
fn bindgen_test_layout_NT_Value() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value>(),
        40usize,
        concat!("Size of: ", stringify!(NT_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_change) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value),
            "::",
            stringify!(last_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).server_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value),
            "::",
            stringify!(server_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " NetworkTables Topic Information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TopicInfo {
    #[doc = " Topic handle"]
    pub topic: NT_Topic,
    #[doc = " Topic name"]
    pub name: NT_String,
    #[doc = " Topic type"]
    pub type_: NT_Type,
    #[doc = " Topic type string"]
    pub type_str: NT_String,
    #[doc = " Topic properties JSON string"]
    pub properties: NT_String,
}
#[test]
fn bindgen_test_layout_NT_TopicInfo() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TopicInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TopicInfo>(),
        64usize,
        concat!("Size of: ", stringify!(NT_TopicInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TopicInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TopicInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TopicInfo),
            "::",
            stringify!(topic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TopicInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TopicInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_str) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TopicInfo),
            "::",
            stringify!(type_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).properties) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TopicInfo),
            "::",
            stringify!(properties)
        )
    );
}
#[doc = " NetworkTables Connection Information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_ConnectionInfo {
    #[doc = " The remote identifier (as set on the remote node by NT_StartClient4()."]
    pub remote_id: NT_String,
    #[doc = " The IP address of the remote node."]
    pub remote_ip: NT_String,
    #[doc = " The port number of the remote node."]
    pub remote_port: ::std::os::raw::c_uint,
    #[doc = " The last time any update was received from the remote node (same scale as\n returned by nt::Now())."]
    pub last_update: u64,
    #[doc = " The protocol version being used for this connection.  This in protocol\n layer format, so 0x0200 = 2.0, 0x0300 = 3.0)."]
    pub protocol_version: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_NT_ConnectionInfo() {
    const UNINIT: ::std::mem::MaybeUninit<NT_ConnectionInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_ConnectionInfo>(),
        56usize,
        concat!("Size of: ", stringify!(NT_ConnectionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_ConnectionInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_ConnectionInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ConnectionInfo),
            "::",
            stringify!(remote_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_ip) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ConnectionInfo),
            "::",
            stringify!(remote_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_port) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ConnectionInfo),
            "::",
            stringify!(remote_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_update) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ConnectionInfo),
            "::",
            stringify!(last_update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol_version) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ConnectionInfo),
            "::",
            stringify!(protocol_version)
        )
    );
}
#[doc = " NetworkTables value event data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NT_ValueEventData {
    #[doc = " Topic handle."]
    pub topic: NT_Topic,
    #[doc = " Subscriber/entry handle."]
    pub subentry: NT_Handle,
    #[doc = " The new value."]
    pub value: NT_Value,
}
#[test]
fn bindgen_test_layout_NT_ValueEventData() {
    const UNINIT: ::std::mem::MaybeUninit<NT_ValueEventData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_ValueEventData>(),
        48usize,
        concat!("Size of: ", stringify!(NT_ValueEventData))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_ValueEventData>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_ValueEventData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ValueEventData),
            "::",
            stringify!(topic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subentry) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ValueEventData),
            "::",
            stringify!(subentry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ValueEventData),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " NetworkTables log message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_LogMessage {
    #[doc = " Log level of the message.  See NT_LogLevel."]
    pub level: ::std::os::raw::c_uint,
    #[doc = " The filename of the source file that generated the message."]
    pub filename: *mut ::std::os::raw::c_char,
    #[doc = " The line number in the source file that generated the message."]
    pub line: ::std::os::raw::c_uint,
    #[doc = " The message."]
    pub message: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NT_LogMessage() {
    const UNINIT: ::std::mem::MaybeUninit<NT_LogMessage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_LogMessage>(),
        32usize,
        concat!("Size of: ", stringify!(NT_LogMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_LogMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_LogMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_LogMessage),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_LogMessage),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_LogMessage),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_LogMessage),
            "::",
            stringify!(message)
        )
    );
}
#[doc = " NetworkTables time sync event data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimeSyncEventData {
    #[doc = " Offset between local time and server time, in microseconds. Add this value\n to local time to get the estimated equivalent server time."]
    pub serverTimeOffset: i64,
    #[doc = " Measured round trip time divided by 2, in microseconds."]
    pub rtt2: i64,
    #[doc = " If serverTimeOffset and RTT are valid. An event with this set to false is\n sent when the client disconnects."]
    pub valid: NT_Bool,
}
#[test]
fn bindgen_test_layout_NT_TimeSyncEventData() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimeSyncEventData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimeSyncEventData>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimeSyncEventData))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimeSyncEventData>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimeSyncEventData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTimeOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimeSyncEventData),
            "::",
            stringify!(serverTimeOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rtt2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimeSyncEventData),
            "::",
            stringify!(rtt2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimeSyncEventData),
            "::",
            stringify!(valid)
        )
    );
}
#[doc = " NetworkTables event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NT_Event {
    #[doc = " Listener that triggered this event."]
    pub listener: NT_Handle,
    #[doc = " Event flags (NT_EventFlags). Also indicates the data included with the\n event:\n - NT_EVENT_CONNECTED or NT_EVENT_DISCONNECTED: connInfo\n - NT_EVENT_PUBLISH, NT_EVENT_UNPUBLISH, or NT_EVENT_PROPERTIES: topicInfo\n - NT_EVENT_VALUE_REMOTE, NT_NOTIFY_VALUE_LOCAL: valueData\n - NT_EVENT_LOGMESSAGE: logMessage\n - NT_EVENT_TIMESYNC: timeSyncData"]
    pub flags: ::std::os::raw::c_uint,
    pub data: NT_Event__bindgen_ty_1,
}
#[doc = " Event data; content depends on flags."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union NT_Event__bindgen_ty_1 {
    pub connInfo: NT_ConnectionInfo,
    pub topicInfo: NT_TopicInfo,
    pub valueData: NT_ValueEventData,
    pub logMessage: NT_LogMessage,
    pub timeSyncData: NT_TimeSyncEventData,
}
#[test]
fn bindgen_test_layout_NT_Event__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Event__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Event__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(NT_Event__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Event__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Event__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event__bindgen_ty_1),
            "::",
            stringify!(connInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topicInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event__bindgen_ty_1),
            "::",
            stringify!(topicInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valueData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event__bindgen_ty_1),
            "::",
            stringify!(valueData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logMessage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event__bindgen_ty_1),
            "::",
            stringify!(logMessage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeSyncData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event__bindgen_ty_1),
            "::",
            stringify!(timeSyncData)
        )
    );
}
#[test]
fn bindgen_test_layout_NT_Event() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Event> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Event>(),
        72usize,
        concat!("Size of: ", stringify!(NT_Event))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Event>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Event))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).listener) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event),
            "::",
            stringify!(listener)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " NetworkTables publish/subscribe options."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_PubSubOptions {
    #[doc = " Structure size. Must be set to sizeof(NT_PubSubOptions)."]
    pub structSize: ::std::os::raw::c_uint,
    #[doc = " Polling storage size for a subscription. Specifies the maximum number of\n updates NetworkTables should store between calls to the subscriber's\n ReadQueue() function. If zero, defaults to 1 if sendAll is false, 20 if\n sendAll is true."]
    pub pollStorage: ::std::os::raw::c_uint,
    #[doc = " How frequently changes will be sent over the network, in seconds.\n NetworkTables may send more frequently than this (e.g. use a combined\n minimum period for all values) or apply a restricted range to this value.\n The default is 100 ms."]
    pub periodic: f64,
    #[doc = " For subscriptions, if non-zero, value updates for ReadQueue() are not\n queued for this publisher."]
    pub excludePublisher: NT_Publisher,
    #[doc = " Send all value changes over the network."]
    pub sendAll: NT_Bool,
    #[doc = " For subscriptions, don't ask for value changes (only topic announcements)."]
    pub topicsOnly: NT_Bool,
    #[doc = " Perform prefix match on subscriber topic names. Is ignored/overridden by\n Subscribe() functions; only present in struct for the purposes of getting\n information about subscriptions."]
    pub prefixMatch: NT_Bool,
    #[doc = " Preserve duplicate value changes (rather than ignoring them)."]
    pub keepDuplicates: NT_Bool,
    #[doc = " For subscriptions, if remote value updates should not be queued for\n ReadQueue(). See also disableLocal."]
    pub disableRemote: NT_Bool,
    #[doc = " For subscriptions, if local value updates should not be queued for\n ReadQueue(). See also disableRemote."]
    pub disableLocal: NT_Bool,
    #[doc = " For entries, don't queue (for ReadQueue) value updates for the entry's\n internal publisher."]
    pub excludeSelf: NT_Bool,
    #[doc = " For subscriptions, don't share the existence of the subscription with the\n network. Note this means updates will not be received from the network\n unless another subscription overlaps with this one, and the subscription\n will not appear in metatopics."]
    pub hidden: NT_Bool,
}
#[test]
fn bindgen_test_layout_NT_PubSubOptions() {
    const UNINIT: ::std::mem::MaybeUninit<NT_PubSubOptions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_PubSubOptions>(),
        56usize,
        concat!("Size of: ", stringify!(NT_PubSubOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_PubSubOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_PubSubOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).structSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(structSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pollStorage) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(pollStorage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).periodic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(periodic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).excludePublisher) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(excludePublisher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sendAll) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(sendAll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topicsOnly) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(topicsOnly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefixMatch) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(prefixMatch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keepDuplicates) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(keepDuplicates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disableRemote) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(disableRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disableLocal) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(disableLocal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).excludeSelf) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(excludeSelf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hidden) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(hidden)
        )
    );
}
extern "C" {
    #[doc = " Get default instance.\n This is the instance used by non-handle-taking functions.\n\n @return Instance handle"]
    pub fn NT_GetDefaultInstance() -> NT_Inst;
}
extern "C" {
    #[doc = " Create an instance.\n\n @return Instance handle"]
    pub fn NT_CreateInstance() -> NT_Inst;
}
extern "C" {
    #[doc = " Destroy an instance.\n The default instance cannot be destroyed.\n\n @param inst Instance handle"]
    pub fn NT_DestroyInstance(inst: NT_Inst);
}
extern "C" {
    #[doc = " Get instance handle from another handle.\n\n @param handle    handle\n @return Instance handle"]
    pub fn NT_GetInstanceFromHandle(handle: NT_Handle) -> NT_Inst;
}
extern "C" {
    #[doc = " Get Entry Handle.\n\n @param inst      instance handle\n @param name      entry name (UTF-8 string)\n @param name_len  length of name in bytes\n @return entry handle"]
    pub fn NT_GetEntry(
        inst: NT_Inst,
        name: *const ::std::os::raw::c_char,
        name_len: usize,
    ) -> NT_Entry;
}
extern "C" {
    #[doc = " Gets the name of the specified entry.\n Returns an empty string if the handle is invalid.\n\n @param entry     entry handle\n @param name_len  length of the returned string (output parameter)\n @return Entry name"]
    pub fn NT_GetEntryName(entry: NT_Entry, name_len: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gets the type for the specified key, or unassigned if non existent.\n\n @param entry   entry handle\n @return Entry type"]
    pub fn NT_GetEntryType(entry: NT_Entry) -> NT_Type;
}
extern "C" {
    #[doc = " Gets the last time the entry was changed.\n Returns 0 if the handle is invalid.\n\n @param entry   entry handle\n @return Entry last change time"]
    pub fn NT_GetEntryLastChange(entry: NT_Entry) -> u64;
}
extern "C" {
    #[doc = " Get Entry Value.\n\n Returns copy of current entry value.\n Note that one of the type options is \"unassigned\".\n\n @param entry     entry handle\n @param value     storage for returned entry value\n\n It is the caller's responsibility to free value once it's no longer\n needed (the utility function NT_DisposeValue() is useful for this\n purpose)."]
    pub fn NT_GetEntryValue(entry: NT_Entry, value: *mut NT_Value);
}
extern "C" {
    #[doc = " Get Entry Value.\n\n Returns copy of current entry value.\n Note that one of the type options is \"unassigned\".\n\n @param entry     entry handle\n @param types     bitmask of NT_Type values; 0 is treated specially\n                  as a \"don't care\"\n @param value     storage for returned entry value\n\n It is the caller's responsibility to free value once it's no longer\n needed (the utility function NT_DisposeValue() is useful for this\n purpose)."]
    pub fn NT_GetEntryValueType(
        entry: NT_Entry,
        types: ::std::os::raw::c_uint,
        value: *mut NT_Value,
    );
}
extern "C" {
    #[doc = " Set Default Entry Value.\n\n Returns copy of current entry value if it exists.\n Otherwise, sets passed in value, and returns set value.\n Note that one of the type options is \"unassigned\".\n\n @param entry     entry handle\n @param default_value     value to be set if name does not exist\n @return 0 on error (value not set), 1 on success"]
    pub fn NT_SetDefaultEntryValue(entry: NT_Entry, default_value: *const NT_Value) -> NT_Bool;
}
extern "C" {
    #[doc = " Set Entry Value.\n\n Sets new entry value.  If type of new value differs from the type of the\n currently stored entry, returns error and does not update value.\n\n @param entry     entry handle\n @param value     new entry value\n @return 0 on error (type mismatch), 1 on success"]
    pub fn NT_SetEntryValue(entry: NT_Entry, value: *const NT_Value) -> NT_Bool;
}
extern "C" {
    #[doc = " Set Entry Flags.\n\n @param entry     entry handle\n @param flags     flags value (bitmask of NT_EntryFlags)"]
    pub fn NT_SetEntryFlags(entry: NT_Entry, flags: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Get Entry Flags.\n\n @param entry     entry handle\n @return Flags value (bitmask of NT_EntryFlags)"]
    pub fn NT_GetEntryFlags(entry: NT_Entry) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Read Entry Queue.\n\n Returns new entry values since last call. The returned array must be freed\n using NT_DisposeValueArray().\n\n @param subentry     subscriber or entry handle\n @param count        count of items in returned array (output)\n @return entry value array; returns NULL and count=0 if no new values"]
    pub fn NT_ReadQueueValue(subentry: NT_Handle, count: *mut usize) -> *mut NT_Value;
}
extern "C" {
    #[doc = " Read Entry Queue.\n\n Returns new entry values since last call. The returned array must be freed\n using NT_DisposeValueArray().\n\n @param subentry     subscriber or entry handle\n @param types        bitmask of NT_Type values; 0 is treated specially\n                     as a \"don't care\"\n @param count        count of items in returned array (output)\n @return entry value array; returns NULL and count=0 if no new values"]
    pub fn NT_ReadQueueValueType(
        subentry: NT_Handle,
        types: ::std::os::raw::c_uint,
        count: *mut usize,
    ) -> *mut NT_Value;
}
extern "C" {
    #[doc = " Get Published Topic Handles.\n\n Returns an array of topic handles.  The results are optionally\n filtered by string prefix and type to only return a subset of all\n topics.\n\n @param inst          instance handle\n @param prefix        name required prefix; only topics whose name\n                      starts with this string are returned\n @param prefix_len    length of prefix in bytes\n @param types         bitmask of NT_Type values; 0 is treated specially\n                      as a \"don't care\"\n @param count         output parameter; set to length of returned array\n @return Array of topic handles."]
    pub fn NT_GetTopics(
        inst: NT_Inst,
        prefix: *const ::std::os::raw::c_char,
        prefix_len: usize,
        types: ::std::os::raw::c_uint,
        count: *mut usize,
    ) -> *mut NT_Topic;
}
extern "C" {
    #[doc = " Get Published Topic Handles.\n\n Returns an array of topic handles.  The results are optionally\n filtered by string prefix and type to only return a subset of all\n topics.\n\n @param inst          instance handle\n @param prefix        name required prefix; only topics whose name\n                      starts with this string are returned\n @param prefix_len    length of prefix in bytes\n @param types         array of type strings\n @param types_len     number of elements in types array\n @param count         output parameter; set to length of returned array\n @return Array of topic handles."]
    pub fn NT_GetTopicsStr(
        inst: NT_Inst,
        prefix: *const ::std::os::raw::c_char,
        prefix_len: usize,
        types: *const *const ::std::os::raw::c_char,
        types_len: usize,
        count: *mut usize,
    ) -> *mut NT_Topic;
}
extern "C" {
    #[doc = " Get Topics.\n\n Returns an array of topic information (handle, name, type).  The results are\n optionally filtered by string prefix and type to only return a subset\n of all topics.\n\n @param inst          instance handle\n @param prefix        name required prefix; only topics whose name\n                      starts with this string are returned\n @param prefix_len    length of prefix in bytes\n @param types         bitmask of NT_Type values; 0 is treated specially\n                      as a \"don't care\"\n @param count         output parameter; set to length of returned array\n @return Array of topic information."]
    pub fn NT_GetTopicInfos(
        inst: NT_Inst,
        prefix: *const ::std::os::raw::c_char,
        prefix_len: usize,
        types: ::std::os::raw::c_uint,
        count: *mut usize,
    ) -> *mut NT_TopicInfo;
}
extern "C" {
    #[doc = " Get Topics.\n\n Returns an array of topic information (handle, name, type).  The results are\n optionally filtered by string prefix and type to only return a subset\n of all topics.\n\n @param inst          instance handle\n @param prefix        name required prefix; only topics whose name\n                      starts with this string are returned\n @param prefix_len    length of prefix in bytes\n @param types         array of type strings\n @param types_len     number of elements in types array\n @param count         output parameter; set to length of returned array\n @return Array of topic information."]
    pub fn NT_GetTopicInfosStr(
        inst: NT_Inst,
        prefix: *const ::std::os::raw::c_char,
        prefix_len: usize,
        types: *const *const ::std::os::raw::c_char,
        types_len: usize,
        count: *mut usize,
    ) -> *mut NT_TopicInfo;
}
extern "C" {
    #[doc = " Gets Topic Information.\n\n Returns information about a topic (name and type).\n\n @param topic         handle\n @param info          information (output)\n @return True if successful, false on error."]
    pub fn NT_GetTopicInfo(topic: NT_Topic, info: *mut NT_TopicInfo) -> NT_Bool;
}
extern "C" {
    #[doc = " Gets Topic Handle.\n\n Returns topic handle.\n\n @param inst      instance handle\n @param name      topic name\n @param name_len  length of topic name in bytes\n @return Topic handle."]
    pub fn NT_GetTopic(
        inst: NT_Inst,
        name: *const ::std::os::raw::c_char,
        name_len: usize,
    ) -> NT_Topic;
}
extern "C" {
    #[doc = " Gets the name of the specified topic.\n\n @param topic     topic handle\n @param name_len  length of topic name (output)\n @return Topic name; returns NULL and name_len=0 if the handle is invalid."]
    pub fn NT_GetTopicName(topic: NT_Topic, name_len: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gets the type for the specified topic, or unassigned if non existent.\n\n @param topic   topic handle\n @return Topic type"]
    pub fn NT_GetTopicType(topic: NT_Topic) -> NT_Type;
}
extern "C" {
    #[doc = " Gets the type string for the specified topic.  This may have more information\n than the numeric type (especially for raw values).\n\n @param topic     topic handle\n @param type_len  length of type string (output)\n @return Topic type string; returns NULL if non-existent"]
    pub fn NT_GetTopicTypeString(
        topic: NT_Topic,
        type_len: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets the persistent property of a topic.  If true, the stored value is\n persistent through server restarts.\n\n @param topic topic handle\n @param value True for persistent, false for not persistent."]
    pub fn NT_SetTopicPersistent(topic: NT_Topic, value: NT_Bool);
}
extern "C" {
    #[doc = " Gets the persistent property of a topic.\n\n @param topic topic handle\n @return persistent property value"]
    pub fn NT_GetTopicPersistent(topic: NT_Topic) -> NT_Bool;
}
extern "C" {
    #[doc = " Sets the retained property of a topic.  If true, the server retains the\n topic even when there are no publishers.\n\n @param topic topic handle\n @param value new retained property value"]
    pub fn NT_SetTopicRetained(topic: NT_Topic, value: NT_Bool);
}
extern "C" {
    #[doc = " Gets the retained property of a topic.\n\n @param topic topic handle\n @return retained property value"]
    pub fn NT_GetTopicRetained(topic: NT_Topic) -> NT_Bool;
}
extern "C" {
    #[doc = " Sets the cached property of a topic.  If true, the server and clients will\n store the latest value, allowing the value to be read (and not just accessed\n through event queues and listeners).\n\n @param topic topic handle\n @param value True for cached, false for not cached"]
    pub fn NT_SetTopicCached(topic: NT_Topic, value: NT_Bool);
}
extern "C" {
    #[doc = " Gets the cached property of a topic.\n\n @param topic topic handle\n @return cached property value"]
    pub fn NT_GetTopicCached(topic: NT_Topic) -> NT_Bool;
}
extern "C" {
    #[doc = " Determine if topic exists (e.g. has at least one publisher).\n\n @param handle Topic, entry, or subscriber handle.\n @return True if topic exists."]
    pub fn NT_GetTopicExists(handle: NT_Handle) -> NT_Bool;
}
extern "C" {
    #[doc = " Gets the current value of a property (as a JSON string).\n\n @param topic topic handle\n @param name property name\n @param len length of returned string (output)\n @return JSON string; empty string if the property does not exist."]
    pub fn NT_GetTopicProperty(
        topic: NT_Topic,
        name: *const ::std::os::raw::c_char,
        len: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets a property value.\n\n @param topic topic handle\n @param name property name\n @param value property value (JSON string)"]
    pub fn NT_SetTopicProperty(
        topic: NT_Topic,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Deletes a property.  Has no effect if the property does not exist.\n\n @param topic topic handle\n @param name property name"]
    pub fn NT_DeleteTopicProperty(topic: NT_Topic, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Gets all topic properties as a JSON string.  Each key in the object\n is the property name, and the corresponding value is the property value.\n\n @param topic topic handle\n @param len length of returned string (output)\n @return JSON string"]
    pub fn NT_GetTopicProperties(topic: NT_Topic, len: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Updates multiple topic properties.  Each key in the passed-in JSON object is\n the name of the property to add/update, and the corresponding value is the\n property value to set for that property.  Null values result in deletion\n of the corresponding property.\n\n @param topic topic handle\n @param properties JSON object string with keys to add/update/delete\n @return False if properties are not a valid JSON object"]
    pub fn NT_SetTopicProperties(
        topic: NT_Topic,
        properties: *const ::std::os::raw::c_char,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Creates a new subscriber to value changes on a topic.\n\n @param topic topic handle\n @param type expected type\n @param typeStr expected type string\n @param options subscription options\n @return Subscriber handle"]
    pub fn NT_Subscribe(
        topic: NT_Topic,
        type_: NT_Type,
        typeStr: *const ::std::os::raw::c_char,
        options: *const NT_PubSubOptions,
    ) -> NT_Subscriber;
}
extern "C" {
    #[doc = " Stops subscriber.\n\n @param sub subscriber handle"]
    pub fn NT_Unsubscribe(sub: NT_Subscriber);
}
extern "C" {
    #[doc = " Creates a new publisher to a topic.\n\n @param topic topic handle\n @param type type\n @param typeStr type string\n @param options publish options\n @return Publisher handle"]
    pub fn NT_Publish(
        topic: NT_Topic,
        type_: NT_Type,
        typeStr: *const ::std::os::raw::c_char,
        options: *const NT_PubSubOptions,
    ) -> NT_Publisher;
}
extern "C" {
    #[doc = " Creates a new publisher to a topic.\n\n @param topic topic handle\n @param type type\n @param typeStr type string\n @param properties initial properties (JSON object)\n @param options publish options\n @return Publisher handle"]
    pub fn NT_PublishEx(
        topic: NT_Topic,
        type_: NT_Type,
        typeStr: *const ::std::os::raw::c_char,
        properties: *const ::std::os::raw::c_char,
        options: *const NT_PubSubOptions,
    ) -> NT_Publisher;
}
extern "C" {
    #[doc = " Stops publisher.\n\n @param pubentry publisher/entry handle"]
    pub fn NT_Unpublish(pubentry: NT_Handle);
}
extern "C" {
    #[doc = " @brief Creates a new entry (subscriber and weak publisher) to a topic.\n\n @param topic topic handle\n @param type type\n @param typeStr type string\n @param options publish options\n @return Entry handle"]
    pub fn NT_GetEntryEx(
        topic: NT_Topic,
        type_: NT_Type,
        typeStr: *const ::std::os::raw::c_char,
        options: *const NT_PubSubOptions,
    ) -> NT_Entry;
}
extern "C" {
    #[doc = " Stops entry subscriber/publisher.\n\n @param entry entry handle"]
    pub fn NT_ReleaseEntry(entry: NT_Entry);
}
extern "C" {
    #[doc = " Stops entry/subscriber/publisher.\n\n @param pubsubentry entry/subscriber/publisher handle"]
    pub fn NT_Release(pubsubentry: NT_Handle);
}
extern "C" {
    #[doc = " Gets the topic handle from an entry/subscriber/publisher handle.\n\n @param pubsubentry entry/subscriber/publisher handle\n @return Topic handle"]
    pub fn NT_GetTopicFromHandle(pubsubentry: NT_Handle) -> NT_Topic;
}
extern "C" {
    #[doc = " Subscribes to multiple topics based on one or more topic name prefixes. Can\n be used in combination with a Value Listener or ReadQueueValue() to get value\n changes across all matching topics.\n\n @param inst instance handle\n @param prefixes topic name prefixes\n @param prefixes_len number of elements in prefixes array\n @param options subscriber options\n @return subscriber handle"]
    pub fn NT_SubscribeMultiple(
        inst: NT_Inst,
        prefixes: *const NT_String,
        prefixes_len: usize,
        options: *const NT_PubSubOptions,
    ) -> NT_MultiSubscriber;
}
extern "C" {
    #[doc = " Unsubscribes a multi-subscriber.\n\n @param sub multi-subscriber handle"]
    pub fn NT_UnsubscribeMultiple(sub: NT_MultiSubscriber);
}
#[doc = " Event listener callback function.\n\n @param data            data pointer provided to callback creation function\n @param event           event info"]
pub type NT_ListenerCallback = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, event: *const NT_Event),
>;
extern "C" {
    #[doc = " Creates a listener poller.\n\n A poller provides a single queue of poll events.  Events linked to this\n poller (using NT_AddPolledXListener()) will be stored in the queue and\n must be collected by calling NT_ReadListenerQueue().\n The returned handle must be destroyed with NT_DestroyListenerPoller().\n\n @param inst      instance handle\n @return poller handle"]
    pub fn NT_CreateListenerPoller(inst: NT_Inst) -> NT_ListenerPoller;
}
extern "C" {
    #[doc = " Destroys a listener poller.  This will abort any blocked polling\n call and prevent additional events from being generated for this poller.\n\n @param poller    poller handle"]
    pub fn NT_DestroyListenerPoller(poller: NT_ListenerPoller);
}
extern "C" {
    #[doc = " Read notifications.\n\n @param poller    poller handle\n @param len       length of returned array (output)\n @return Array of events.  Returns NULL and len=0 if no events since last\n         call."]
    pub fn NT_ReadListenerQueue(poller: NT_ListenerPoller, len: *mut usize) -> *mut NT_Event;
}
extern "C" {
    #[doc = " Removes a listener.\n\n @param listener Listener handle to remove"]
    pub fn NT_RemoveListener(listener: NT_Listener);
}
extern "C" {
    #[doc = " Wait for the listener queue to be empty. This is primarily useful\n for deterministic testing. This blocks until either the listener\n queue is empty (e.g. there are no more events that need to be passed along to\n callbacks or poll queues) or the timeout expires.\n\n @param handle  handle\n @param timeout timeout, in seconds. Set to 0 for non-blocking behavior, or a\n                negative value to block indefinitely\n @return False if timed out, otherwise true."]
    pub fn NT_WaitForListenerQueue(handle: NT_Handle, timeout: f64) -> NT_Bool;
}
extern "C" {
    #[doc = " Create a listener for changes to topics with names that start with\n the given prefix. This creates a corresponding internal subscriber with the\n lifetime of the listener.\n\n @param inst Instance handle\n @param prefix Topic name string prefix\n @param prefix_len Length of topic name string prefix\n @param mask Bitmask of NT_EventFlags values (only topic and value events will\n             be generated)\n @param data Data passed to callback function\n @param callback Listener function\n @return Listener handle"]
    pub fn NT_AddListenerSingle(
        inst: NT_Inst,
        prefix: *const ::std::os::raw::c_char,
        prefix_len: usize,
        mask: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
        callback: NT_ListenerCallback,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Create a listener for changes to topics with names that start with any of\n the given prefixes. This creates a corresponding internal subscriber with the\n lifetime of the listener.\n\n @param inst Instance handle\n @param prefixes Topic name string prefixes\n @param prefixes_len Number of elements in prefixes array\n @param mask Bitmask of NT_EventFlags values (only topic and value events will\n             be generated)\n @param data Data passed to callback function\n @param callback Listener function\n @return Listener handle"]
    pub fn NT_AddListenerMultiple(
        inst: NT_Inst,
        prefixes: *const NT_String,
        prefixes_len: usize,
        mask: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
        callback: NT_ListenerCallback,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Create a listener.\n\n Some combinations of handle and mask have no effect:\n - connection and log message events are only generated on instances\n - topic and value events are only generated on non-instances\n\n Adding value and topic events on a topic will create a corresponding internal\n subscriber with the lifetime of the listener.\n\n Adding a log message listener through this function will only result in\n events at NT_LOG_INFO or higher; for more customized settings, use\n NT_AddLogger().\n\n @param handle Handle\n @param mask Bitmask of NT_EventFlags values\n @param data Data passed to callback function\n @param callback Listener function\n @return Listener handle"]
    pub fn NT_AddListener(
        handle: NT_Handle,
        mask: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
        callback: NT_ListenerCallback,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Creates a polled topic listener. This creates a corresponding internal\n subscriber with the lifetime of the listener.\n The caller is responsible for calling NT_ReadListenerQueue() to poll.\n\n @param poller            poller handle\n @param prefix            UTF-8 string prefix\n @param prefix_len        Length of UTF-8 string prefix\n @param mask              NT_EventFlags bitmask (only topic and value events\n will be generated)\n @return Listener handle"]
    pub fn NT_AddPolledListenerSingle(
        poller: NT_ListenerPoller,
        prefix: *const ::std::os::raw::c_char,
        prefix_len: usize,
        mask: ::std::os::raw::c_uint,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Creates a polled topic listener. This creates a corresponding internal\n subscriber with the lifetime of the listener.\n The caller is responsible for calling NT_ReadListenerQueue() to poll.\n\n @param poller            poller handle\n @param prefixes          array of UTF-8 string prefixes\n @param prefixes_len      Length of prefixes array\n @param mask              NT_EventFlags bitmask (only topic and value events\n will be generated)\n @return Listener handle"]
    pub fn NT_AddPolledListenerMultiple(
        poller: NT_ListenerPoller,
        prefixes: *const NT_String,
        prefixes_len: usize,
        mask: ::std::os::raw::c_uint,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Creates a polled listener.\n The caller is responsible for calling NT_ReadListenerQueue() to poll.\n\n Some combinations of handle and mask have no effect:\n - connection and log message events are only generated on instances\n - topic and value events are only generated on non-instances\n\n Adding value and topic events on a topic will create a corresponding internal\n subscriber with the lifetime of the listener.\n\n Adding a log message listener through this function will only result in\n events at NT_LOG_INFO or higher; for more customized settings, use\n NT_AddPolledLogger().\n\n @param poller            poller handle\n @param handle            handle\n @param mask              NT_NotifyKind bitmask\n @return Listener handle"]
    pub fn NT_AddPolledListener(
        poller: NT_ListenerPoller,
        handle: NT_Handle,
        mask: ::std::os::raw::c_uint,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Get the current network mode.\n\n @param inst  instance handle\n @return Bitmask of NT_NetworkMode."]
    pub fn NT_GetNetworkMode(inst: NT_Inst) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Starts local-only operation.  Prevents calls to NT_StartServer or\n NT_StartClient from taking effect.  Has no effect if NT_StartServer or\n NT_StartClient has already been called."]
    pub fn NT_StartLocal(inst: NT_Inst);
}
extern "C" {
    #[doc = " Stops local-only operation.  NT_StartServer or NT_StartClient can be called\n after this call to start a server or client."]
    pub fn NT_StopLocal(inst: NT_Inst);
}
extern "C" {
    #[doc = " Starts a server using the specified filename, listening address, and port.\n\n @param inst              instance handle\n @param persist_filename  the name of the persist file to use (UTF-8 string,\n                          null terminated)\n @param listen_address    the address to listen on, or null to listen on any\n                          address. (UTF-8 string, null terminated)\n @param port3             port to communicate over (NT3)\n @param port4             port to communicate over (NT4)"]
    pub fn NT_StartServer(
        inst: NT_Inst,
        persist_filename: *const ::std::os::raw::c_char,
        listen_address: *const ::std::os::raw::c_char,
        port3: ::std::os::raw::c_uint,
        port4: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Stops the server if it is running.\n\n @param inst  instance handle"]
    pub fn NT_StopServer(inst: NT_Inst);
}
extern "C" {
    #[doc = " Starts a NT3 client.  Use NT_SetServer or NT_SetServerTeam to set the server\n name and port.\n\n @param inst      instance handle\n @param identity  network identity to advertise (cannot be empty string)"]
    pub fn NT_StartClient3(inst: NT_Inst, identity: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Starts a NT4 client.  Use NT_SetServer or NT_SetServerTeam to set the server\n name and port.\n\n @param inst      instance handle\n @param identity  network identity to advertise (cannot be empty string)"]
    pub fn NT_StartClient4(inst: NT_Inst, identity: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Stops the client if it is running.\n\n @param inst  instance handle"]
    pub fn NT_StopClient(inst: NT_Inst);
}
extern "C" {
    #[doc = " Sets server address and port for client (without restarting client).\n\n @param inst        instance handle\n @param server_name server name (UTF-8 string, null terminated)\n @param port        port to communicate over"]
    pub fn NT_SetServer(
        inst: NT_Inst,
        server_name: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Sets server addresses for client (without restarting client).\n The client will attempt to connect to each server in round robin fashion.\n\n @param inst         instance handle\n @param count        length of the server_names and ports arrays\n @param server_names array of server names (each a UTF-8 string, null\n                     terminated)\n @param ports        array of ports to communicate over (one for each server)"]
    pub fn NT_SetServerMulti(
        inst: NT_Inst,
        count: usize,
        server_names: *mut *const ::std::os::raw::c_char,
        ports: *const ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Sets server addresses and port for client (without restarting client).\n Connects using commonly known robot addresses for the specified team.\n\n @param inst        instance handle\n @param team        team number\n @param port        port to communicate over"]
    pub fn NT_SetServerTeam(
        inst: NT_Inst,
        team: ::std::os::raw::c_uint,
        port: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Disconnects the client if it's running and connected. This will automatically\n start reconnection attempts to the current server list.\n\n @param inst instance handle"]
    pub fn NT_Disconnect(inst: NT_Inst);
}
extern "C" {
    #[doc = " Starts requesting server address from Driver Station.\n This connects to the Driver Station running on localhost to obtain the\n server IP address.\n\n @param inst  instance handle\n @param port  server port to use in combination with IP from DS"]
    pub fn NT_StartDSClient(inst: NT_Inst, port: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Stops requesting server address from Driver Station.\n\n @param inst  instance handle"]
    pub fn NT_StopDSClient(inst: NT_Inst);
}
extern "C" {
    #[doc = " Flush local updates.\n\n Forces an immediate flush of all local changes to the client/server.\n This does not flush to the network.\n\n Normally this is done on a regularly scheduled interval.\n\n @param inst      instance handle"]
    pub fn NT_FlushLocal(inst: NT_Inst);
}
extern "C" {
    #[doc = " Flush to network.\n\n Forces an immediate flush of all local entry changes to network.\n Normally this is done on a regularly scheduled interval (set\n by update rates on individual publishers).\n\n Note: flushes are rate limited to avoid excessive network traffic.  If\n the time between calls is too short, the flush will occur after the minimum\n time elapses (rather than immediately).\n\n @param inst      instance handle"]
    pub fn NT_Flush(inst: NT_Inst);
}
extern "C" {
    #[doc = " Get information on the currently established network connections.\n If operating as a client, this will return either zero or one values.\n\n @param inst  instance handle\n @param count returns the number of elements in the array\n @return      array of connection information\n\n It is the caller's responsibility to free the array. The\n NT_DisposeConnectionInfoArray function is useful for this purpose."]
    pub fn NT_GetConnections(inst: NT_Inst, count: *mut usize) -> *mut NT_ConnectionInfo;
}
extern "C" {
    #[doc = " Return whether or not the instance is connected to another node.\n\n @param inst  instance handle\n @return True if connected."]
    pub fn NT_IsConnected(inst: NT_Inst) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the time offset between server time and local time. Add this value to\n local time to get the estimated equivalent server time. In server mode, this\n always returns a valid value of 0. In client mode, this returns the time\n offset only if the client and server are connected and have exchanged\n synchronization messages. Note the time offset may change over time as it is\n periodically updated; to receive updates as events, add a listener to the\n \"time sync\" event.\n\n @param inst instance handle\n @param valid set to true if the return value is valid, false otherwise\n              (output)\n @return Time offset in microseconds (if valid is set to true)"]
    pub fn NT_GetServerTimeOffset(inst: NT_Inst, valid: *mut NT_Bool) -> i64;
}
extern "C" {
    #[doc = " Frees value memory.\n\n @param value   value to free"]
    pub fn NT_DisposeValue(value: *mut NT_Value);
}
extern "C" {
    #[doc = " Initializes a NT_Value.\n Sets type to NT_UNASSIGNED and clears rest of struct.\n\n @param value value to initialize"]
    pub fn NT_InitValue(value: *mut NT_Value);
}
extern "C" {
    #[doc = " Frees string memory.\n\n @param str   string to free"]
    pub fn NT_DisposeString(str_: *mut NT_String);
}
extern "C" {
    #[doc = " Initializes a NT_String.\n Sets length to zero and pointer to null.\n\n @param str   string to initialize"]
    pub fn NT_InitString(str_: *mut NT_String);
}
extern "C" {
    #[doc = " Frees an array of NT_Values.\n\n @param arr   pointer to the value array to free\n @param count number of elements in the array\n\n Note that the individual NT_Values in the array should NOT be\n freed before calling this. This function will free all the values\n individually."]
    pub fn NT_DisposeValueArray(arr: *mut NT_Value, count: usize);
}
extern "C" {
    #[doc = " Disposes a connection info array.\n\n @param arr   pointer to the array to dispose\n @param count number of elements in the array"]
    pub fn NT_DisposeConnectionInfoArray(arr: *mut NT_ConnectionInfo, count: usize);
}
extern "C" {
    #[doc = " Disposes a topic info array.\n\n @param arr   pointer to the array to dispose\n @param count number of elements in the array"]
    pub fn NT_DisposeTopicInfoArray(arr: *mut NT_TopicInfo, count: usize);
}
extern "C" {
    #[doc = " Disposes a single topic info (as returned by NT_GetTopicInfo).\n\n @param info  pointer to the info to dispose"]
    pub fn NT_DisposeTopicInfo(info: *mut NT_TopicInfo);
}
extern "C" {
    #[doc = " Disposes an event array.\n\n @param arr   pointer to the array to dispose\n @param count number of elements in the array"]
    pub fn NT_DisposeEventArray(arr: *mut NT_Event, count: usize);
}
extern "C" {
    #[doc = " Disposes a single event.\n\n @param event  pointer to the event to dispose"]
    pub fn NT_DisposeEvent(event: *mut NT_Event);
}
extern "C" {
    #[doc = " Returns monotonic current time in 1 us increments.\n This is the same time base used for entry and connection timestamps.\n This function by default simply wraps WPI_Now(), but if NT_SetNow() is\n called, this function instead returns the value passed to NT_SetNow();\n this can be used to reduce overhead.\n\n @return Timestamp"]
    pub fn NT_Now() -> i64;
}
extern "C" {
    #[doc = " Sets the current timestamp used for timestamping values that do not\n provide a timestamp (e.g. a value of 0 is passed).  For consistency,\n it also results in NT_Now() returning the set value.  This should generally\n be used only if the overhead of calling WPI_Now() is a concern.\n If used, it should be called periodically with the value of WPI_Now().\n\n @param timestamp timestamp (1 us increments)"]
    pub fn NT_SetNow(timestamp: i64);
}
extern "C" {
    #[doc = " Starts logging entry changes to a DataLog.\n\n @param inst instance handle\n @param log data log object; lifetime must extend until StopEntryDataLog is\n            called or the instance is destroyed\n @param prefix only store entries with names that start with this prefix;\n               the prefix is not included in the data log entry name\n @param logPrefix prefix to add to data log entry names\n @return Data logger handle"]
    pub fn NT_StartEntryDataLog(
        inst: NT_Inst,
        log: *mut WPI_DataLog,
        prefix: *const ::std::os::raw::c_char,
        logPrefix: *const ::std::os::raw::c_char,
    ) -> NT_DataLogger;
}
extern "C" {
    #[doc = " Stops logging entry changes to a DataLog.\n\n @param logger data logger handle"]
    pub fn NT_StopEntryDataLog(logger: NT_DataLogger);
}
extern "C" {
    #[doc = " Starts logging connection changes to a DataLog.\n\n @param inst instance handle\n @param log data log object; lifetime must extend until StopConnectionDataLog\n            is called or the instance is destroyed\n @param name data log entry name\n @return Data logger handle"]
    pub fn NT_StartConnectionDataLog(
        inst: NT_Inst,
        log: *mut WPI_DataLog,
        name: *const ::std::os::raw::c_char,
    ) -> NT_ConnectionDataLogger;
}
extern "C" {
    #[doc = " Stops logging connection changes to a DataLog.\n\n @param logger data logger handle"]
    pub fn NT_StopConnectionDataLog(logger: NT_ConnectionDataLogger);
}
extern "C" {
    #[doc = " Add logger callback function.  By default, log messages are sent to stderr;\n this function sends log messages to the provided callback function instead.\n The callback function will only be called for log messages with level\n greater than or equal to min_level and less than or equal to max_level;\n messages outside this range will be silently ignored.\n\n @param inst        instance handle\n @param min_level   minimum log level\n @param max_level   maximum log level\n @param data        data pointer to pass to func\n @param func        listener callback function\n @return Listener handle"]
    pub fn NT_AddLogger(
        inst: NT_Inst,
        min_level: ::std::os::raw::c_uint,
        max_level: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
        func: NT_ListenerCallback,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Set the log level for a listener poller.  Events will only be generated for\n log messages with level greater than or equal to min_level and less than or\n equal to max_level; messages outside this range will be silently ignored.\n\n @param poller        poller handle\n @param min_level     minimum log level\n @param max_level     maximum log level\n @return Listener handle"]
    pub fn NT_AddPolledLogger(
        poller: NT_ListenerPoller,
        min_level: ::std::os::raw::c_uint,
        max_level: ::std::os::raw::c_uint,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Returns whether there is a data schema already registered with the given\n name. This does NOT perform a check as to whether the schema has already\n been published by another node on the network.\n\n @param inst instance\n @param name Name (the string passed as the data type for topics using this\n             schema)\n @return True if schema already registered"]
    pub fn NT_HasSchema(inst: NT_Inst, name: *const ::std::os::raw::c_char) -> NT_Bool;
}
extern "C" {
    #[doc = " Registers a data schema.  Data schemas provide information for how a\n certain data type string can be decoded.  The type string of a data schema\n indicates the type of the schema itself (e.g. \"protobuf\" for protobuf\n schemas, \"struct\" for struct schemas, etc). In NetworkTables, schemas are\n published just like normal topics, with the name being generated from the\n provided name: \"/.schema/<name>\".  Duplicate calls to this function with\n the same name are silently ignored.\n\n @param inst instance\n @param name Name (the string passed as the data type for topics using this\n             schema)\n @param type Type of schema (e.g. \"protobuf\", \"struct\", etc)\n @param schema Schema data\n @param schemaSize Size of schema data"]
    pub fn NT_AddSchema(
        inst: NT_Inst,
        name: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        schema: *const u8,
        schemaSize: usize,
    );
}
extern "C" {
    #[doc = " Allocates an array of chars.\n Note that the size is the number of elements, and not the\n specific number of bytes to allocate. That is calculated internally.\n\n @param size  the number of elements the array will contain\n @return      the allocated char array\n\n After use, the array should be freed using the NT_FreeCharArray()\n function."]
    pub fn NT_AllocateCharArray(size: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Allocates an array of booleans.\n Note that the size is the number of elements, and not the\n specific number of bytes to allocate. That is calculated internally.\n\n @param size  the number of elements the array will contain\n @return      the allocated boolean array\n\n After use, the array should be freed using the NT_FreeBooleanArray()\n function."]
    pub fn NT_AllocateBooleanArray(size: usize) -> *mut NT_Bool;
}
extern "C" {
    #[doc = " Allocates an array of ints.\n Note that the size is the number of elements, and not the\n specific number of bytes to allocate. That is calculated internally.\n\n @param size  the number of elements the array will contain\n @return      the allocated double array\n\n After use, the array should be freed using the NT_FreeIntArray()\n function."]
    pub fn NT_AllocateIntegerArray(size: usize) -> *mut i64;
}
extern "C" {
    #[doc = " Allocates an array of floats.\n Note that the size is the number of elements, and not the\n specific number of bytes to allocate. That is calculated internally.\n\n @param size  the number of elements the array will contain\n @return      the allocated double array\n\n After use, the array should be freed using the NT_FreeFloatArray()\n function."]
    pub fn NT_AllocateFloatArray(size: usize) -> *mut f32;
}
extern "C" {
    #[doc = " Allocates an array of doubles.\n Note that the size is the number of elements, and not the\n specific number of bytes to allocate. That is calculated internally.\n\n @param size  the number of elements the array will contain\n @return      the allocated double array\n\n After use, the array should be freed using the NT_FreeDoubleArray()\n function."]
    pub fn NT_AllocateDoubleArray(size: usize) -> *mut f64;
}
extern "C" {
    #[doc = " Allocates an array of NT_Strings.\n Note that the size is the number of elements, and not the\n specific number of bytes to allocate. That is calculated internally.\n\n @param size  the number of elements the array will contain\n @return      the allocated NT_String array\n\n After use, the array should be freed using the NT_FreeStringArray()\n function."]
    pub fn NT_AllocateStringArray(size: usize) -> *mut NT_String;
}
extern "C" {
    #[doc = " Frees an array of chars.\n\n @param v_char pointer to the char array to free"]
    pub fn NT_FreeCharArray(v_char: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Frees an array of booleans.\n\n @param v_boolean pointer to the boolean array to free"]
    pub fn NT_FreeBooleanArray(v_boolean: *mut NT_Bool);
}
extern "C" {
    #[doc = " Frees an array of ints.\n\n @param v_int pointer to the int array to free"]
    pub fn NT_FreeIntegerArray(v_int: *mut i64);
}
extern "C" {
    #[doc = " Frees an array of floats.\n\n @param v_float pointer to the float array to free"]
    pub fn NT_FreeFloatArray(v_float: *mut f32);
}
extern "C" {
    #[doc = " Frees an array of doubles.\n\n @param v_double pointer to the double array to free"]
    pub fn NT_FreeDoubleArray(v_double: *mut f64);
}
extern "C" {
    #[doc = " Frees an array of NT_Strings.\n\n @param v_string  pointer to the string array to free\n @param arr_size  size of the string array to free\n\n Note that the individual NT_Strings in the array should NOT be\n freed before calling this. This function will free all the strings\n individually."]
    pub fn NT_FreeStringArray(v_string: *mut NT_String, arr_size: usize);
}
extern "C" {
    #[doc = " Returns the type of an NT_Value struct.\n Note that one of the type options is \"unassigned\".\n\n @param value  The NT_Value struct to get the type from.\n @return       The type of the value, or unassigned if null."]
    pub fn NT_GetValueType(value: *const NT_Value) -> NT_Type;
}
extern "C" {
    #[doc = " Returns the boolean from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns 0.\n\n @param value       NT_Value struct to get the boolean from\n @param last_change returns time in ms since the last change in the value\n @param v_boolean   returns the boolean assigned to the name\n @return            1 if successful, or 0 if value is null or not a boolean"]
    pub fn NT_GetValueBoolean(
        value: *const NT_Value,
        last_change: *mut u64,
        v_boolean: *mut NT_Bool,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Returns the int from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns 0.\n\n @param value       NT_Value struct to get the int from\n @param last_change returns time in ms since the last change in the value\n @param v_int       returns the int assigned to the name\n @return            1 if successful, or 0 if value is null or not an int"]
    pub fn NT_GetValueInteger(
        value: *const NT_Value,
        last_change: *mut u64,
        v_int: *mut i64,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Returns the float from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns 0.\n\n @param value       NT_Value struct to get the float from\n @param last_change returns time in ms since the last change in the value\n @param v_float     returns the float assigned to the name\n @return            1 if successful, or 0 if value is null or not a float"]
    pub fn NT_GetValueFloat(
        value: *const NT_Value,
        last_change: *mut u64,
        v_float: *mut f32,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Returns the double from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns 0.\n\n @param value       NT_Value struct to get the double from\n @param last_change returns time in ms since the last change in the value\n @param v_double    returns the double assigned to the name\n @return            1 if successful, or 0 if value is null or not a double"]
    pub fn NT_GetValueDouble(
        value: *const NT_Value,
        last_change: *mut u64,
        v_double: *mut f64,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Returns a copy of the string from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns 0.\n\n @param value       NT_Value struct to get the string from\n @param last_change returns time in ms since the last change in the value\n @param str_len     returns the length of the string\n @return            pointer to the string (UTF-8), or null if error\n\n It is the caller's responsibility to free the string once its no longer\n needed. The NT_FreeCharArray() function is useful for this purpose. The\n returned string is a copy of the string in the value, and must be freed\n separately."]
    pub fn NT_GetValueString(
        value: *const NT_Value,
        last_change: *mut u64,
        str_len: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a copy of the raw value from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns null.\n\n @param value       NT_Value struct to get the string from\n @param last_change returns time in ms since the last change in the value\n @param raw_len     returns the length of the string\n @return            pointer to the raw value (UTF-8), or null if error\n\n It is the caller's responsibility to free the raw value once its no longer\n needed. The NT_FreeCharArray() function is useful for this purpose. The\n returned string is a copy of the string in the value, and must be freed\n separately."]
    pub fn NT_GetValueRaw(
        value: *const NT_Value,
        last_change: *mut u64,
        raw_len: *mut usize,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Returns a copy of the boolean array from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns null.\n\n @param value       NT_Value struct to get the boolean array from\n @param last_change returns time in ms since the last change in the value\n @param arr_size    returns the number of elements in the array\n @return            pointer to the boolean array, or null if error\n\n It is the caller's responsibility to free the array once its no longer\n needed. The NT_FreeBooleanArray() function is useful for this purpose.\n The returned array is a copy of the array in the value, and must be\n freed separately."]
    pub fn NT_GetValueBooleanArray(
        value: *const NT_Value,
        last_change: *mut u64,
        arr_size: *mut usize,
    ) -> *mut NT_Bool;
}
extern "C" {
    #[doc = " Returns a copy of the int array from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns null.\n\n @param value       NT_Value struct to get the int array from\n @param last_change returns time in ms since the last change in the value\n @param arr_size    returns the number of elements in the array\n @return            pointer to the int array, or null if error\n\n It is the caller's responsibility to free the array once its no longer\n needed. The NT_FreeIntArray() function is useful for this purpose.\n The returned array is a copy of the array in the value, and must be\n freed separately."]
    pub fn NT_GetValueIntegerArray(
        value: *const NT_Value,
        last_change: *mut u64,
        arr_size: *mut usize,
    ) -> *mut i64;
}
extern "C" {
    #[doc = " Returns a copy of the float array from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns null.\n\n @param value       NT_Value struct to get the float array from\n @param last_change returns time in ms since the last change in the value\n @param arr_size    returns the number of elements in the array\n @return            pointer to the float array, or null if error\n\n It is the caller's responsibility to free the array once its no longer\n needed. The NT_FreeFloatArray() function is useful for this purpose.\n The returned array is a copy of the array in the value, and must be\n freed separately."]
    pub fn NT_GetValueFloatArray(
        value: *const NT_Value,
        last_change: *mut u64,
        arr_size: *mut usize,
    ) -> *mut f32;
}
extern "C" {
    #[doc = " Returns a copy of the double array from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns null.\n\n @param value       NT_Value struct to get the double array from\n @param last_change returns time in ms since the last change in the value\n @param arr_size    returns the number of elements in the array\n @return            pointer to the double array, or null if error\n\n It is the caller's responsibility to free the array once its no longer\n needed. The NT_FreeDoubleArray() function is useful for this purpose.\n The returned array is a copy of the array in the value, and must be\n freed separately."]
    pub fn NT_GetValueDoubleArray(
        value: *const NT_Value,
        last_change: *mut u64,
        arr_size: *mut usize,
    ) -> *mut f64;
}
extern "C" {
    #[doc = " Returns a copy of the NT_String array from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns null.\n\n @param value       NT_Value struct to get the NT_String array from\n @param last_change returns time in ms since the last change in the value\n @param arr_size    returns the number of elements in the array\n @return            pointer to the NT_String array, or null if error\n\n It is the caller's responsibility to free the array once its no longer\n needed. The NT_FreeStringArray() function is useful for this purpose.\n The returned array is a copy of the array in the value, and must be\n freed separately. Note that the individual NT_Strings should not be freed,\n but the entire array should be freed at once. The NT_FreeStringArray()\n function will free all the NT_Strings."]
    pub fn NT_GetValueStringArray(
        value: *const NT_Value,
        last_change: *mut u64,
        arr_size: *mut usize,
    ) -> *mut NT_String;
}
#[doc = " Subscriber options. Different from PubSubOptions in this reflects only\n options that are sent over the network."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Meta_SubscriberOptions {
    pub periodic: f64,
    pub topicsOnly: NT_Bool,
    pub sendAll: NT_Bool,
    pub prefixMatch: NT_Bool,
}
#[test]
fn bindgen_test_layout_NT_Meta_SubscriberOptions() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Meta_SubscriberOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Meta_SubscriberOptions>(),
        24usize,
        concat!("Size of: ", stringify!(NT_Meta_SubscriberOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Meta_SubscriberOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Meta_SubscriberOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).periodic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_SubscriberOptions),
            "::",
            stringify!(periodic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topicsOnly) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_SubscriberOptions),
            "::",
            stringify!(topicsOnly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sendAll) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_SubscriberOptions),
            "::",
            stringify!(sendAll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefixMatch) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_SubscriberOptions),
            "::",
            stringify!(prefixMatch)
        )
    );
}
#[doc = " Topic publisher (as published via `$pub$<topic>`)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Meta_TopicPublisher {
    pub client: NT_String,
    pub pubuid: u64,
}
#[test]
fn bindgen_test_layout_NT_Meta_TopicPublisher() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Meta_TopicPublisher> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Meta_TopicPublisher>(),
        24usize,
        concat!("Size of: ", stringify!(NT_Meta_TopicPublisher))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Meta_TopicPublisher>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Meta_TopicPublisher))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_TopicPublisher),
            "::",
            stringify!(client)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pubuid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_TopicPublisher),
            "::",
            stringify!(pubuid)
        )
    );
}
#[doc = " Topic subscriber (as published via `$sub$<topic>`)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Meta_TopicSubscriber {
    pub client: NT_String,
    pub subuid: u64,
    pub options: NT_Meta_SubscriberOptions,
}
#[test]
fn bindgen_test_layout_NT_Meta_TopicSubscriber() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Meta_TopicSubscriber> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Meta_TopicSubscriber>(),
        48usize,
        concat!("Size of: ", stringify!(NT_Meta_TopicSubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Meta_TopicSubscriber>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Meta_TopicSubscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_TopicSubscriber),
            "::",
            stringify!(client)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subuid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_TopicSubscriber),
            "::",
            stringify!(subuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_TopicSubscriber),
            "::",
            stringify!(options)
        )
    );
}
#[doc = " Client publisher (as published via `$clientpub$<client>` or `$serverpub`)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Meta_ClientPublisher {
    pub uid: i64,
    pub topic: NT_String,
}
#[test]
fn bindgen_test_layout_NT_Meta_ClientPublisher() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Meta_ClientPublisher> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Meta_ClientPublisher>(),
        24usize,
        concat!("Size of: ", stringify!(NT_Meta_ClientPublisher))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Meta_ClientPublisher>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Meta_ClientPublisher))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_ClientPublisher),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_ClientPublisher),
            "::",
            stringify!(topic)
        )
    );
}
#[doc = " Client subscriber (as published via `$clientsub$<client>` or `$serversub`)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Meta_ClientSubscriber {
    pub uid: i64,
    pub topicsCount: usize,
    pub topics: *mut NT_String,
    pub options: NT_Meta_SubscriberOptions,
}
#[test]
fn bindgen_test_layout_NT_Meta_ClientSubscriber() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Meta_ClientSubscriber> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Meta_ClientSubscriber>(),
        48usize,
        concat!("Size of: ", stringify!(NT_Meta_ClientSubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Meta_ClientSubscriber>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Meta_ClientSubscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_ClientSubscriber),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topicsCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_ClientSubscriber),
            "::",
            stringify!(topicsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topics) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_ClientSubscriber),
            "::",
            stringify!(topics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_ClientSubscriber),
            "::",
            stringify!(options)
        )
    );
}
#[doc = " Client (as published via `$clients`)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Meta_Client {
    pub id: NT_String,
    pub conn: NT_String,
    pub version: u16,
}
#[test]
fn bindgen_test_layout_NT_Meta_Client() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Meta_Client> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Meta_Client>(),
        40usize,
        concat!("Size of: ", stringify!(NT_Meta_Client))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Meta_Client>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Meta_Client))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_Client),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_Client),
            "::",
            stringify!(conn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_Client),
            "::",
            stringify!(version)
        )
    );
}
extern "C" {
    #[doc = " Decodes `$pub$<topic>` meta-topic data.\n\n @param data data contents\n @param size size of data contents\n @param count number of elements in returned array (output)\n @return Array of TopicPublishers, or NULL on decoding error."]
    pub fn NT_Meta_DecodeTopicPublishers(
        data: *const u8,
        size: usize,
        count: *mut usize,
    ) -> *mut NT_Meta_TopicPublisher;
}
extern "C" {
    #[doc = " Decodes `$sub$<topic>` meta-topic data.\n\n @param data data contents\n @param size size of data contents\n @param count number of elements in returned array (output)\n @return Array of TopicSubscribers, or NULL on decoding error."]
    pub fn NT_Meta_DecodeTopicSubscribers(
        data: *const u8,
        size: usize,
        count: *mut usize,
    ) -> *mut NT_Meta_TopicSubscriber;
}
extern "C" {
    #[doc = " Decodes `$clientpub$<topic>` meta-topic data.\n\n @param data data contents\n @param size size of data contents\n @param count number of elements in returned array (output)\n @return Array of ClientPublishers, or NULL on decoding error."]
    pub fn NT_Meta_DecodeClientPublishers(
        data: *const u8,
        size: usize,
        count: *mut usize,
    ) -> *mut NT_Meta_ClientPublisher;
}
extern "C" {
    #[doc = " Decodes `$clientsub$<topic>` meta-topic data.\n\n @param data data contents\n @param size size of data contents\n @param count number of elements in returned array (output)\n @return Array of ClientSubscribers, or NULL on decoding error."]
    pub fn NT_Meta_DecodeClientSubscribers(
        data: *const u8,
        size: usize,
        count: *mut usize,
    ) -> *mut NT_Meta_ClientSubscriber;
}
extern "C" {
    #[doc = " Decodes `$clients` meta-topic data.\n\n @param data data contents\n @param size size of data contents\n @param count number of elements in returned array (output)\n @return Array of Clients, or NULL on decoding error."]
    pub fn NT_Meta_DecodeClients(
        data: *const u8,
        size: usize,
        count: *mut usize,
    ) -> *mut NT_Meta_Client;
}
extern "C" {
    #[doc = " Frees an array of NT_Meta_TopicPublisher.\n\n @param arr   pointer to the array to free\n @param count size of the array to free"]
    pub fn NT_Meta_FreeTopicPublishers(arr: *mut NT_Meta_TopicPublisher, count: usize);
}
extern "C" {
    #[doc = " Frees an array of NT_Meta_TopicSubscriber.\n\n @param arr   pointer to the array to free\n @param count size of the array to free"]
    pub fn NT_Meta_FreeTopicSubscribers(arr: *mut NT_Meta_TopicSubscriber, count: usize);
}
extern "C" {
    #[doc = " Frees an array of NT_Meta_ClientPublisher.\n\n @param arr   pointer to the array to free\n @param count size of the array to free"]
    pub fn NT_Meta_FreeClientPublishers(arr: *mut NT_Meta_ClientPublisher, count: usize);
}
extern "C" {
    #[doc = " Frees an array of NT_Meta_ClientSubscriber.\n\n @param arr   pointer to the array to free\n @param count size of the array to free"]
    pub fn NT_Meta_FreeClientSubscribers(arr: *mut NT_Meta_ClientSubscriber, count: usize);
}
extern "C" {
    #[doc = " Frees an array of NT_Meta_Client.\n\n @param arr   pointer to the array to free\n @param count size of the array to free"]
    pub fn NT_Meta_FreeClients(arr: *mut NT_Meta_Client, count: usize);
}
#[doc = " Timestamped Boolean.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedBoolean {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: NT_Bool,
}
#[test]
fn bindgen_test_layout_NT_TimestampedBoolean() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedBoolean> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedBoolean>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimestampedBoolean))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedBoolean>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedBoolean))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBoolean),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBoolean),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBoolean),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish"]
    pub fn NT_SetBoolean(pubentry: NT_Handle, time: i64, value: NT_Bool) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    pub fn NT_SetDefaultBoolean(pubentry: NT_Handle, defaultValue: NT_Bool) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    pub fn NT_GetBoolean(subentry: NT_Handle, defaultValue: NT_Bool) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicBoolean(
        subentry: NT_Handle,
        defaultValue: NT_Bool,
        value: *mut NT_TimestampedBoolean,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicBoolean).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedBoolean(value: *mut NT_TimestampedBoolean);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueBoolean(subentry: NT_Handle, len: *mut usize) -> *mut NT_TimestampedBoolean;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueBoolean).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueBoolean(arr: *mut NT_TimestampedBoolean, len: usize);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueValuesBoolean(subentry: NT_Handle, len: *mut usize) -> *mut NT_Bool;
}
#[doc = " Timestamped Integer.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedInteger {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: i64,
}
#[test]
fn bindgen_test_layout_NT_TimestampedInteger() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedInteger> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedInteger>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimestampedInteger))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedInteger>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedInteger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedInteger),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedInteger),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedInteger),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish"]
    pub fn NT_SetInteger(pubentry: NT_Handle, time: i64, value: i64) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    pub fn NT_SetDefaultInteger(pubentry: NT_Handle, defaultValue: i64) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    pub fn NT_GetInteger(subentry: NT_Handle, defaultValue: i64) -> i64;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicInteger(
        subentry: NT_Handle,
        defaultValue: i64,
        value: *mut NT_TimestampedInteger,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicInteger).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedInteger(value: *mut NT_TimestampedInteger);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueInteger(subentry: NT_Handle, len: *mut usize) -> *mut NT_TimestampedInteger;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueInteger).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueInteger(arr: *mut NT_TimestampedInteger, len: usize);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueValuesInteger(subentry: NT_Handle, len: *mut usize) -> *mut i64;
}
#[doc = " Timestamped Float.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedFloat {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: f32,
}
#[test]
fn bindgen_test_layout_NT_TimestampedFloat() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedFloat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedFloat>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimestampedFloat))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedFloat>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedFloat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloat),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloat),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloat),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish"]
    pub fn NT_SetFloat(pubentry: NT_Handle, time: i64, value: f32) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    pub fn NT_SetDefaultFloat(pubentry: NT_Handle, defaultValue: f32) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    pub fn NT_GetFloat(subentry: NT_Handle, defaultValue: f32) -> f32;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicFloat(
        subentry: NT_Handle,
        defaultValue: f32,
        value: *mut NT_TimestampedFloat,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicFloat).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedFloat(value: *mut NT_TimestampedFloat);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueFloat(subentry: NT_Handle, len: *mut usize) -> *mut NT_TimestampedFloat;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueFloat).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueFloat(arr: *mut NT_TimestampedFloat, len: usize);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueValuesFloat(subentry: NT_Handle, len: *mut usize) -> *mut f32;
}
#[doc = " Timestamped Double.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedDouble {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: f64,
}
#[test]
fn bindgen_test_layout_NT_TimestampedDouble() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedDouble> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedDouble>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimestampedDouble))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedDouble>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedDouble))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDouble),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDouble),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDouble),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish"]
    pub fn NT_SetDouble(pubentry: NT_Handle, time: i64, value: f64) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    pub fn NT_SetDefaultDouble(pubentry: NT_Handle, defaultValue: f64) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    pub fn NT_GetDouble(subentry: NT_Handle, defaultValue: f64) -> f64;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicDouble(
        subentry: NT_Handle,
        defaultValue: f64,
        value: *mut NT_TimestampedDouble,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicDouble).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedDouble(value: *mut NT_TimestampedDouble);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueDouble(subentry: NT_Handle, len: *mut usize) -> *mut NT_TimestampedDouble;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueDouble).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueDouble(arr: *mut NT_TimestampedDouble, len: usize);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueValuesDouble(subentry: NT_Handle, len: *mut usize) -> *mut f64;
}
#[doc = " Timestamped String.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedString {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: *mut ::std::os::raw::c_char,
    #[doc = " Value length."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_TimestampedString() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedString> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedString>(),
        32usize,
        concat!("Size of: ", stringify!(NT_TimestampedString))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedString>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedString))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedString),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedString),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedString),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedString),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish\n @param len length of value\n"]
    pub fn NT_SetString(
        pubentry: NT_Handle,
        time: i64,
        value: *const ::std::os::raw::c_char,
        len: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value\n @param defaultValueLen length of default value\n"]
    pub fn NT_SetDefaultString(
        pubentry: NT_Handle,
        defaultValue: *const ::std::os::raw::c_char,
        defaultValueLen: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n @param len length of returned value (output)\n\n @return value"]
    pub fn NT_GetString(
        subentry: NT_Handle,
        defaultValue: *const ::std::os::raw::c_char,
        defaultValueLen: usize,
        len: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicString(
        subentry: NT_Handle,
        defaultValue: *const ::std::os::raw::c_char,
        defaultValueLen: usize,
        value: *mut NT_TimestampedString,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicString).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedString(value: *mut NT_TimestampedString);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueString(subentry: NT_Handle, len: *mut usize) -> *mut NT_TimestampedString;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueString).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueString(arr: *mut NT_TimestampedString, len: usize);
}
#[doc = " Timestamped Raw.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedRaw {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: *mut u8,
    #[doc = " Value length."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_TimestampedRaw() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedRaw> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedRaw>(),
        32usize,
        concat!("Size of: ", stringify!(NT_TimestampedRaw))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedRaw>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedRaw))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedRaw),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedRaw),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedRaw),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedRaw),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish\n @param len length of value\n"]
    pub fn NT_SetRaw(pubentry: NT_Handle, time: i64, value: *const u8, len: usize) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value\n @param defaultValueLen length of default value\n"]
    pub fn NT_SetDefaultRaw(
        pubentry: NT_Handle,
        defaultValue: *const u8,
        defaultValueLen: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n @param len length of returned value (output)\n\n @return value"]
    pub fn NT_GetRaw(
        subentry: NT_Handle,
        defaultValue: *const u8,
        defaultValueLen: usize,
        len: *mut usize,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicRaw(
        subentry: NT_Handle,
        defaultValue: *const u8,
        defaultValueLen: usize,
        value: *mut NT_TimestampedRaw,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicRaw).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedRaw(value: *mut NT_TimestampedRaw);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueRaw(subentry: NT_Handle, len: *mut usize) -> *mut NT_TimestampedRaw;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueRaw).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueRaw(arr: *mut NT_TimestampedRaw, len: usize);
}
#[doc = " Timestamped BooleanArray.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedBooleanArray {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: *mut NT_Bool,
    #[doc = " Value length."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_TimestampedBooleanArray() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedBooleanArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedBooleanArray>(),
        32usize,
        concat!("Size of: ", stringify!(NT_TimestampedBooleanArray))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedBooleanArray>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedBooleanArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBooleanArray),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBooleanArray),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBooleanArray),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBooleanArray),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish\n @param len length of value\n"]
    pub fn NT_SetBooleanArray(
        pubentry: NT_Handle,
        time: i64,
        value: *const NT_Bool,
        len: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value\n @param defaultValueLen length of default value\n"]
    pub fn NT_SetDefaultBooleanArray(
        pubentry: NT_Handle,
        defaultValue: *const NT_Bool,
        defaultValueLen: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n @param len length of returned value (output)\n\n @return value"]
    pub fn NT_GetBooleanArray(
        subentry: NT_Handle,
        defaultValue: *const NT_Bool,
        defaultValueLen: usize,
        len: *mut usize,
    ) -> *mut NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicBooleanArray(
        subentry: NT_Handle,
        defaultValue: *const NT_Bool,
        defaultValueLen: usize,
        value: *mut NT_TimestampedBooleanArray,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicBooleanArray).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedBooleanArray(value: *mut NT_TimestampedBooleanArray);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueBooleanArray(
        subentry: NT_Handle,
        len: *mut usize,
    ) -> *mut NT_TimestampedBooleanArray;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueBooleanArray).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueBooleanArray(arr: *mut NT_TimestampedBooleanArray, len: usize);
}
#[doc = " Timestamped IntegerArray.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedIntegerArray {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: *mut i64,
    #[doc = " Value length."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_TimestampedIntegerArray() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedIntegerArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedIntegerArray>(),
        32usize,
        concat!("Size of: ", stringify!(NT_TimestampedIntegerArray))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedIntegerArray>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedIntegerArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedIntegerArray),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedIntegerArray),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedIntegerArray),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedIntegerArray),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish\n @param len length of value\n"]
    pub fn NT_SetIntegerArray(
        pubentry: NT_Handle,
        time: i64,
        value: *const i64,
        len: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value\n @param defaultValueLen length of default value\n"]
    pub fn NT_SetDefaultIntegerArray(
        pubentry: NT_Handle,
        defaultValue: *const i64,
        defaultValueLen: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n @param len length of returned value (output)\n\n @return value"]
    pub fn NT_GetIntegerArray(
        subentry: NT_Handle,
        defaultValue: *const i64,
        defaultValueLen: usize,
        len: *mut usize,
    ) -> *mut i64;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicIntegerArray(
        subentry: NT_Handle,
        defaultValue: *const i64,
        defaultValueLen: usize,
        value: *mut NT_TimestampedIntegerArray,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicIntegerArray).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedIntegerArray(value: *mut NT_TimestampedIntegerArray);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueIntegerArray(
        subentry: NT_Handle,
        len: *mut usize,
    ) -> *mut NT_TimestampedIntegerArray;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueIntegerArray).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueIntegerArray(arr: *mut NT_TimestampedIntegerArray, len: usize);
}
#[doc = " Timestamped FloatArray.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedFloatArray {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: *mut f32,
    #[doc = " Value length."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_TimestampedFloatArray() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedFloatArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedFloatArray>(),
        32usize,
        concat!("Size of: ", stringify!(NT_TimestampedFloatArray))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedFloatArray>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedFloatArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloatArray),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloatArray),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloatArray),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloatArray),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish\n @param len length of value\n"]
    pub fn NT_SetFloatArray(
        pubentry: NT_Handle,
        time: i64,
        value: *const f32,
        len: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value\n @param defaultValueLen length of default value\n"]
    pub fn NT_SetDefaultFloatArray(
        pubentry: NT_Handle,
        defaultValue: *const f32,
        defaultValueLen: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n @param len length of returned value (output)\n\n @return value"]
    pub fn NT_GetFloatArray(
        subentry: NT_Handle,
        defaultValue: *const f32,
        defaultValueLen: usize,
        len: *mut usize,
    ) -> *mut f32;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicFloatArray(
        subentry: NT_Handle,
        defaultValue: *const f32,
        defaultValueLen: usize,
        value: *mut NT_TimestampedFloatArray,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicFloatArray).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedFloatArray(value: *mut NT_TimestampedFloatArray);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueFloatArray(
        subentry: NT_Handle,
        len: *mut usize,
    ) -> *mut NT_TimestampedFloatArray;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueFloatArray).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueFloatArray(arr: *mut NT_TimestampedFloatArray, len: usize);
}
#[doc = " Timestamped DoubleArray.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedDoubleArray {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: *mut f64,
    #[doc = " Value length."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_TimestampedDoubleArray() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedDoubleArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedDoubleArray>(),
        32usize,
        concat!("Size of: ", stringify!(NT_TimestampedDoubleArray))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedDoubleArray>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedDoubleArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDoubleArray),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDoubleArray),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDoubleArray),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDoubleArray),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish\n @param len length of value\n"]
    pub fn NT_SetDoubleArray(
        pubentry: NT_Handle,
        time: i64,
        value: *const f64,
        len: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value\n @param defaultValueLen length of default value\n"]
    pub fn NT_SetDefaultDoubleArray(
        pubentry: NT_Handle,
        defaultValue: *const f64,
        defaultValueLen: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n @param len length of returned value (output)\n\n @return value"]
    pub fn NT_GetDoubleArray(
        subentry: NT_Handle,
        defaultValue: *const f64,
        defaultValueLen: usize,
        len: *mut usize,
    ) -> *mut f64;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicDoubleArray(
        subentry: NT_Handle,
        defaultValue: *const f64,
        defaultValueLen: usize,
        value: *mut NT_TimestampedDoubleArray,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicDoubleArray).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedDoubleArray(value: *mut NT_TimestampedDoubleArray);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueDoubleArray(
        subentry: NT_Handle,
        len: *mut usize,
    ) -> *mut NT_TimestampedDoubleArray;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueDoubleArray).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueDoubleArray(arr: *mut NT_TimestampedDoubleArray, len: usize);
}
#[doc = " Timestamped StringArray.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedStringArray {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: *mut NT_String,
    #[doc = " Value length."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_TimestampedStringArray() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedStringArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedStringArray>(),
        32usize,
        concat!("Size of: ", stringify!(NT_TimestampedStringArray))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedStringArray>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedStringArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedStringArray),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedStringArray),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedStringArray),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedStringArray),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish\n @param len length of value\n"]
    pub fn NT_SetStringArray(
        pubentry: NT_Handle,
        time: i64,
        value: *const NT_String,
        len: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value\n @param defaultValueLen length of default value\n"]
    pub fn NT_SetDefaultStringArray(
        pubentry: NT_Handle,
        defaultValue: *const NT_String,
        defaultValueLen: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n @param len length of returned value (output)\n\n @return value"]
    pub fn NT_GetStringArray(
        subentry: NT_Handle,
        defaultValue: *const NT_String,
        defaultValueLen: usize,
        len: *mut usize,
    ) -> *mut NT_String;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicStringArray(
        subentry: NT_Handle,
        defaultValue: *const NT_String,
        defaultValueLen: usize,
        value: *mut NT_TimestampedStringArray,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicStringArray).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedStringArray(value: *mut NT_TimestampedStringArray);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueStringArray(
        subentry: NT_Handle,
        len: *mut usize,
    ) -> *mut NT_TimestampedStringArray;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueStringArray).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueStringArray(arr: *mut NT_TimestampedStringArray, len: usize);
}
