/* automatically generated by rust-bindgen 0.68.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const AHRS_UPDATE_YAW_VALUE_INDEX: u32 = 4;
pub const AHRS_UPDATE_ROLL_VALUE_INDEX: u32 = 6;
pub const AHRS_UPDATE_PITCH_VALUE_INDEX: u32 = 8;
pub const AHRS_UPDATE_HEADING_VALUE_INDEX: u32 = 10;
pub const AHRS_UPDATE_ALTITUDE_VALUE_INDEX: u32 = 12;
pub const AHRS_UPDATE_FUSED_HEADING_VALUE_INDEX: u32 = 16;
pub const AHRS_UPDATE_LINEAR_ACCEL_X_VALUE_INDEX: u32 = 18;
pub const AHRS_UPDATE_LINEAR_ACCEL_Y_VALUE_INDEX: u32 = 20;
pub const AHRS_UPDATE_LINEAR_ACCEL_Z_VALUE_INDEX: u32 = 22;
pub const AHRS_UPDATE_CAL_MAG_X_VALUE_INDEX: u32 = 24;
pub const AHRS_UPDATE_CAL_MAG_Y_VALUE_INDEX: u32 = 26;
pub const AHRS_UPDATE_CAL_MAG_Z_VALUE_INDEX: u32 = 28;
pub const AHRS_UPDATE_CAL_MAG_NORM_RATIO_VALUE_INDEX: u32 = 30;
pub const AHRS_UPDATE_CAL_MAG_SCALAR_VALUE_INDEX: u32 = 32;
pub const AHRS_UPDATE_MPU_TEMP_VAUE_INDEX: u32 = 36;
pub const AHRS_UPDATE_RAW_MAG_X_VALUE_INDEX: u32 = 38;
pub const AHRS_UPDATE_RAW_MAG_Y_VALUE_INDEX: u32 = 40;
pub const AHRS_UPDATE_RAW_MAG_Z_VALUE_INDEX: u32 = 42;
pub const AHRS_UPDATE_QUAT_W_VALUE_INDEX: u32 = 44;
pub const AHRS_UPDATE_QUAT_X_VALUE_INDEX: u32 = 46;
pub const AHRS_UPDATE_QUAT_Y_VALUE_INDEX: u32 = 48;
pub const AHRS_UPDATE_QUAT_Z_VALUE_INDEX: u32 = 50;
pub const AHRS_UPDATE_BARO_PRESSURE_VALUE_INDEX: u32 = 52;
pub const AHRS_UPDATE_BARO_TEMP_VAUE_INDEX: u32 = 56;
pub const AHRS_UPDATE_OPSTATUS_VALUE_INDEX: u32 = 58;
pub const AHRS_UPDATE_SENSOR_STATUS_VALUE_INDEX: u32 = 59;
pub const AHRS_UPDATE_CAL_STATUS_VALUE_INDEX: u32 = 60;
pub const AHRS_UPDATE_SELFTEST_STATUS_VALUE_INDEX: u32 = 61;
pub const AHRS_UPDATE_MESSAGE_CHECKSUM_INDEX: u32 = 62;
pub const AHRS_UPDATE_MESSAGE_TERMINATOR_INDEX: u32 = 64;
pub const AHRS_UPDATE_MESSAGE_LENGTH: u32 = 66;
pub const AHRS_PROTOCOL_MAX_MESSAGE_LENGTH: u32 = 114;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_SendableBuilder {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct wpi_Sendable__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Interface for Sendable objects."]
#[repr(C)]
#[derive(Debug)]
pub struct wpi_Sendable {
    pub vtable_: *const wpi_Sendable__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_wpi_Sendable() {
    assert_eq!(
        ::std::mem::size_of::<wpi_Sendable>(),
        8usize,
        concat!("Size of: ", stringify!(wpi_Sendable))
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_Sendable>(),
        8usize,
        concat!("Alignment of ", stringify!(wpi_Sendable))
    );
}
#[doc = " A helper class for use with objects that add themselves to SendableRegistry.\n It takes care of properly calling Move() and Remove() on move and\n destruction.  No action is taken if the object is copied.\n Use public inheritance with CRTP when using this class.\n @tparam CRTP derived class"]
#[repr(C)]
#[derive(Debug)]
pub struct wpi_SendableHelper {
    pub _address: u8,
}
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std__If = u8;
pub type std_conditional_type<_If> = _If;
pub type std_conditional_t = u8;
pub type std_iter_difference_t = std_conditional_t;
pub type std_iter_value_t = std_conditional_t;
pub type std_iter_reference_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_input_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_input_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_input_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_input_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_input_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_input_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_forward_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_forward_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_forward_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bidirectional_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_bidirectional_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_bidirectional_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_bidirectional_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_random_access_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_random_access_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_random_access_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_random_access_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_random_access_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_random_access_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_contiguous_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_contiguous_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_contiguous_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_contiguous_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_contiguous_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_contiguous_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
pub type std_iterator_traits___primary_template = std_iterator_traits;
pub type std_streampos = std_fpos<__mbstate_t>;
pub type std_streamoff = ::std::os::raw::c_longlong;
pub type std_string = std_basic_string;
pub type std___allocator_traits_rebind_type = [u8; 0usize];
pub type std___allocator_traits_rebind_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = [u8; 0usize];
pub type std_allocator_traits_pointer = [u8; 0usize];
pub type std_allocator_traits_const_pointer = [u8; 0usize];
pub type std_allocator_traits_void_pointer = [u8; 0usize];
pub type std_allocator_traits_const_void_pointer = [u8; 0usize];
pub type std_allocator_traits_difference_type = [u8; 0usize];
pub type std_allocator_traits_size_type = [u8; 0usize];
pub type std_allocator_traits_propagate_on_container_copy_assignment = u8;
pub type std_allocator_traits_propagate_on_container_move_assignment = u8;
pub type std_allocator_traits_propagate_on_container_swap = u8;
pub type std_allocator_traits_is_always_equal = u8;
pub type std_allocator_traits_rebind_alloc = std___allocator_traits_rebind_t;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = ::std::os::raw::c_ulong;
pub type std_allocator_difference_type = ::std::os::raw::c_long;
pub type std_allocator_value_type<_Tp> = _Tp;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
pub type std___compressed_pair_elem__ParamT<_Tp> = _Tp;
pub type std___compressed_pair_elem_reference<_Tp> = *mut _Tp;
pub type std___compressed_pair_elem_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___compressed_pair {
    pub _address: u8,
}
pub type std___compressed_pair__Base1 = u8;
pub type std___compressed_pair__Base2 = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
pub type std_iterator_iterator_category<_Category> = _Category;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iter> {
    pub __t: _Iter,
    pub current: _Iter,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iter>>,
}
pub type std_reverse_iterator_iterator_type<_Iter> = _Iter;
pub type std_reverse_iterator_iterator_category = std__If;
pub type std_reverse_iterator_pointer = std_iterator_traits;
pub type std_reverse_iterator_iterator_concept = std__If;
pub type std_reverse_iterator_value_type = std_iter_value_t;
pub type std_reverse_iterator_difference_type = std_iter_difference_t;
pub type std_reverse_iterator_reference = std_iter_reference_t;
pub type std___libcpp_thread_id = pthread_t;
pub type std___libcpp_thread_t = pthread_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___thread_id {
    pub __id_: std___libcpp_thread_id,
}
#[test]
fn bindgen_test_layout_std___thread_id() {
    const UNINIT: ::std::mem::MaybeUninit<std___thread_id> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std___thread_id>(),
        8usize,
        concat!("Size of: ", stringify!(std___thread_id))
    );
    assert_eq!(
        ::std::mem::align_of::<std___thread_id>(),
        8usize,
        concat!("Alignment of ", stringify!(std___thread_id))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__id_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___thread_id),
            "::",
            stringify!(__id_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___wrap_iter<_Iter> {
    pub __i: std___wrap_iter_iterator_type<_Iter>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iter>>,
}
pub type std___wrap_iter_iterator_type<_Iter> = _Iter;
pub type std___wrap_iter_value_type = std_iterator_traits;
pub type std___wrap_iter_difference_type = std_iterator_traits;
pub type std___wrap_iter_pointer = std_iterator_traits;
pub type std___wrap_iter_reference = std_iterator_traits;
pub type std___wrap_iter_iterator_category = std_iterator_traits;
pub type std___wrap_iter_iterator_concept = std_contiguous_iterator_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_fpos<_StateT> {
    pub __st_: _StateT,
    pub __off_: std_streamoff,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
pub type std_char_traits_char_type<_CharT> = _CharT;
pub type std_char_traits_int_type = ::std::os::raw::c_int;
pub type std_char_traits_off_type = std_streamoff;
pub type std_char_traits_pos_type = std_streampos;
pub type std_char_traits_state_type = __mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string_view<_CharT> {
    pub __data: *const std_basic_string_view_value_type<_CharT>,
    pub __size: std_basic_string_view_size_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_string_view_traits_type<_Traits> = _Traits;
pub type std_basic_string_view_value_type<_CharT> = _CharT;
pub type std_basic_string_view_pointer<_CharT> = *mut _CharT;
pub type std_basic_string_view_const_pointer<_CharT> = *const _CharT;
pub type std_basic_string_view_reference<_CharT> = *mut _CharT;
pub type std_basic_string_view_const_reference<_CharT> = *const _CharT;
pub type std_basic_string_view_const_iterator<_CharT> = std_basic_string_view_const_pointer<_CharT>;
pub type std_basic_string_view_iterator<_CharT> = std_basic_string_view_const_iterator<_CharT>;
pub type std_basic_string_view_const_reverse_iterator<_CharT> =
    std_reverse_iterator<std_basic_string_view_const_iterator<_CharT>>;
pub type std_basic_string_view_reverse_iterator<_CharT> =
    std_basic_string_view_const_reverse_iterator<_CharT>;
pub type std_basic_string_view_size_type = ::std::os::raw::c_ulong;
pub type std_basic_string_view_difference_type = ::std::os::raw::c_long;
#[repr(C)]
pub struct std_basic_string {
    pub __r_: std___compressed_pair,
}
pub type std_basic_string___self = std_basic_string;
pub type std_basic_string___self_view<_CharT> = std_basic_string_view<_CharT>;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_value_type<_CharT> = _CharT;
pub type std_basic_string_allocator_type<_Allocator> = _Allocator;
pub type std_basic_string___alloc_traits = std_allocator_traits;
pub type std_basic_string_size_type = std_basic_string___alloc_traits;
pub type std_basic_string_difference_type = std_basic_string___alloc_traits;
pub type std_basic_string_reference<_CharT> = *mut std_basic_string_value_type<_CharT>;
pub type std_basic_string_const_reference<_CharT> = *const std_basic_string_value_type<_CharT>;
pub type std_basic_string_pointer = std_basic_string___alloc_traits;
pub type std_basic_string_const_pointer = std_basic_string___alloc_traits;
pub type std_basic_string_iterator = std___wrap_iter<std_basic_string_pointer>;
pub type std_basic_string_const_iterator = std___wrap_iter<std_basic_string_const_pointer>;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___long {
    pub _address: u8,
}
pub const std_basic_string___min_cap: std_basic_string__bindgen_ty_1 = 0;
pub type std_basic_string__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___short<_CharT> {
    pub __data_: *mut std_basic_string_value_type<_CharT>,
    pub __padding_: *mut ::std::os::raw::c_uchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
impl<_CharT> std_basic_string___short<_CharT> {
    #[inline]
    pub fn __size_(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set___size_(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn __is_long_(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set___is_long_(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __size_: ::std::os::raw::c_uchar,
        __is_long_: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let __size_: u8 = unsafe { ::std::mem::transmute(__size_) };
            __size_ as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __is_long_: u8 = unsafe { ::std::mem::transmute(__is_long_) };
            __is_long_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(1))]
pub struct std_basic_string___ulx<_CharT> {
    pub __lx: __BindgenUnionField<u8>,
    pub __lxx: __BindgenUnionField<std_basic_string___short<_CharT>>,
    pub bindgen_union_field: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub const std_basic_string___n_words: std_basic_string__bindgen_ty_2 = 0;
pub type std_basic_string__bindgen_ty_2 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___raw {
    pub __words: *mut std_basic_string_size_type,
}
#[repr(C)]
pub struct std_basic_string___rep<_CharT> {
    pub __bindgen_anon_1: std_basic_string___rep__bindgen_ty_1<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
#[repr(C)]
#[repr(align(1))]
pub struct std_basic_string___rep__bindgen_ty_1<_CharT> {
    pub __l: __BindgenUnionField<u8>,
    pub __s: __BindgenUnionField<std_basic_string___short<_CharT>>,
    pub __r: __BindgenUnionField<std_basic_string___raw>,
    pub bindgen_union_field: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub const std_basic_string___alignment: std_basic_string__bindgen_ty_3 = 0;
pub type std_basic_string__bindgen_ty_3 = i32;
#[repr(C)]
#[derive(Debug)]
pub struct std_thread {
    pub __t_: std___libcpp_thread_t,
}
pub type std_thread_id = std___thread_id;
pub type std_thread_native_handle_type = std___libcpp_thread_t;
#[test]
fn bindgen_test_layout_std_thread() {
    const UNINIT: ::std::mem::MaybeUninit<std_thread> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_thread>(),
        8usize,
        concat!("Size of: ", stringify!(std_thread))
    );
    assert_eq!(
        ::std::mem::align_of::<std_thread>(),
        8usize,
        concat!("Alignment of ", stringify!(std_thread))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__t_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_thread),
            "::",
            stringify!(__t_)
        )
    );
}
extern "C" {
    #[link_name = "_ZNSt3__16thread4joinEv"]
    pub fn std_thread_join(this: *mut std_thread);
}
extern "C" {
    #[link_name = "_ZNSt3__16thread6detachEv"]
    pub fn std_thread_detach(this: *mut std_thread);
}
extern "C" {
    #[link_name = "_ZNSt3__16thread20hardware_concurrencyEv"]
    pub fn std_thread_hardware_concurrency() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "_ZNSt3__16threadD1Ev"]
    pub fn std_thread_thread_destructor(this: *mut std_thread);
}
impl std_thread {
    #[inline]
    pub unsafe fn join(&mut self) {
        std_thread_join(self)
    }
    #[inline]
    pub unsafe fn detach(&mut self) {
        std_thread_detach(self)
    }
    #[inline]
    pub unsafe fn hardware_concurrency() -> ::std::os::raw::c_uint {
        std_thread_hardware_concurrency()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_thread_thread_destructor(self)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type pthread_t = __darwin_pthread_t;
pub type HAL_Handle = i32;
pub type HAL_SimDeviceHandle = HAL_Handle;
#[doc = " A move-only C++ wrapper around a HAL simulator device handle."]
#[repr(C)]
#[derive(Debug)]
pub struct hal_SimDevice {
    pub m_handle: HAL_SimDeviceHandle,
}
pub const hal_SimDevice_Direction_kInput: hal_SimDevice_Direction = 0;
pub const hal_SimDevice_Direction_kOutput: hal_SimDevice_Direction = 1;
pub const hal_SimDevice_Direction_kBidir: hal_SimDevice_Direction = 2;
#[doc = " Direction of a simulated value (from the perspective of user code)."]
pub type hal_SimDevice_Direction = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_hal_SimDevice() {
    const UNINIT: ::std::mem::MaybeUninit<hal_SimDevice> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hal_SimDevice>(),
        4usize,
        concat!("Size of: ", stringify!(hal_SimDevice))
    );
    assert_eq!(
        ::std::mem::align_of::<hal_SimDevice>(),
        4usize,
        concat!("Alignment of ", stringify!(hal_SimDevice))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_SimDevice),
            "::",
            stringify!(m_handle)
        )
    );
}
extern "C" {
    #[doc = " Creates a simulated device.\n\n The device name must be unique.  Returns null if the device name\n already exists.  This is a convenience method that appends index in\n brackets to the device name, e.g. passing index=1 results in \"device[1]\"\n for the device name.\n\n If not in simulation, results in an \"empty\" object that evaluates to false\n in a boolean context.\n\n @param name device name\n @param index device index number to append to name"]
    #[link_name = "_ZN3hal9SimDeviceC1EPKci"]
    pub fn hal_SimDevice_SimDevice(
        this: *mut hal_SimDevice,
        name: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Creates a simulated device.\n\n The device name must be unique.  Returns null if the device name\n already exists.  This is a convenience method that appends index and\n channel in brackets to the device name, e.g. passing index=1 and channel=2\n results in \"device[1,2]\" for the device name.\n\n If not in simulation, results in an \"empty\" object that evaluates to false\n in a boolean context.\n\n @param name device name\n @param index device index number to append to name\n @param channel device channel number to append to name"]
    #[link_name = "_ZN3hal9SimDeviceC1EPKcii"]
    pub fn hal_SimDevice_SimDevice1(
        this: *mut hal_SimDevice,
        name: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        channel: ::std::os::raw::c_int,
    );
}
impl hal_SimDevice {
    #[inline]
    pub unsafe fn new(name: *const ::std::os::raw::c_char, index: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        hal_SimDevice_SimDevice(__bindgen_tmp.as_mut_ptr(), name, index);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        name: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        channel: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        hal_SimDevice_SimDevice1(__bindgen_tmp.as_mut_ptr(), name, index, channel);
        __bindgen_tmp.assume_init()
    }
}
pub const frc_I2C_Port_kOnboard: frc_I2C_Port = 0;
pub const frc_I2C_Port_kMXP: frc_I2C_Port = 1;
pub type frc_I2C_Port = ::std::os::raw::c_uint;
pub const frc_SPI_Port_kOnboardCS0: frc_SPI_Port = 0;
pub const frc_SPI_Port_kOnboardCS1: frc_SPI_Port = 1;
pub const frc_SPI_Port_kOnboardCS2: frc_SPI_Port = 2;
pub const frc_SPI_Port_kOnboardCS3: frc_SPI_Port = 3;
pub const frc_SPI_Port_kMXP: frc_SPI_Port = 4;
pub type frc_SPI_Port = ::std::os::raw::c_uint;
pub const frc_SerialPort_Port_kOnboard: frc_SerialPort_Port = 0;
pub const frc_SerialPort_Port_kMXP: frc_SerialPort_Port = 1;
pub const frc_SerialPort_Port_kUSB: frc_SerialPort_Port = 2;
pub const frc_SerialPort_Port_kUSB1: frc_SerialPort_Port = 2;
pub const frc_SerialPort_Port_kUSB2: frc_SerialPort_Port = 3;
pub type frc_SerialPort_Port = ::std::os::raw::c_uint;
#[repr(C)]
pub struct frc_Gyro__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Interface for yaw rate gyros."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_Gyro {
    pub vtable_: *const frc_Gyro__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_frc_Gyro() {
    assert_eq!(
        ::std::mem::size_of::<frc_Gyro>(),
        8usize,
        concat!("Size of: ", stringify!(frc_Gyro))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Gyro>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_Gyro))
    );
}
pub const AHRS_TUNING_VAR_ID_UNSPECIFIED: AHRS_TUNING_VAR_ID = 0;
pub const AHRS_TUNING_VAR_ID_MOTION_THRESHOLD: AHRS_TUNING_VAR_ID = 1;
pub const AHRS_TUNING_VAR_ID_YAW_STABLE_THRESHOLD: AHRS_TUNING_VAR_ID = 2;
pub const AHRS_TUNING_VAR_ID_MAG_DISTURBANCE_THRESHOLD: AHRS_TUNING_VAR_ID = 3;
pub const AHRS_TUNING_VAR_ID_SEA_LEVEL_PRESSURE: AHRS_TUNING_VAR_ID = 4;
pub const AHRS_TUNING_VAR_ID_KALMAN_STATIC_MOTION_COEFF: AHRS_TUNING_VAR_ID = 5;
pub const AHRS_TUNING_VAR_ID_KALMAN_DYNAMIC_MOTION_COEFF: AHRS_TUNING_VAR_ID = 6;
pub const AHRS_TUNING_VAR_ID_YAW_GYRO_SCALE_FACTOR_RATIO: AHRS_TUNING_VAR_ID = 7;
pub const AHRS_TUNING_VAR_ID_MAX_GYRO_MEASUREMENT_ERR_DPS: AHRS_TUNING_VAR_ID = 8;
pub const AHRS_TUNING_VAR_ID_GYRO_FULL_SCALE_RANGE_DPS: AHRS_TUNING_VAR_ID = 9;
pub const AHRS_TUNING_VAR_ID_ACCEL_FULL_SCALE_RANGE_G: AHRS_TUNING_VAR_ID = 10;
pub const AHRS_TUNING_VAR_ID_MIN_TUNING_VAR_ID: AHRS_TUNING_VAR_ID = 1;
pub const AHRS_TUNING_VAR_ID_MAX_TUNING_VAR_ID: AHRS_TUNING_VAR_ID = 10;
pub type AHRS_TUNING_VAR_ID = ::std::os::raw::c_uint;
pub const AHRS_DATA_TYPE_TUNING_VARIABLE: AHRS_DATA_TYPE = 0;
pub const AHRS_DATA_TYPE_MAG_CALIBRATION: AHRS_DATA_TYPE = 1;
pub const AHRS_DATA_TYPE_BOARD_IDENTITY: AHRS_DATA_TYPE = 2;
pub type AHRS_DATA_TYPE = ::std::os::raw::c_uint;
pub const AHRS_DATA_ACTION_DATA_GET: AHRS_DATA_ACTION = 0;
pub const AHRS_DATA_ACTION_DATA_SET: AHRS_DATA_ACTION = 1;
pub const AHRS_DATA_ACTION_DATA_SET_TO_DEFAULT: AHRS_DATA_ACTION = 2;
pub type AHRS_DATA_ACTION = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHRSProtocol_AHRSUpdateBase {
    pub yaw: f32,
    pub pitch: f32,
    pub roll: f32,
    pub compass_heading: f32,
    pub altitude: f32,
    pub fused_heading: f32,
    pub linear_accel_x: f32,
    pub linear_accel_y: f32,
    pub linear_accel_z: f32,
    pub mpu_temp: f32,
    pub quat_w: f32,
    pub quat_x: f32,
    pub quat_y: f32,
    pub quat_z: f32,
    pub barometric_pressure: f32,
    pub baro_temp: f32,
    pub op_status: u8,
    pub sensor_status: u8,
    pub cal_status: u8,
    pub selftest_status: u8,
}
#[test]
fn bindgen_test_layout_AHRSProtocol_AHRSUpdateBase() {
    const UNINIT: ::std::mem::MaybeUninit<AHRSProtocol_AHRSUpdateBase> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AHRSProtocol_AHRSUpdateBase>(),
        68usize,
        concat!("Size of: ", stringify!(AHRSProtocol_AHRSUpdateBase))
    );
    assert_eq!(
        ::std::mem::align_of::<AHRSProtocol_AHRSUpdateBase>(),
        4usize,
        concat!("Alignment of ", stringify!(AHRSProtocol_AHRSUpdateBase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yaw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRSProtocol_AHRSUpdateBase),
            "::",
            stringify!(yaw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRSProtocol_AHRSUpdateBase),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).roll) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRSProtocol_AHRSUpdateBase),
            "::",
            stringify!(roll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compass_heading) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRSProtocol_AHRSUpdateBase),
            "::",
            stringify!(compass_heading)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).altitude) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRSProtocol_AHRSUpdateBase),
            "::",
            stringify!(altitude)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fused_heading) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRSProtocol_AHRSUpdateBase),
            "::",
            stringify!(fused_heading)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linear_accel_x) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRSProtocol_AHRSUpdateBase),
            "::",
            stringify!(linear_accel_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linear_accel_y) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRSProtocol_AHRSUpdateBase),
            "::",
            stringify!(linear_accel_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linear_accel_z) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRSProtocol_AHRSUpdateBase),
            "::",
            stringify!(linear_accel_z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpu_temp) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRSProtocol_AHRSUpdateBase),
            "::",
            stringify!(mpu_temp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quat_w) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRSProtocol_AHRSUpdateBase),
            "::",
            stringify!(quat_w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quat_x) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRSProtocol_AHRSUpdateBase),
            "::",
            stringify!(quat_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quat_y) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRSProtocol_AHRSUpdateBase),
            "::",
            stringify!(quat_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quat_z) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRSProtocol_AHRSUpdateBase),
            "::",
            stringify!(quat_z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).barometric_pressure) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRSProtocol_AHRSUpdateBase),
            "::",
            stringify!(barometric_pressure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).baro_temp) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRSProtocol_AHRSUpdateBase),
            "::",
            stringify!(baro_temp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).op_status) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRSProtocol_AHRSUpdateBase),
            "::",
            stringify!(op_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sensor_status) as usize - ptr as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRSProtocol_AHRSUpdateBase),
            "::",
            stringify!(sensor_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cal_status) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRSProtocol_AHRSUpdateBase),
            "::",
            stringify!(cal_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).selftest_status) as usize - ptr as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRSProtocol_AHRSUpdateBase),
            "::",
            stringify!(selftest_status)
        )
    );
}
#[repr(C)]
pub struct ITimestampedDataSubscriber__bindgen_vtable(::std::os::raw::c_void);
#[doc = " The ITimestampedDataSubscriber interface provides a method for consumers\n of navX-Model device data to be rapidly notified whenever new data\n has arrived.\n\n - timestampedDataReceived():  reception of sensor-timestamped data\n\n  A \"sensor\" timestamp is provided, generated by the navX-Model device, which is\n  at millisecond resolution.  A \"system timestamp\", also at millisecond resolution,\n  is also provided, which represents as accurately as possible the time at which the\n  data was acquired from the navX-Model device.  Note that the \"system timestamp\"\n  typically has more jitter since it is generated by the host of the navX-Model\n  device.\n\n  Thus, in general sensor timestamps are preferred, as they are generated\n  by the navX-Model device motion processor and has a greater accuracy (+/- 1ms) than the\n  system timestamp which is vulnerable to latencies introduced by the\n  host operating system.\n\n  The system timestamp is provided to allow performance monitoring of the\n  navX-Model device host's data acquisition process."]
#[repr(C)]
#[derive(Debug)]
pub struct ITimestampedDataSubscriber {
    pub vtable_: *const ITimestampedDataSubscriber__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ITimestampedDataSubscriber() {
    assert_eq!(
        ::std::mem::size_of::<ITimestampedDataSubscriber>(),
        8usize,
        concat!("Size of: ", stringify!(ITimestampedDataSubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<ITimestampedDataSubscriber>(),
        8usize,
        concat!("Alignment of ", stringify!(ITimestampedDataSubscriber))
    );
}
pub type NT_Handle = ::std::os::raw::c_uint;
pub type NT_Entry = NT_Handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_NetworkTableInstance {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_Topic {
    _unused: [u8; 0],
}
#[doc = " NetworkTables Entry\n\n @note For backwards compatibility, the NetworkTableEntry destructor does not\n       release the entry.\n\n @ingroup ntcore_cpp_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_NetworkTableEntry {
    pub m_handle: NT_Entry,
}
pub const nt_NetworkTableEntry_Flags_kPersistent: nt_NetworkTableEntry_Flags = 1;
#[doc = " Flag values (as returned by GetFlags()).\n @deprecated Use IsPersistent() instead."]
pub type nt_NetworkTableEntry_Flags = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_nt_NetworkTableEntry() {
    const UNINIT: ::std::mem::MaybeUninit<nt_NetworkTableEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_NetworkTableEntry>(),
        4usize,
        concat!("Size of: ", stringify!(nt_NetworkTableEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_NetworkTableEntry>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_NetworkTableEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_NetworkTableEntry),
            "::",
            stringify!(m_handle)
        )
    );
}
extern "C" {
    #[doc = " Gets the instance for the entry.\n\n @return Instance"]
    #[link_name = "_ZNK2nt17NetworkTableEntry11GetInstanceEv"]
    pub fn nt_NetworkTableEntry_GetInstance(
        this: *const nt_NetworkTableEntry,
    ) -> nt_NetworkTableInstance;
}
extern "C" {
    #[doc = " Gets the entry's topic.\n\n @return Topic"]
    #[link_name = "_ZNK2nt17NetworkTableEntry8GetTopicEv"]
    pub fn nt_NetworkTableEntry_GetTopic(this: *const nt_NetworkTableEntry) -> nt_Topic;
}
impl nt_NetworkTableEntry {
    #[inline]
    pub unsafe fn GetInstance(&self) -> nt_NetworkTableInstance {
        nt_NetworkTableEntry_GetInstance(self)
    }
    #[inline]
    pub unsafe fn GetTopic(&self) -> nt_Topic {
        nt_NetworkTableEntry_GetTopic(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IIOProvider {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ContinuousAngleTracker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InertialDataIntegrator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OffsetTracker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHRSInternal {
    _unused: [u8; 0],
}
#[doc = " Class providing an \"Attitude and Heading Reference System\" (AHRS)\n interface to a navX-sensor"]
#[repr(C)]
#[derive(Debug)]
pub struct AHRS {
    pub _base: frc_Gyro,
    pub _base_1: wpi_Sendable,
    pub ahrs_internal: *mut AHRSInternal,
    pub yaw: f32,
    pub pitch: f32,
    pub roll: f32,
    pub compass_heading: f32,
    pub world_linear_accel_x: f32,
    pub world_linear_accel_y: f32,
    pub world_linear_accel_z: f32,
    pub mpu_temp_c: f32,
    pub fused_heading: f32,
    pub altitude: f32,
    pub baro_pressure: f32,
    pub is_moving: bool,
    pub is_rotating: bool,
    pub baro_sensor_temp_c: f32,
    pub altitude_valid: bool,
    pub is_magnetometer_calibrated: bool,
    pub magnetic_disturbance: bool,
    pub quaternionW: f32,
    pub quaternionX: f32,
    pub quaternionY: f32,
    pub quaternionZ: f32,
    pub velocity: [f32; 3usize],
    pub displacement: [f32; 3usize],
    pub raw_gyro_x: i16,
    pub raw_gyro_y: i16,
    pub raw_gyro_z: i16,
    pub raw_accel_x: i16,
    pub raw_accel_y: i16,
    pub raw_accel_z: i16,
    pub cal_mag_x: i16,
    pub cal_mag_y: i16,
    pub cal_mag_z: i16,
    pub update_rate_hz: u8,
    pub accel_fsr_g: i16,
    pub gyro_fsr_dps: i16,
    pub capability_flags: i16,
    pub op_status: u8,
    pub sensor_status: i16,
    pub cal_status: u8,
    pub selftest_status: u8,
    pub board_type: u8,
    pub hw_rev: u8,
    pub fw_ver_major: u8,
    pub fw_ver_minor: u8,
    pub last_sensor_timestamp: ::std::os::raw::c_long,
    pub last_update_time: f64,
    pub integrator: *mut InertialDataIntegrator,
    pub yaw_angle_tracker: *mut ContinuousAngleTracker,
    pub yaw_offset_tracker: *mut OffsetTracker,
    pub io: *mut IIOProvider,
    pub task: *mut std_thread,
    pub m_simDevice: hal_SimDevice,
    pub callbacks: [*mut ITimestampedDataSubscriber; 3usize],
    pub callback_contexts: [*mut ::std::os::raw::c_void; 3usize],
    pub enable_boardlevel_yawreset: bool,
    pub last_yawreset_request_timestamp: f64,
    pub last_yawreset_while_calibrating_request_timestamp: f64,
    pub successive_suppressed_yawreset_request_count: u32,
    pub disconnect_startupcalibration_recovery_pending: bool,
    pub logging_enabled: bool,
    pub m_valueEntry: nt_NetworkTableEntry,
}
#[doc = " Board X (left/right) Axis"]
pub const AHRS_BoardAxis_kBoardAxisX: AHRS_BoardAxis = 0;
#[doc = " Board Y (forward/reverse) Axis"]
pub const AHRS_BoardAxis_kBoardAxisY: AHRS_BoardAxis = 1;
#[doc = " Board Z (up/down) Axis"]
pub const AHRS_BoardAxis_kBoardAxisZ: AHRS_BoardAxis = 2;
#[doc = " Enumeration of all board axes"]
pub type AHRS_BoardAxis = ::std::os::raw::c_uint;
#[doc = " Structure describing the current board orientation w/respect to the IMU axes of measurement."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHRS_BoardYawAxis {
    #[doc = " Identifies one of the board axes."]
    pub board_axis: AHRS_BoardAxis,
    #[doc = " true if axis is pointing up (with respect to gravity); false if pointing down."]
    pub up: bool,
}
#[test]
fn bindgen_test_layout_AHRS_BoardYawAxis() {
    const UNINIT: ::std::mem::MaybeUninit<AHRS_BoardYawAxis> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AHRS_BoardYawAxis>(),
        8usize,
        concat!("Size of: ", stringify!(AHRS_BoardYawAxis))
    );
    assert_eq!(
        ::std::mem::align_of::<AHRS_BoardYawAxis>(),
        4usize,
        concat!("Alignment of ", stringify!(AHRS_BoardYawAxis))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).board_axis) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS_BoardYawAxis),
            "::",
            stringify!(board_axis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).up) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS_BoardYawAxis),
            "::",
            stringify!(up)
        )
    );
}
#[doc = " (default):  6 and 9-axis processed data"]
pub const AHRS_SerialDataType_kProcessedData: AHRS_SerialDataType = 0;
#[doc = " unprocessed data from each individual sensor"]
pub const AHRS_SerialDataType_kRawData: AHRS_SerialDataType = 1;
#[doc = " navX-Sensor support Serial Data types"]
pub type AHRS_SerialDataType = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_AHRS() {
    const UNINIT: ::std::mem::MaybeUninit<AHRS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AHRS>(),
        312usize,
        concat!("Size of: ", stringify!(AHRS))
    );
    assert_eq!(
        ::std::mem::align_of::<AHRS>(),
        8usize,
        concat!("Alignment of ", stringify!(AHRS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ahrs_internal) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(ahrs_internal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yaw) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(AHRS), "::", stringify!(yaw))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).roll) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(roll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compass_heading) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(compass_heading)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).world_linear_accel_x) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(world_linear_accel_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).world_linear_accel_y) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(world_linear_accel_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).world_linear_accel_z) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(world_linear_accel_z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpu_temp_c) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(mpu_temp_c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fused_heading) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(fused_heading)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).altitude) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(altitude)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).baro_pressure) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(baro_pressure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_moving) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(is_moving)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_rotating) as usize - ptr as usize },
        69usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(is_rotating)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).baro_sensor_temp_c) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(baro_sensor_temp_c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).altitude_valid) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(altitude_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_magnetometer_calibrated) as usize - ptr as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(is_magnetometer_calibrated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magnetic_disturbance) as usize - ptr as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(magnetic_disturbance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quaternionW) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(quaternionW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quaternionX) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(quaternionX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quaternionY) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(quaternionY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quaternionZ) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(quaternionZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).velocity) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(velocity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displacement) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(displacement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_gyro_x) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(raw_gyro_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_gyro_y) as usize - ptr as usize },
        122usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(raw_gyro_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_gyro_z) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(raw_gyro_z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_accel_x) as usize - ptr as usize },
        126usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(raw_accel_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_accel_y) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(raw_accel_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_accel_z) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(raw_accel_z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cal_mag_x) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(cal_mag_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cal_mag_y) as usize - ptr as usize },
        134usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(cal_mag_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cal_mag_z) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(cal_mag_z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_rate_hz) as usize - ptr as usize },
        138usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(update_rate_hz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accel_fsr_g) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(accel_fsr_g)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gyro_fsr_dps) as usize - ptr as usize },
        142usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(gyro_fsr_dps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capability_flags) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(capability_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).op_status) as usize - ptr as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(op_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sensor_status) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(sensor_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cal_status) as usize - ptr as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(cal_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).selftest_status) as usize - ptr as usize },
        151usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(selftest_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).board_type) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(board_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hw_rev) as usize - ptr as usize },
        153usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(hw_rev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fw_ver_major) as usize - ptr as usize },
        154usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(fw_ver_major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fw_ver_minor) as usize - ptr as usize },
        155usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(fw_ver_minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_sensor_timestamp) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(last_sensor_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_update_time) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(last_update_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).integrator) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(integrator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yaw_angle_tracker) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(yaw_angle_tracker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yaw_offset_tracker) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(yaw_offset_tracker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io) as usize - ptr as usize },
        200usize,
        concat!("Offset of field: ", stringify!(AHRS), "::", stringify!(io))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).task) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(task)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_simDevice) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(m_simDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callbacks) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(callbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback_contexts) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(callback_contexts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_boardlevel_yawreset) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(enable_boardlevel_yawreset)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).last_yawreset_request_timestamp) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(last_yawreset_request_timestamp)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).last_yawreset_while_calibrating_request_timestamp) as usize
                - ptr as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(last_yawreset_while_calibrating_request_timestamp)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).successive_suppressed_yawreset_request_count) as usize
                - ptr as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(successive_suppressed_yawreset_request_count)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).disconnect_startupcalibration_recovery_pending) as usize
                - ptr as usize
        },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(disconnect_startupcalibration_recovery_pending)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logging_enabled) as usize - ptr as usize },
        301usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(logging_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_valueEntry) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(AHRS),
            "::",
            stringify!(m_valueEntry)
        )
    );
}
extern "C" {
    #[link_name = "_ZN4AHRS8GetPitchEv"]
    pub fn AHRS_GetPitch(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS7GetRollEv"]
    pub fn AHRS_GetRoll(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS6GetYawEv"]
    pub fn AHRS_GetYaw(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS17GetCompassHeadingEv"]
    pub fn AHRS_GetCompassHeading(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS7ZeroYawEv"]
    pub fn AHRS_ZeroYaw(this: *mut AHRS);
}
extern "C" {
    #[link_name = "_ZN4AHRS13IsCalibratingEv"]
    pub fn AHRS_IsCalibrating(this: *mut AHRS) -> bool;
}
extern "C" {
    #[link_name = "_ZN4AHRS11IsConnectedEv"]
    pub fn AHRS_IsConnected(this: *mut AHRS) -> bool;
}
extern "C" {
    #[link_name = "_ZN4AHRS12GetByteCountEv"]
    pub fn AHRS_GetByteCount(this: *mut AHRS) -> f64;
}
extern "C" {
    #[link_name = "_ZN4AHRS14GetUpdateCountEv"]
    pub fn AHRS_GetUpdateCount(this: *mut AHRS) -> f64;
}
extern "C" {
    #[link_name = "_ZN4AHRS22GetLastSensorTimestampEv"]
    pub fn AHRS_GetLastSensorTimestamp(this: *mut AHRS) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "_ZN4AHRS20GetWorldLinearAccelXEv"]
    pub fn AHRS_GetWorldLinearAccelX(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS20GetWorldLinearAccelYEv"]
    pub fn AHRS_GetWorldLinearAccelY(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS20GetWorldLinearAccelZEv"]
    pub fn AHRS_GetWorldLinearAccelZ(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS8IsMovingEv"]
    pub fn AHRS_IsMoving(this: *mut AHRS) -> bool;
}
extern "C" {
    #[link_name = "_ZN4AHRS10IsRotatingEv"]
    pub fn AHRS_IsRotating(this: *mut AHRS) -> bool;
}
extern "C" {
    #[link_name = "_ZN4AHRS21GetBarometricPressureEv"]
    pub fn AHRS_GetBarometricPressure(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS11GetAltitudeEv"]
    pub fn AHRS_GetAltitude(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS15IsAltitudeValidEv"]
    pub fn AHRS_IsAltitudeValid(this: *mut AHRS) -> bool;
}
extern "C" {
    #[link_name = "_ZN4AHRS15GetFusedHeadingEv"]
    pub fn AHRS_GetFusedHeading(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS21IsMagneticDisturbanceEv"]
    pub fn AHRS_IsMagneticDisturbance(this: *mut AHRS) -> bool;
}
extern "C" {
    #[link_name = "_ZN4AHRS24IsMagnetometerCalibratedEv"]
    pub fn AHRS_IsMagnetometerCalibrated(this: *mut AHRS) -> bool;
}
extern "C" {
    #[link_name = "_ZN4AHRS14GetQuaternionWEv"]
    pub fn AHRS_GetQuaternionW(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS14GetQuaternionXEv"]
    pub fn AHRS_GetQuaternionX(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS14GetQuaternionYEv"]
    pub fn AHRS_GetQuaternionY(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS14GetQuaternionZEv"]
    pub fn AHRS_GetQuaternionZ(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS17ResetDisplacementEv"]
    pub fn AHRS_ResetDisplacement(this: *mut AHRS);
}
extern "C" {
    #[link_name = "_ZN4AHRS18UpdateDisplacementEffib"]
    pub fn AHRS_UpdateDisplacement(
        this: *mut AHRS,
        accel_x_g: f32,
        accel_y_g: f32,
        update_rate_hz: ::std::os::raw::c_int,
        is_moving: bool,
    );
}
extern "C" {
    #[link_name = "_ZN4AHRS12GetVelocityXEv"]
    pub fn AHRS_GetVelocityX(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS12GetVelocityYEv"]
    pub fn AHRS_GetVelocityY(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS12GetVelocityZEv"]
    pub fn AHRS_GetVelocityZ(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS16GetDisplacementXEv"]
    pub fn AHRS_GetDisplacementX(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS16GetDisplacementYEv"]
    pub fn AHRS_GetDisplacementY(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS16GetDisplacementZEv"]
    pub fn AHRS_GetDisplacementZ(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS18SetAngleAdjustmentEd"]
    pub fn AHRS_SetAngleAdjustment(this: *mut AHRS, angle: f64);
}
extern "C" {
    #[link_name = "_ZN4AHRS18GetAngleAdjustmentEv"]
    pub fn AHRS_GetAngleAdjustment(this: *mut AHRS) -> f64;
}
extern "C" {
    #[link_name = "_ZN4AHRS11GetRawGyroXEv"]
    pub fn AHRS_GetRawGyroX(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS11GetRawGyroYEv"]
    pub fn AHRS_GetRawGyroY(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS11GetRawGyroZEv"]
    pub fn AHRS_GetRawGyroZ(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS12GetRawAccelXEv"]
    pub fn AHRS_GetRawAccelX(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS12GetRawAccelYEv"]
    pub fn AHRS_GetRawAccelY(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS12GetRawAccelZEv"]
    pub fn AHRS_GetRawAccelZ(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS10GetRawMagXEv"]
    pub fn AHRS_GetRawMagX(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS10GetRawMagYEv"]
    pub fn AHRS_GetRawMagY(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS10GetRawMagZEv"]
    pub fn AHRS_GetRawMagZ(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS11GetPressureEv"]
    pub fn AHRS_GetPressure(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS8GetTempCEv"]
    pub fn AHRS_GetTempC(this: *mut AHRS) -> f32;
}
extern "C" {
    #[link_name = "_ZN4AHRS15GetBoardYawAxisEv"]
    pub fn AHRS_GetBoardYawAxis(this: *mut AHRS) -> AHRS_BoardYawAxis;
}
extern "C" {
    #[link_name = "_ZN4AHRS18GetFirmwareVersionEv"]
    pub fn AHRS_GetFirmwareVersion(this: *mut AHRS) -> std_string;
}
extern "C" {
    #[link_name = "_ZN4AHRS16RegisterCallbackEP26ITimestampedDataSubscriberPv"]
    pub fn AHRS_RegisterCallback(
        this: *mut AHRS,
        callback: *mut ITimestampedDataSubscriber,
        callback_context: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[link_name = "_ZN4AHRS18DeregisterCallbackEP26ITimestampedDataSubscriber"]
    pub fn AHRS_DeregisterCallback(
        this: *mut AHRS,
        callback: *mut ITimestampedDataSubscriber,
    ) -> bool;
}
extern "C" {
    #[link_name = "_ZN4AHRS19GetActualUpdateRateEv"]
    pub fn AHRS_GetActualUpdateRate(this: *mut AHRS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_ZN4AHRS22GetRequestedUpdateRateEv"]
    pub fn AHRS_GetRequestedUpdateRate(this: *mut AHRS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_ZN4AHRS13EnableLoggingEb"]
    pub fn AHRS_EnableLogging(this: *mut AHRS, enable: bool);
}
extern "C" {
    #[link_name = "_ZN4AHRS24EnableBoardlevelYawResetEb"]
    pub fn AHRS_EnableBoardlevelYawReset(this: *mut AHRS, enable: bool);
}
extern "C" {
    #[link_name = "_ZN4AHRS27IsBoardlevelYawResetEnabledEv"]
    pub fn AHRS_IsBoardlevelYawResetEnabled(this: *mut AHRS) -> bool;
}
extern "C" {
    #[link_name = "_ZN4AHRS24GetGyroFullScaleRangeDPSEv"]
    pub fn AHRS_GetGyroFullScaleRangeDPS(this: *mut AHRS) -> i16;
}
extern "C" {
    #[link_name = "_ZN4AHRS23GetAccelFullScaleRangeGEv"]
    pub fn AHRS_GetAccelFullScaleRangeG(this: *mut AHRS) -> i16;
}
extern "C" {
    #[link_name = "_ZN4AHRSC1EN3frc3SPI4PortE"]
    pub fn AHRS_AHRS(this: *mut AHRS, spi_port_id: frc_SPI_Port);
}
extern "C" {
    #[link_name = "_ZN4AHRSC1EN3frc3I2C4PortE"]
    pub fn AHRS_AHRS1(this: *mut AHRS, i2c_port_id: frc_I2C_Port);
}
extern "C" {
    #[link_name = "_ZN4AHRSC1EN3frc10SerialPort4PortE"]
    pub fn AHRS_AHRS2(this: *mut AHRS, serial_port_id: frc_SerialPort_Port);
}
extern "C" {
    #[link_name = "_ZN4AHRSC1EN3frc3SPI4PortEh"]
    pub fn AHRS_AHRS3(this: *mut AHRS, spi_port_id: frc_SPI_Port, update_rate_hz: u8);
}
extern "C" {
    #[link_name = "_ZN4AHRSC1EN3frc3SPI4PortEjh"]
    pub fn AHRS_AHRS4(
        this: *mut AHRS,
        spi_port_id: frc_SPI_Port,
        spi_bitrate: u32,
        update_rate_hz: u8,
    );
}
extern "C" {
    #[link_name = "_ZN4AHRSC1EN3frc3I2C4PortEh"]
    pub fn AHRS_AHRS5(this: *mut AHRS, i2c_port_id: frc_I2C_Port, update_rate_hz: u8);
}
extern "C" {
    #[link_name = "_ZN4AHRSC1EN3frc10SerialPort4PortENS_14SerialDataTypeEh"]
    pub fn AHRS_AHRS6(
        this: *mut AHRS,
        serial_port_id: frc_SerialPort_Port,
        data_type: AHRS_SerialDataType,
        update_rate_hz: u8,
    );
}
impl AHRS {
    #[inline]
    pub unsafe fn GetPitch(&mut self) -> f32 {
        AHRS_GetPitch(self)
    }
    #[inline]
    pub unsafe fn GetRoll(&mut self) -> f32 {
        AHRS_GetRoll(self)
    }
    #[inline]
    pub unsafe fn GetYaw(&mut self) -> f32 {
        AHRS_GetYaw(self)
    }
    #[inline]
    pub unsafe fn GetCompassHeading(&mut self) -> f32 {
        AHRS_GetCompassHeading(self)
    }
    #[inline]
    pub unsafe fn ZeroYaw(&mut self) {
        AHRS_ZeroYaw(self)
    }
    #[inline]
    pub unsafe fn IsCalibrating(&mut self) -> bool {
        AHRS_IsCalibrating(self)
    }
    #[inline]
    pub unsafe fn IsConnected(&mut self) -> bool {
        AHRS_IsConnected(self)
    }
    #[inline]
    pub unsafe fn GetByteCount(&mut self) -> f64 {
        AHRS_GetByteCount(self)
    }
    #[inline]
    pub unsafe fn GetUpdateCount(&mut self) -> f64 {
        AHRS_GetUpdateCount(self)
    }
    #[inline]
    pub unsafe fn GetLastSensorTimestamp(&mut self) -> ::std::os::raw::c_long {
        AHRS_GetLastSensorTimestamp(self)
    }
    #[inline]
    pub unsafe fn GetWorldLinearAccelX(&mut self) -> f32 {
        AHRS_GetWorldLinearAccelX(self)
    }
    #[inline]
    pub unsafe fn GetWorldLinearAccelY(&mut self) -> f32 {
        AHRS_GetWorldLinearAccelY(self)
    }
    #[inline]
    pub unsafe fn GetWorldLinearAccelZ(&mut self) -> f32 {
        AHRS_GetWorldLinearAccelZ(self)
    }
    #[inline]
    pub unsafe fn IsMoving(&mut self) -> bool {
        AHRS_IsMoving(self)
    }
    #[inline]
    pub unsafe fn IsRotating(&mut self) -> bool {
        AHRS_IsRotating(self)
    }
    #[inline]
    pub unsafe fn GetBarometricPressure(&mut self) -> f32 {
        AHRS_GetBarometricPressure(self)
    }
    #[inline]
    pub unsafe fn GetAltitude(&mut self) -> f32 {
        AHRS_GetAltitude(self)
    }
    #[inline]
    pub unsafe fn IsAltitudeValid(&mut self) -> bool {
        AHRS_IsAltitudeValid(self)
    }
    #[inline]
    pub unsafe fn GetFusedHeading(&mut self) -> f32 {
        AHRS_GetFusedHeading(self)
    }
    #[inline]
    pub unsafe fn IsMagneticDisturbance(&mut self) -> bool {
        AHRS_IsMagneticDisturbance(self)
    }
    #[inline]
    pub unsafe fn IsMagnetometerCalibrated(&mut self) -> bool {
        AHRS_IsMagnetometerCalibrated(self)
    }
    #[inline]
    pub unsafe fn GetQuaternionW(&mut self) -> f32 {
        AHRS_GetQuaternionW(self)
    }
    #[inline]
    pub unsafe fn GetQuaternionX(&mut self) -> f32 {
        AHRS_GetQuaternionX(self)
    }
    #[inline]
    pub unsafe fn GetQuaternionY(&mut self) -> f32 {
        AHRS_GetQuaternionY(self)
    }
    #[inline]
    pub unsafe fn GetQuaternionZ(&mut self) -> f32 {
        AHRS_GetQuaternionZ(self)
    }
    #[inline]
    pub unsafe fn ResetDisplacement(&mut self) {
        AHRS_ResetDisplacement(self)
    }
    #[inline]
    pub unsafe fn UpdateDisplacement(
        &mut self,
        accel_x_g: f32,
        accel_y_g: f32,
        update_rate_hz: ::std::os::raw::c_int,
        is_moving: bool,
    ) {
        AHRS_UpdateDisplacement(self, accel_x_g, accel_y_g, update_rate_hz, is_moving)
    }
    #[inline]
    pub unsafe fn GetVelocityX(&mut self) -> f32 {
        AHRS_GetVelocityX(self)
    }
    #[inline]
    pub unsafe fn GetVelocityY(&mut self) -> f32 {
        AHRS_GetVelocityY(self)
    }
    #[inline]
    pub unsafe fn GetVelocityZ(&mut self) -> f32 {
        AHRS_GetVelocityZ(self)
    }
    #[inline]
    pub unsafe fn GetDisplacementX(&mut self) -> f32 {
        AHRS_GetDisplacementX(self)
    }
    #[inline]
    pub unsafe fn GetDisplacementY(&mut self) -> f32 {
        AHRS_GetDisplacementY(self)
    }
    #[inline]
    pub unsafe fn GetDisplacementZ(&mut self) -> f32 {
        AHRS_GetDisplacementZ(self)
    }
    #[inline]
    pub unsafe fn SetAngleAdjustment(&mut self, angle: f64) {
        AHRS_SetAngleAdjustment(self, angle)
    }
    #[inline]
    pub unsafe fn GetAngleAdjustment(&mut self) -> f64 {
        AHRS_GetAngleAdjustment(self)
    }
    #[inline]
    pub unsafe fn GetRawGyroX(&mut self) -> f32 {
        AHRS_GetRawGyroX(self)
    }
    #[inline]
    pub unsafe fn GetRawGyroY(&mut self) -> f32 {
        AHRS_GetRawGyroY(self)
    }
    #[inline]
    pub unsafe fn GetRawGyroZ(&mut self) -> f32 {
        AHRS_GetRawGyroZ(self)
    }
    #[inline]
    pub unsafe fn GetRawAccelX(&mut self) -> f32 {
        AHRS_GetRawAccelX(self)
    }
    #[inline]
    pub unsafe fn GetRawAccelY(&mut self) -> f32 {
        AHRS_GetRawAccelY(self)
    }
    #[inline]
    pub unsafe fn GetRawAccelZ(&mut self) -> f32 {
        AHRS_GetRawAccelZ(self)
    }
    #[inline]
    pub unsafe fn GetRawMagX(&mut self) -> f32 {
        AHRS_GetRawMagX(self)
    }
    #[inline]
    pub unsafe fn GetRawMagY(&mut self) -> f32 {
        AHRS_GetRawMagY(self)
    }
    #[inline]
    pub unsafe fn GetRawMagZ(&mut self) -> f32 {
        AHRS_GetRawMagZ(self)
    }
    #[inline]
    pub unsafe fn GetPressure(&mut self) -> f32 {
        AHRS_GetPressure(self)
    }
    #[inline]
    pub unsafe fn GetTempC(&mut self) -> f32 {
        AHRS_GetTempC(self)
    }
    #[inline]
    pub unsafe fn GetBoardYawAxis(&mut self) -> AHRS_BoardYawAxis {
        AHRS_GetBoardYawAxis(self)
    }
    #[inline]
    pub unsafe fn GetFirmwareVersion(&mut self) -> std_string {
        AHRS_GetFirmwareVersion(self)
    }
    #[inline]
    pub unsafe fn RegisterCallback(
        &mut self,
        callback: *mut ITimestampedDataSubscriber,
        callback_context: *mut ::std::os::raw::c_void,
    ) -> bool {
        AHRS_RegisterCallback(self, callback, callback_context)
    }
    #[inline]
    pub unsafe fn DeregisterCallback(&mut self, callback: *mut ITimestampedDataSubscriber) -> bool {
        AHRS_DeregisterCallback(self, callback)
    }
    #[inline]
    pub unsafe fn GetActualUpdateRate(&mut self) -> ::std::os::raw::c_int {
        AHRS_GetActualUpdateRate(self)
    }
    #[inline]
    pub unsafe fn GetRequestedUpdateRate(&mut self) -> ::std::os::raw::c_int {
        AHRS_GetRequestedUpdateRate(self)
    }
    #[inline]
    pub unsafe fn EnableLogging(&mut self, enable: bool) {
        AHRS_EnableLogging(self, enable)
    }
    #[inline]
    pub unsafe fn EnableBoardlevelYawReset(&mut self, enable: bool) {
        AHRS_EnableBoardlevelYawReset(self, enable)
    }
    #[inline]
    pub unsafe fn IsBoardlevelYawResetEnabled(&mut self) -> bool {
        AHRS_IsBoardlevelYawResetEnabled(self)
    }
    #[inline]
    pub unsafe fn GetGyroFullScaleRangeDPS(&mut self) -> i16 {
        AHRS_GetGyroFullScaleRangeDPS(self)
    }
    #[inline]
    pub unsafe fn GetAccelFullScaleRangeG(&mut self) -> i16 {
        AHRS_GetAccelFullScaleRangeG(self)
    }
    #[inline]
    pub unsafe fn new(spi_port_id: frc_SPI_Port) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        AHRS_AHRS(__bindgen_tmp.as_mut_ptr(), spi_port_id);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(i2c_port_id: frc_I2C_Port) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        AHRS_AHRS1(__bindgen_tmp.as_mut_ptr(), i2c_port_id);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(serial_port_id: frc_SerialPort_Port) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        AHRS_AHRS2(__bindgen_tmp.as_mut_ptr(), serial_port_id);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(spi_port_id: frc_SPI_Port, update_rate_hz: u8) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        AHRS_AHRS3(__bindgen_tmp.as_mut_ptr(), spi_port_id, update_rate_hz);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(spi_port_id: frc_SPI_Port, spi_bitrate: u32, update_rate_hz: u8) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        AHRS_AHRS4(
            __bindgen_tmp.as_mut_ptr(),
            spi_port_id,
            spi_bitrate,
            update_rate_hz,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(i2c_port_id: frc_I2C_Port, update_rate_hz: u8) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        AHRS_AHRS5(__bindgen_tmp.as_mut_ptr(), i2c_port_id, update_rate_hz);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new6(
        serial_port_id: frc_SerialPort_Port,
        data_type: AHRS_SerialDataType,
        update_rate_hz: u8,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        AHRS_AHRS6(
            __bindgen_tmp.as_mut_ptr(),
            serial_port_id,
            data_type,
            update_rate_hz,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "_ZNK4AHRS8GetAngleEv"]
    pub fn AHRS_GetAngle(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[link_name = "_ZNK4AHRS7GetRateEv"]
    pub fn AHRS_GetRate(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[link_name = "_ZN4AHRS5ResetEv"]
    pub fn AHRS_Reset(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Gyro interface implementation"]
    #[link_name = "_ZN4AHRS9CalibrateEv"]
    pub fn AHRS_Calibrate(this: *mut ::std::os::raw::c_void);
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_AHRS_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
