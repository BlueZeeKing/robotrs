/* automatically generated by rust-bindgen 0.66.1 */
#![allow(warnings)]
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std__If = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
pub type std_iterator_traits___primary_template = std_iterator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
pub type std_iterator_iterator_category<_Category> = _Category;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iter> {
    pub __t: _Iter,
    pub current: _Iter,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iter>>,
}
pub type std_reverse_iterator_iterator_type<_Iter> = _Iter;
pub type std_reverse_iterator_iterator_category = std__If;
pub type std_reverse_iterator_pointer = std_iterator_traits;
pub type std_reverse_iterator_value_type = std_iterator_traits;
pub type std_reverse_iterator_difference_type = std_iterator_traits;
pub type std_reverse_iterator_reference = std_iterator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___wrap_iter<_Iter> {
    pub __i: std___wrap_iter_iterator_type<_Iter>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iter>>,
}
pub type std___wrap_iter_iterator_type<_Iter> = _Iter;
pub type std___wrap_iter_value_type = std_iterator_traits;
pub type std___wrap_iter_difference_type = std_iterator_traits;
pub type std___wrap_iter_pointer = std_iterator_traits;
pub type std___wrap_iter_reference = std_iterator_traits;
pub type std___wrap_iter_iterator_category = std_iterator_traits;
pub type std___allocator_traits_rebind_type = [u8; 0usize];
pub type std___allocator_traits_rebind_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = [u8; 0usize];
pub type std_allocator_traits_pointer = [u8; 0usize];
pub type std_allocator_traits_const_pointer = [u8; 0usize];
pub type std_allocator_traits_void_pointer = [u8; 0usize];
pub type std_allocator_traits_const_void_pointer = [u8; 0usize];
pub type std_allocator_traits_difference_type = [u8; 0usize];
pub type std_allocator_traits_size_type = [u8; 0usize];
pub type std_allocator_traits_propagate_on_container_copy_assignment = u8;
pub type std_allocator_traits_propagate_on_container_move_assignment = u8;
pub type std_allocator_traits_propagate_on_container_swap = u8;
pub type std_allocator_traits_is_always_equal = u8;
pub type std_allocator_traits_rebind_alloc = std___allocator_traits_rebind_t;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
pub type std_streampos = std_fpos<__mbstate_t>;
pub type std_streamoff = ::std::os::raw::c_longlong;
pub type std_string = std_basic_string;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = ::std::os::raw::c_ulong;
pub type std_allocator_difference_type = ::std::os::raw::c_long;
pub type std_allocator_value_type<_Tp> = _Tp;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
pub type std___compressed_pair_elem__ParamT<_Tp> = _Tp;
pub type std___compressed_pair_elem_reference<_Tp> = *mut _Tp;
pub type std___compressed_pair_elem_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___compressed_pair {
    pub _address: u8,
}
pub type std___compressed_pair__Base1 = u8;
pub type std___compressed_pair__Base2 = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_fpos<_StateT> {
    pub __st_: _StateT,
    pub __off_: std_streamoff,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
pub type std_char_traits_char_type<_CharT> = _CharT;
pub type std_char_traits_int_type = ::std::os::raw::c_int;
pub type std_char_traits_off_type = std_streamoff;
pub type std_char_traits_pos_type = std_streampos;
pub type std_char_traits_state_type = __mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string_view<_CharT> {
    pub __data: *const std_basic_string_view_value_type<_CharT>,
    pub __size: std_basic_string_view_size_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_string_view_traits_type<_Traits> = _Traits;
pub type std_basic_string_view_value_type<_CharT> = _CharT;
pub type std_basic_string_view_pointer<_CharT> = *mut _CharT;
pub type std_basic_string_view_const_pointer<_CharT> = *const _CharT;
pub type std_basic_string_view_reference<_CharT> = *mut _CharT;
pub type std_basic_string_view_const_reference<_CharT> = *const _CharT;
pub type std_basic_string_view_const_iterator<_CharT> = std_basic_string_view_const_pointer<_CharT>;
pub type std_basic_string_view_iterator<_CharT> = std_basic_string_view_const_iterator<_CharT>;
pub type std_basic_string_view_const_reverse_iterator<_CharT> =
    std_reverse_iterator<std_basic_string_view_const_iterator<_CharT>>;
pub type std_basic_string_view_reverse_iterator<_CharT> =
    std_basic_string_view_const_reverse_iterator<_CharT>;
pub type std_basic_string_view_size_type = ::std::os::raw::c_ulong;
pub type std_basic_string_view_difference_type = ::std::os::raw::c_long;
#[repr(C)]
pub struct std_basic_string {
    pub __r_: std___compressed_pair,
}
pub type std_basic_string___self = std_basic_string;
pub type std_basic_string___self_view<_CharT> = std_basic_string_view<_CharT>;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_value_type<_CharT> = _CharT;
pub type std_basic_string_allocator_type<_Allocator> = _Allocator;
pub type std_basic_string___alloc_traits = std_allocator_traits;
pub type std_basic_string_size_type = std_basic_string___alloc_traits;
pub type std_basic_string_difference_type = std_basic_string___alloc_traits;
pub type std_basic_string_reference<_CharT> = *mut std_basic_string_value_type<_CharT>;
pub type std_basic_string_const_reference<_CharT> = *const std_basic_string_value_type<_CharT>;
pub type std_basic_string_pointer = std_basic_string___alloc_traits;
pub type std_basic_string_const_pointer = std_basic_string___alloc_traits;
pub type std_basic_string_iterator = std___wrap_iter<std_basic_string_pointer>;
pub type std_basic_string_const_iterator = std___wrap_iter<std_basic_string_const_pointer>;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___long {
    pub _address: u8,
}
pub const std_basic_string___min_cap: std_basic_string__bindgen_ty_1 = 0;
pub type std_basic_string__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___short<_CharT> {
    pub __data_: *mut std_basic_string_value_type<_CharT>,
    pub __padding_: *mut ::std::os::raw::c_uchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
impl<_CharT> std_basic_string___short<_CharT> {
    #[inline]
    pub fn __size_(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set___size_(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn __is_long_(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set___is_long_(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __size_: ::std::os::raw::c_uchar,
        __is_long_: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let __size_: u8 = unsafe { ::std::mem::transmute(__size_) };
            __size_ as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __is_long_: u8 = unsafe { ::std::mem::transmute(__is_long_) };
            __is_long_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(1))]
pub struct std_basic_string___ulx<_CharT> {
    pub __lx: __BindgenUnionField<u8>,
    pub __lxx: __BindgenUnionField<std_basic_string___short<_CharT>>,
    pub bindgen_union_field: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub const std_basic_string___n_words: std_basic_string__bindgen_ty_2 = 0;
pub type std_basic_string__bindgen_ty_2 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___raw {
    pub __words: *mut std_basic_string_size_type,
}
#[repr(C)]
pub struct std_basic_string___rep<_CharT> {
    pub __bindgen_anon_1: std_basic_string___rep__bindgen_ty_1<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
#[repr(C)]
#[repr(align(1))]
pub struct std_basic_string___rep__bindgen_ty_1<_CharT> {
    pub __l: __BindgenUnionField<u8>,
    pub __s: __BindgenUnionField<std_basic_string___short<_CharT>>,
    pub __r: __BindgenUnionField<std_basic_string___raw>,
    pub bindgen_union_field: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub const std_basic_string___alignment: std_basic_string__bindgen_ty_3 = 0;
pub type std_basic_string__bindgen_ty_3 = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub const _c_REVLib_ErrorCode_c_REVLibError_None: _c_REVLib_ErrorCode = 0;
pub const _c_REVLib_ErrorCode_c_REVLibError_General: _c_REVLib_ErrorCode = 1;
pub const _c_REVLib_ErrorCode_c_REVLibError_CANTimeout: _c_REVLib_ErrorCode = 2;
pub const _c_REVLib_ErrorCode_c_REVLibError_NotImplemented: _c_REVLib_ErrorCode = 3;
pub const _c_REVLib_ErrorCode_c_REVLibError_HAL: _c_REVLib_ErrorCode = 4;
pub const _c_REVLib_ErrorCode_c_REVLibError_CantFindFirmware: _c_REVLib_ErrorCode = 5;
pub const _c_REVLib_ErrorCode_c_REVLibError_FirmwareTooOld: _c_REVLib_ErrorCode = 6;
pub const _c_REVLib_ErrorCode_c_REVLibError_FirmwareTooNew: _c_REVLib_ErrorCode = 7;
pub const _c_REVLib_ErrorCode_c_REVLibError_ParamInvalidID: _c_REVLib_ErrorCode = 8;
pub const _c_REVLib_ErrorCode_c_REVLibError_ParamMismatchType: _c_REVLib_ErrorCode = 9;
pub const _c_REVLib_ErrorCode_c_REVLibError_ParamAccessMode: _c_REVLib_ErrorCode = 10;
pub const _c_REVLib_ErrorCode_c_REVLibError_ParamInvalid: _c_REVLib_ErrorCode = 11;
pub const _c_REVLib_ErrorCode_c_REVLibError_ParamNotImplementedDeprecated: _c_REVLib_ErrorCode = 12;
pub const _c_REVLib_ErrorCode_c_REVLibError_FollowConfigMismatch: _c_REVLib_ErrorCode = 13;
pub const _c_REVLib_ErrorCode_c_REVLibError_Invalid: _c_REVLib_ErrorCode = 14;
pub const _c_REVLib_ErrorCode_c_REVLibError_SetpointOutOfRange: _c_REVLib_ErrorCode = 15;
pub const _c_REVLib_ErrorCode_c_REVLibError_Unknown: _c_REVLib_ErrorCode = 16;
pub const _c_REVLib_ErrorCode_c_REVLibError_CANDisconnected: _c_REVLib_ErrorCode = 17;
pub const _c_REVLib_ErrorCode_c_REVLibError_DuplicateCANId: _c_REVLib_ErrorCode = 18;
pub const _c_REVLib_ErrorCode_c_REVLibError_InvalidCANId: _c_REVLib_ErrorCode = 19;
pub const _c_REVLib_ErrorCode_c_REVLibError_SparkMaxDataPortAlreadyConfiguredDifferently:
    _c_REVLib_ErrorCode = 20;
pub const _c_REVLib_ErrorCode_c_REVLibError_NumCodes: _c_REVLib_ErrorCode = 21;
pub type _c_REVLib_ErrorCode = ::std::os::raw::c_uint;
pub use self::_c_REVLib_ErrorCode as c_REVLib_ErrorCode;
extern "C" {
    pub fn c_REVLib_SendError(code: c_REVLib_ErrorCode, deviceId: ::std::os::raw::c_int);
}
extern "C" {
    pub fn c_REVLib_SendErrorText(
        code: c_REVLib_ErrorCode,
        deviceId: ::std::os::raw::c_int,
        context: std_string,
    );
}
extern "C" {
    pub fn c_REVLib_FlushErrors();
}
extern "C" {
    pub fn c_REVLib_SuppressErrors(suppress: bool);
}
extern "C" {
    pub fn c_REVLib_ErrorSize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c_REVLib_ErrorFromCode(code: c_REVLib_ErrorCode) -> *const ::std::os::raw::c_char;
}
pub const c_SparkMax_kAPIMajorVersion: u16 = 2023;
pub const c_SparkMax_kAPIMinorVersion: u8 = 1;
pub const c_SparkMax_kAPIBuildVersion: u8 = 3;
pub const c_SparkMax_kAPIVersion: u32 = 132579587;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c_SparkMax_Obj {
    _unused: [u8; 0],
}
pub type c_SparkMax_handle = *mut c_SparkMax_Obj;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c_SparkMax_APIVersion {
    pub Major: u16,
    pub Minor: u8,
    pub Build: u8,
    pub Version: u32,
}
#[test]
fn bindgen_test_layout_c_SparkMax_APIVersion() {
    const UNINIT: ::std::mem::MaybeUninit<c_SparkMax_APIVersion> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<c_SparkMax_APIVersion>(),
        8usize,
        concat!("Size of: ", stringify!(c_SparkMax_APIVersion))
    );
    assert_eq!(
        ::std::mem::align_of::<c_SparkMax_APIVersion>(),
        4usize,
        concat!("Alignment of ", stringify!(c_SparkMax_APIVersion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_APIVersion),
            "::",
            stringify!(Major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Minor) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_APIVersion),
            "::",
            stringify!(Minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Build) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_APIVersion),
            "::",
            stringify!(Build)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_APIVersion),
            "::",
            stringify!(Version)
        )
    );
}
pub const c_SparkMax_LimitDirection_c_SparkMax_kForward: c_SparkMax_LimitDirection = 0;
pub const c_SparkMax_LimitDirection_c_SparkMax_kReverse: c_SparkMax_LimitDirection = 1;
pub type c_SparkMax_LimitDirection = ::std::os::raw::c_uint;
pub const c_SparkMax_LimitPolarity_c_SparkMax_kNormallyOpen: c_SparkMax_LimitPolarity = 0;
pub const c_SparkMax_LimitPolarity_c_SparkMax_kNormallyClosed: c_SparkMax_LimitPolarity = 1;
pub type c_SparkMax_LimitPolarity = ::std::os::raw::c_uint;
pub const c_SparkMax_EncoderType_c_SparkMax_kNoSensor: c_SparkMax_EncoderType = 0;
pub const c_SparkMax_EncoderType_c_SparkMax_kHallSensor: c_SparkMax_EncoderType = 1;
pub const c_SparkMax_EncoderType_c_SparkMax_kQuadrature: c_SparkMax_EncoderType = 2;
pub const c_SparkMax_EncoderType_c_SparkMax_kSensorless: c_SparkMax_EncoderType = 3;
pub const c_SparkMax_EncoderType_c_SparkMax_kAlternateQuadrature: c_SparkMax_EncoderType = 4;
pub type c_SparkMax_EncoderType = ::std::os::raw::c_uint;
pub const c_SparkMax_IdleMode_c_SparkMax_kCoast: c_SparkMax_IdleMode = 0;
pub const c_SparkMax_IdleMode_c_SparkMax_kBrake: c_SparkMax_IdleMode = 1;
pub type c_SparkMax_IdleMode = ::std::os::raw::c_uint;
pub const c_SparkMax_InputMode_c_SparkMax_kPWM: c_SparkMax_InputMode = 0;
pub const c_SparkMax_InputMode_c_SparkMax_kCAN: c_SparkMax_InputMode = 1;
pub type c_SparkMax_InputMode = ::std::os::raw::c_uint;
pub const c_SparkMax_FaultID_c_SparkMax_Fault_kBrownout: c_SparkMax_FaultID = 0;
pub const c_SparkMax_FaultID_c_SparkMax_Fault_kOvercurrent: c_SparkMax_FaultID = 1;
pub const c_SparkMax_FaultID_c_SparkMax_Fault_kIWDTReset: c_SparkMax_FaultID = 2;
pub const c_SparkMax_FaultID_c_SparkMax_Fault_kMotorFault: c_SparkMax_FaultID = 3;
pub const c_SparkMax_FaultID_c_SparkMax_Fault_kSensorFault: c_SparkMax_FaultID = 4;
pub const c_SparkMax_FaultID_c_SparkMax_Fault_kStall: c_SparkMax_FaultID = 5;
pub const c_SparkMax_FaultID_c_SparkMax_Fault_kEEPROMCRC: c_SparkMax_FaultID = 6;
pub const c_SparkMax_FaultID_c_SparkMax_Fault_kCANTX: c_SparkMax_FaultID = 7;
pub const c_SparkMax_FaultID_c_SparkMax_Fault_kCANRX: c_SparkMax_FaultID = 8;
pub const c_SparkMax_FaultID_c_SparkMax_Fault_kHasReset: c_SparkMax_FaultID = 9;
pub const c_SparkMax_FaultID_c_SparkMax_Fault_kDRVFault: c_SparkMax_FaultID = 10;
pub const c_SparkMax_FaultID_c_SparkMax_Fault_kOtherFault: c_SparkMax_FaultID = 11;
pub const c_SparkMax_FaultID_c_SparkMax_Fault_kSoftLimitFwd: c_SparkMax_FaultID = 12;
pub const c_SparkMax_FaultID_c_SparkMax_Fault_kSoftLimitRev: c_SparkMax_FaultID = 13;
pub const c_SparkMax_FaultID_c_SparkMax_Fault_kHardLimitFwd: c_SparkMax_FaultID = 14;
pub const c_SparkMax_FaultID_c_SparkMax_Fault_kHardLimitRev: c_SparkMax_FaultID = 15;
pub type c_SparkMax_FaultID = ::std::os::raw::c_uint;
pub const c_SparkMax_MotorType_c_SparkMax_kBrushed: c_SparkMax_MotorType = 0;
pub const c_SparkMax_MotorType_c_SparkMax_kBrushless: c_SparkMax_MotorType = 1;
pub type c_SparkMax_MotorType = ::std::os::raw::c_uint;
pub const c_SparkMax_ParameterStatus_c_SparkMax_kParamOK: c_SparkMax_ParameterStatus = 0;
pub const c_SparkMax_ParameterStatus_c_SparkMax_kInvalidID: c_SparkMax_ParameterStatus = 1;
pub const c_SparkMax_ParameterStatus_c_SparkMax_kMismatchType: c_SparkMax_ParameterStatus = 2;
pub const c_SparkMax_ParameterStatus_c_SparkMax_kAccessMode: c_SparkMax_ParameterStatus = 3;
pub const c_SparkMax_ParameterStatus_c_SparkMax_kInvalid: c_SparkMax_ParameterStatus = 4;
pub const c_SparkMax_ParameterStatus_c_SparkMax_kNotImplementedDeprecated:
    c_SparkMax_ParameterStatus = 5;
pub type c_SparkMax_ParameterStatus = ::std::os::raw::c_uint;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kCanID: c_SparkMax_ConfigParameter = 0;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kInputMode: c_SparkMax_ConfigParameter = 1;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kMotorType: c_SparkMax_ConfigParameter = 2;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kCommAdvance: c_SparkMax_ConfigParameter = 3;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSensorType: c_SparkMax_ConfigParameter = 4;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kCtrlType: c_SparkMax_ConfigParameter = 5;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kIdleMode: c_SparkMax_ConfigParameter = 6;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kInputDeadband: c_SparkMax_ConfigParameter = 7;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kFeedbackSensorPID0: c_SparkMax_ConfigParameter = 8;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kFeedbackSensorPID1: c_SparkMax_ConfigParameter = 9;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kPolePairs: c_SparkMax_ConfigParameter = 10;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kCurrentChop: c_SparkMax_ConfigParameter = 11;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kCurrentChopCycles: c_SparkMax_ConfigParameter = 12;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kP_0: c_SparkMax_ConfigParameter = 13;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kI_0: c_SparkMax_ConfigParameter = 14;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kD_0: c_SparkMax_ConfigParameter = 15;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kF_0: c_SparkMax_ConfigParameter = 16;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kIZone_0: c_SparkMax_ConfigParameter = 17;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kDFilter_0: c_SparkMax_ConfigParameter = 18;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kOutputMin_0: c_SparkMax_ConfigParameter = 19;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kOutputMax_0: c_SparkMax_ConfigParameter = 20;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kP_1: c_SparkMax_ConfigParameter = 21;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kI_1: c_SparkMax_ConfigParameter = 22;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kD_1: c_SparkMax_ConfigParameter = 23;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kF_1: c_SparkMax_ConfigParameter = 24;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kIZone_1: c_SparkMax_ConfigParameter = 25;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kDFilter_1: c_SparkMax_ConfigParameter = 26;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kOutputMin_1: c_SparkMax_ConfigParameter = 27;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kOutputMax_1: c_SparkMax_ConfigParameter = 28;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kP_2: c_SparkMax_ConfigParameter = 29;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kI_2: c_SparkMax_ConfigParameter = 30;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kD_2: c_SparkMax_ConfigParameter = 31;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kF_2: c_SparkMax_ConfigParameter = 32;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kIZone_2: c_SparkMax_ConfigParameter = 33;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kDFilter_2: c_SparkMax_ConfigParameter = 34;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kOutputMin_2: c_SparkMax_ConfigParameter = 35;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kOutputMax_2: c_SparkMax_ConfigParameter = 36;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kP_3: c_SparkMax_ConfigParameter = 37;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kI_3: c_SparkMax_ConfigParameter = 38;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kD_3: c_SparkMax_ConfigParameter = 39;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kF_3: c_SparkMax_ConfigParameter = 40;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kIZone_3: c_SparkMax_ConfigParameter = 41;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kDFilter_3: c_SparkMax_ConfigParameter = 42;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kOutputMin_3: c_SparkMax_ConfigParameter = 43;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kOutputMax_3: c_SparkMax_ConfigParameter = 44;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kInverted: c_SparkMax_ConfigParameter = 45;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kOutputRatio: c_SparkMax_ConfigParameter = 46;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSerialNumberLow: c_SparkMax_ConfigParameter = 47;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSerialNumberMid: c_SparkMax_ConfigParameter = 48;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSerialNumberHigh: c_SparkMax_ConfigParameter = 49;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kLimitSwitchFwdPolarity:
    c_SparkMax_ConfigParameter = 50;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kLimitSwitchRevPolarity:
    c_SparkMax_ConfigParameter = 51;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kHardLimitFwdEn: c_SparkMax_ConfigParameter = 52;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kHardLimitRevEn: c_SparkMax_ConfigParameter = 53;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSoftLimitFwdEn: c_SparkMax_ConfigParameter = 54;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSoftLimitRevEn: c_SparkMax_ConfigParameter = 55;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kRampRate: c_SparkMax_ConfigParameter = 56;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kFollowerID: c_SparkMax_ConfigParameter = 57;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kFollowerConfig: c_SparkMax_ConfigParameter = 58;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartCurrentStallLimit:
    c_SparkMax_ConfigParameter = 59;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartCurrentFreeLimit: c_SparkMax_ConfigParameter =
    60;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartCurrentConfig: c_SparkMax_ConfigParameter =
    61;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartCurrentReserved: c_SparkMax_ConfigParameter =
    62;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kMotorKv: c_SparkMax_ConfigParameter = 63;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kMotorR: c_SparkMax_ConfigParameter = 64;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kMotorL: c_SparkMax_ConfigParameter = 65;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kMotorRsvd1: c_SparkMax_ConfigParameter = 66;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kMotorRsvd2: c_SparkMax_ConfigParameter = 67;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kMotorRsvd3: c_SparkMax_ConfigParameter = 68;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kEncoderCountsPerRev: c_SparkMax_ConfigParameter =
    69;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kEncoderAverageDepth: c_SparkMax_ConfigParameter =
    70;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kEncoderSampleDelta: c_SparkMax_ConfigParameter =
    71;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kEncoderInverted: c_SparkMax_ConfigParameter = 72;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kEncoderRsvd1: c_SparkMax_ConfigParameter = 73;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kVoltageCompMode: c_SparkMax_ConfigParameter = 74;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kCompensatedNominalVoltage:
    c_SparkMax_ConfigParameter = 75;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartMotionMaxVelocity_0:
    c_SparkMax_ConfigParameter = 76;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartMotionMaxAccel_0: c_SparkMax_ConfigParameter =
    77;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartMotionMinVelOutput_0:
    c_SparkMax_ConfigParameter = 78;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartMotionAllowedClosedLoopError_0:
    c_SparkMax_ConfigParameter = 79;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartMotionAccelStrategy_0:
    c_SparkMax_ConfigParameter = 80;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartMotionMaxVelocity_1:
    c_SparkMax_ConfigParameter = 81;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartMotionMaxAccel_1: c_SparkMax_ConfigParameter =
    82;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartMotionMinVelOutput_1:
    c_SparkMax_ConfigParameter = 83;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartMotionAllowedClosedLoopError_1:
    c_SparkMax_ConfigParameter = 84;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartMotionAccelStrategy_1:
    c_SparkMax_ConfigParameter = 85;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartMotionMaxVelocity_2:
    c_SparkMax_ConfigParameter = 86;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartMotionMaxAccel_2: c_SparkMax_ConfigParameter =
    87;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartMotionMinVelOutput_2:
    c_SparkMax_ConfigParameter = 88;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartMotionAllowedClosedLoopError_2:
    c_SparkMax_ConfigParameter = 89;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartMotionAccelStrategy_2:
    c_SparkMax_ConfigParameter = 90;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartMotionMaxVelocity_3:
    c_SparkMax_ConfigParameter = 91;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartMotionMaxAccel_3: c_SparkMax_ConfigParameter =
    92;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartMotionMinVelOutput_3:
    c_SparkMax_ConfigParameter = 93;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartMotionAllowedClosedLoopError_3:
    c_SparkMax_ConfigParameter = 94;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSmartMotionAccelStrategy_3:
    c_SparkMax_ConfigParameter = 95;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kIMaxAccum_0: c_SparkMax_ConfigParameter = 96;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSlot3Placeholder1_0: c_SparkMax_ConfigParameter =
    97;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSlot3Placeholder2_0: c_SparkMax_ConfigParameter =
    98;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSlot3Placeholder3_0: c_SparkMax_ConfigParameter =
    99;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kIMaxAccum_1: c_SparkMax_ConfigParameter = 100;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSlot3Placeholder1_1: c_SparkMax_ConfigParameter =
    101;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSlot3Placeholder2_1: c_SparkMax_ConfigParameter =
    102;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSlot3Placeholder3_1: c_SparkMax_ConfigParameter =
    103;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kIMaxAccum_2: c_SparkMax_ConfigParameter = 104;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSlot3Placeholder1_2: c_SparkMax_ConfigParameter =
    105;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSlot3Placeholder2_2: c_SparkMax_ConfigParameter =
    106;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSlot3Placeholder3_2: c_SparkMax_ConfigParameter =
    107;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kIMaxAccum_3: c_SparkMax_ConfigParameter = 108;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSlot3Placeholder1_3: c_SparkMax_ConfigParameter =
    109;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSlot3Placeholder2_3: c_SparkMax_ConfigParameter =
    110;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSlot3Placeholder3_3: c_SparkMax_ConfigParameter =
    111;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kPositionConversionFactor:
    c_SparkMax_ConfigParameter = 112;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kVelocityConversionFactor:
    c_SparkMax_ConfigParameter = 113;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kClosedLoopRampRate: c_SparkMax_ConfigParameter =
    114;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSoftLimitFwd: c_SparkMax_ConfigParameter = 115;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSoftLimitRev: c_SparkMax_ConfigParameter = 116;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSoftLimitRsvd0: c_SparkMax_ConfigParameter = 117;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kSoftLimitRsvd1: c_SparkMax_ConfigParameter = 118;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kAnalogRevPerVolt: c_SparkMax_ConfigParameter = 119;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kAnalogRotationsPerVoltSec:
    c_SparkMax_ConfigParameter = 120;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kAnalogAverageDepth: c_SparkMax_ConfigParameter =
    121;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kAnalogSensorMode: c_SparkMax_ConfigParameter = 122;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kAnalogInverted: c_SparkMax_ConfigParameter = 123;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kAnalogSampleDelta: c_SparkMax_ConfigParameter =
    124;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kAnalogRsvd0: c_SparkMax_ConfigParameter = 125;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kAnalogRsvd1: c_SparkMax_ConfigParameter = 126;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kDataPortConfig: c_SparkMax_ConfigParameter = 127;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kAltEncoderCountsPerRev:
    c_SparkMax_ConfigParameter = 128;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kAltEncoderAverageDepth:
    c_SparkMax_ConfigParameter = 129;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kAltEncoderSampleDelta: c_SparkMax_ConfigParameter =
    130;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kAltEncoderInverted: c_SparkMax_ConfigParameter =
    131;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kAltEncodePositionFactor:
    c_SparkMax_ConfigParameter = 132;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kAltEncoderVelocityFactor:
    c_SparkMax_ConfigParameter = 133;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kAltEncoderRsvd0: c_SparkMax_ConfigParameter = 134;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kAltEncoderRsvd1: c_SparkMax_ConfigParameter = 135;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kHallSensorSampleRate: c_SparkMax_ConfigParameter =
    136;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kHallSensorAverageDepth:
    c_SparkMax_ConfigParameter = 137;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kNumParameters: c_SparkMax_ConfigParameter = 138;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kDutyCyclePositionFactor:
    c_SparkMax_ConfigParameter = 139;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kDutyCycleVelocityFactor:
    c_SparkMax_ConfigParameter = 140;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kDutyCycleInverted: c_SparkMax_ConfigParameter =
    141;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kDutyCycleSensorMode: c_SparkMax_ConfigParameter =
    142;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kDutyCycleAverageDepth: c_SparkMax_ConfigParameter =
    143;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kDutyCycleSampleDelta: c_SparkMax_ConfigParameter =
    144;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kDutyCycleOffsetv1p6p2: c_SparkMax_ConfigParameter =
    145;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kDutyCycleRsvd0: c_SparkMax_ConfigParameter = 146;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kDutyCycleRsvd1: c_SparkMax_ConfigParameter = 147;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kDutyCycleRsvd2: c_SparkMax_ConfigParameter = 148;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kPositionPIDWrapEnable: c_SparkMax_ConfigParameter =
    149;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kPositionPIDMinInput: c_SparkMax_ConfigParameter =
    150;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kPositionPIDMaxInput: c_SparkMax_ConfigParameter =
    151;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kDutyCycleZeroCentered: c_SparkMax_ConfigParameter =
    152;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kDutyCyclePrescalar: c_SparkMax_ConfigParameter =
    153;
pub const c_SparkMax_ConfigParameter_c_SparkMax_kDutyCycleOffset: c_SparkMax_ConfigParameter = 154;
pub const c_SparkMax_ConfigParameter_c_SparkMax_NumParameters: c_SparkMax_ConfigParameter = 155;
pub type c_SparkMax_ConfigParameter = ::std::os::raw::c_uint;
pub const c_SparkMax_ParameterType_c_SparkMax_kInt32: c_SparkMax_ParameterType = 0;
pub const c_SparkMax_ParameterType_c_SparkMax_kUint32: c_SparkMax_ParameterType = 1;
pub const c_SparkMax_ParameterType_c_SparkMax_kFloat32: c_SparkMax_ParameterType = 2;
pub const c_SparkMax_ParameterType_c_SparkMax_kBool: c_SparkMax_ParameterType = 3;
pub type c_SparkMax_ParameterType = ::std::os::raw::c_uint;
pub const c_SparkMax_PeriodicFrame_c_SparkMax_kStatus0: c_SparkMax_PeriodicFrame = 0;
pub const c_SparkMax_PeriodicFrame_c_SparkMax_kStatus1: c_SparkMax_PeriodicFrame = 1;
pub const c_SparkMax_PeriodicFrame_c_SparkMax_kStatus2: c_SparkMax_PeriodicFrame = 2;
pub const c_SparkMax_PeriodicFrame_c_SparkMax_kStatus3: c_SparkMax_PeriodicFrame = 3;
pub const c_SparkMax_PeriodicFrame_c_SparkMax_kStatus4: c_SparkMax_PeriodicFrame = 4;
pub const c_SparkMax_PeriodicFrame_c_SparkMax_kStatus5: c_SparkMax_PeriodicFrame = 5;
pub const c_SparkMax_PeriodicFrame_c_SparkMax_kStatus6: c_SparkMax_PeriodicFrame = 6;
pub type c_SparkMax_PeriodicFrame = ::std::os::raw::c_uint;
pub const c_SparkMax_ControlType_c_SparkMax_kDutyCycle: c_SparkMax_ControlType = 0;
pub const c_SparkMax_ControlType_c_SparkMax_kVelocity: c_SparkMax_ControlType = 1;
pub const c_SparkMax_ControlType_c_SparkMax_kVoltage: c_SparkMax_ControlType = 2;
pub const c_SparkMax_ControlType_c_SparkMax_kPosition: c_SparkMax_ControlType = 3;
pub const c_SparkMax_ControlType_c_SparkMax_kSmartMotion: c_SparkMax_ControlType = 4;
pub const c_SparkMax_ControlType_c_SparkMax_kCurrent: c_SparkMax_ControlType = 5;
pub const c_SparkMax_ControlType_c_SparkMax_kSmartVelocity: c_SparkMax_ControlType = 6;
pub type c_SparkMax_ControlType = ::std::os::raw::c_uint;
pub const c_SparkMax_DataPortConfig_c_SparkMax_kDataPortConfigNone: c_SparkMax_DataPortConfig = -1;
pub const c_SparkMax_DataPortConfig_c_SparkMax_kDataPortConfigLimitSwitchesAndAbsoluteEncoder:
    c_SparkMax_DataPortConfig = 0;
pub const c_SparkMax_DataPortConfig_c_SparkMax_kDataPortConfigAltEncoder:
    c_SparkMax_DataPortConfig = 1;
pub type c_SparkMax_DataPortConfig = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c_SparkMax_PeriodicStatus0 {
    pub appliedOutput: f32,
    pub faults: u16,
    pub stickyFaults: u16,
    pub motorType: c_SparkMax_MotorType,
    pub isFollower: u8,
    pub isInverted: u8,
    pub lock: u8,
    pub roboRIO: u8,
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_c_SparkMax_PeriodicStatus0() {
    const UNINIT: ::std::mem::MaybeUninit<c_SparkMax_PeriodicStatus0> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<c_SparkMax_PeriodicStatus0>(),
        24usize,
        concat!("Size of: ", stringify!(c_SparkMax_PeriodicStatus0))
    );
    assert_eq!(
        ::std::mem::align_of::<c_SparkMax_PeriodicStatus0>(),
        8usize,
        concat!("Alignment of ", stringify!(c_SparkMax_PeriodicStatus0))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appliedOutput) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus0),
            "::",
            stringify!(appliedOutput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).faults) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus0),
            "::",
            stringify!(faults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stickyFaults) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus0),
            "::",
            stringify!(stickyFaults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).motorType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus0),
            "::",
            stringify!(motorType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isFollower) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus0),
            "::",
            stringify!(isFollower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isInverted) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus0),
            "::",
            stringify!(isInverted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus0),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).roboRIO) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus0),
            "::",
            stringify!(roboRIO)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus0),
            "::",
            stringify!(timestamp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c_SparkMax_PeriodicStatus1 {
    pub sensorVelocity: f32,
    pub motorTemperature: u8,
    pub busVoltage: f32,
    pub outputCurrent: f32,
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_c_SparkMax_PeriodicStatus1() {
    const UNINIT: ::std::mem::MaybeUninit<c_SparkMax_PeriodicStatus1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<c_SparkMax_PeriodicStatus1>(),
        24usize,
        concat!("Size of: ", stringify!(c_SparkMax_PeriodicStatus1))
    );
    assert_eq!(
        ::std::mem::align_of::<c_SparkMax_PeriodicStatus1>(),
        8usize,
        concat!("Alignment of ", stringify!(c_SparkMax_PeriodicStatus1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sensorVelocity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus1),
            "::",
            stringify!(sensorVelocity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).motorTemperature) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus1),
            "::",
            stringify!(motorTemperature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).busVoltage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus1),
            "::",
            stringify!(busVoltage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputCurrent) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus1),
            "::",
            stringify!(outputCurrent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus1),
            "::",
            stringify!(timestamp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c_SparkMax_PeriodicStatus2 {
    pub sensorPosition: f32,
    pub iAccum: f32,
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_c_SparkMax_PeriodicStatus2() {
    const UNINIT: ::std::mem::MaybeUninit<c_SparkMax_PeriodicStatus2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<c_SparkMax_PeriodicStatus2>(),
        16usize,
        concat!("Size of: ", stringify!(c_SparkMax_PeriodicStatus2))
    );
    assert_eq!(
        ::std::mem::align_of::<c_SparkMax_PeriodicStatus2>(),
        8usize,
        concat!("Alignment of ", stringify!(c_SparkMax_PeriodicStatus2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sensorPosition) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus2),
            "::",
            stringify!(sensorPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iAccum) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus2),
            "::",
            stringify!(iAccum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus2),
            "::",
            stringify!(timestamp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c_SparkMax_PeriodicStatus3 {
    pub analogVoltage: f32,
    pub analogVelocity: f32,
    pub analogPosition: f32,
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_c_SparkMax_PeriodicStatus3() {
    const UNINIT: ::std::mem::MaybeUninit<c_SparkMax_PeriodicStatus3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<c_SparkMax_PeriodicStatus3>(),
        24usize,
        concat!("Size of: ", stringify!(c_SparkMax_PeriodicStatus3))
    );
    assert_eq!(
        ::std::mem::align_of::<c_SparkMax_PeriodicStatus3>(),
        8usize,
        concat!("Alignment of ", stringify!(c_SparkMax_PeriodicStatus3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analogVoltage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus3),
            "::",
            stringify!(analogVoltage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analogVelocity) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus3),
            "::",
            stringify!(analogVelocity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analogPosition) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus3),
            "::",
            stringify!(analogPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus3),
            "::",
            stringify!(timestamp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c_SparkMax_PeriodicStatus4 {
    pub altEncoderPosition: f32,
    pub altEncoderVelocity: f32,
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_c_SparkMax_PeriodicStatus4() {
    const UNINIT: ::std::mem::MaybeUninit<c_SparkMax_PeriodicStatus4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<c_SparkMax_PeriodicStatus4>(),
        16usize,
        concat!("Size of: ", stringify!(c_SparkMax_PeriodicStatus4))
    );
    assert_eq!(
        ::std::mem::align_of::<c_SparkMax_PeriodicStatus4>(),
        8usize,
        concat!("Alignment of ", stringify!(c_SparkMax_PeriodicStatus4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).altEncoderPosition) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus4),
            "::",
            stringify!(altEncoderPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).altEncoderVelocity) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus4),
            "::",
            stringify!(altEncoderVelocity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus4),
            "::",
            stringify!(timestamp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c_SparkMax_PeriodicStatus5 {
    pub dutyCyclePosition: f32,
    pub dutyCycleAbsoluteValue: u8,
    pub dutyCycleStatus: u8,
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_c_SparkMax_PeriodicStatus5() {
    const UNINIT: ::std::mem::MaybeUninit<c_SparkMax_PeriodicStatus5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<c_SparkMax_PeriodicStatus5>(),
        16usize,
        concat!("Size of: ", stringify!(c_SparkMax_PeriodicStatus5))
    );
    assert_eq!(
        ::std::mem::align_of::<c_SparkMax_PeriodicStatus5>(),
        8usize,
        concat!("Alignment of ", stringify!(c_SparkMax_PeriodicStatus5))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dutyCyclePosition) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus5),
            "::",
            stringify!(dutyCyclePosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dutyCycleAbsoluteValue) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus5),
            "::",
            stringify!(dutyCycleAbsoluteValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dutyCycleStatus) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus5),
            "::",
            stringify!(dutyCycleStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus5),
            "::",
            stringify!(timestamp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c_SparkMax_PeriodicStatus6 {
    pub dutyCycleVelocity: f32,
    pub dutyCycleFrequency: u8,
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_c_SparkMax_PeriodicStatus6() {
    const UNINIT: ::std::mem::MaybeUninit<c_SparkMax_PeriodicStatus6> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<c_SparkMax_PeriodicStatus6>(),
        16usize,
        concat!("Size of: ", stringify!(c_SparkMax_PeriodicStatus6))
    );
    assert_eq!(
        ::std::mem::align_of::<c_SparkMax_PeriodicStatus6>(),
        8usize,
        concat!("Alignment of ", stringify!(c_SparkMax_PeriodicStatus6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dutyCycleVelocity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus6),
            "::",
            stringify!(dutyCycleVelocity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dutyCycleFrequency) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus6),
            "::",
            stringify!(dutyCycleFrequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_PeriodicStatus6),
            "::",
            stringify!(timestamp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c_SparkMax_FirmwareVersion {
    pub major: u8,
    pub minor: u8,
    pub build: u16,
    pub isDebug: u8,
    pub versionRaw: u32,
}
#[test]
fn bindgen_test_layout_c_SparkMax_FirmwareVersion() {
    const UNINIT: ::std::mem::MaybeUninit<c_SparkMax_FirmwareVersion> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<c_SparkMax_FirmwareVersion>(),
        12usize,
        concat!("Size of: ", stringify!(c_SparkMax_FirmwareVersion))
    );
    assert_eq!(
        ::std::mem::align_of::<c_SparkMax_FirmwareVersion>(),
        4usize,
        concat!("Alignment of ", stringify!(c_SparkMax_FirmwareVersion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_FirmwareVersion),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_FirmwareVersion),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).build) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_FirmwareVersion),
            "::",
            stringify!(build)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isDebug) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_FirmwareVersion),
            "::",
            stringify!(isDebug)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).versionRaw) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_FirmwareVersion),
            "::",
            stringify!(versionRaw)
        )
    );
}
pub const c_SparkMax_AccelStrategy_c_SparkMax_kStrategyTrapezoidal: c_SparkMax_AccelStrategy = 0;
pub const c_SparkMax_AccelStrategy_c_SparkMax_kStrategySCurve: c_SparkMax_AccelStrategy = 1;
pub type c_SparkMax_AccelStrategy = ::std::os::raw::c_uint;
pub const c_SparkMax_AnalogMode_c_SparkMax_kAbsolute: c_SparkMax_AnalogMode = 0;
pub const c_SparkMax_AnalogMode_c_SparkMax_kRelative: c_SparkMax_AnalogMode = 1;
pub type c_SparkMax_AnalogMode = ::std::os::raw::c_uint;
pub const c_SparkMax_DutyCycleMode_c_SparkMax_kDutyCycleAbsolute: c_SparkMax_DutyCycleMode = 0;
pub const c_SparkMax_DutyCycleMode_c_SparkMax_kDutyCycleRelative: c_SparkMax_DutyCycleMode = 1;
pub type c_SparkMax_DutyCycleMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c_SparkMax_DRVStatus {
    pub DRVStat0: u16,
    pub DRVStat1: u16,
    pub faults: u16,
    pub stickyFaults: u16,
}
#[test]
fn bindgen_test_layout_c_SparkMax_DRVStatus() {
    const UNINIT: ::std::mem::MaybeUninit<c_SparkMax_DRVStatus> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<c_SparkMax_DRVStatus>(),
        8usize,
        concat!("Size of: ", stringify!(c_SparkMax_DRVStatus))
    );
    assert_eq!(
        ::std::mem::align_of::<c_SparkMax_DRVStatus>(),
        2usize,
        concat!("Alignment of ", stringify!(c_SparkMax_DRVStatus))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DRVStat0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_DRVStatus),
            "::",
            stringify!(DRVStat0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DRVStat1) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_DRVStatus),
            "::",
            stringify!(DRVStat1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).faults) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_DRVStatus),
            "::",
            stringify!(faults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stickyFaults) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(c_SparkMax_DRVStatus),
            "::",
            stringify!(stickyFaults)
        )
    );
}
extern "C" {
    pub fn c_SparkMax_RegisterId(deviceId: ::std::os::raw::c_int) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_Create(
        deviceId: ::std::os::raw::c_int,
        type_: c_SparkMax_MotorType,
    ) -> c_SparkMax_handle;
}
extern "C" {
    pub fn c_SparkMax_Create_Inplace(deviceId: ::std::os::raw::c_int) -> c_SparkMax_handle;
}
extern "C" {
    pub fn c_SparkMax_Destroy(handle: c_SparkMax_handle);
}
extern "C" {
    pub fn c_SparkMax_CheckId(deviceId: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn c_SparkMax_GetFirmwareVersion(
        handle: c_SparkMax_handle,
        fwVersion: *mut c_SparkMax_FirmwareVersion,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetSerialNumber(
        handle: c_SparkMax_handle,
        serialNumber: *mut *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDeviceId(
        handle: c_SparkMax_handle,
        deviceId: *mut ::std::os::raw::c_int,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetMotorType(
        handle: c_SparkMax_handle,
        type_: c_SparkMax_MotorType,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetMotorType(
        handle: c_SparkMax_handle,
        type_: *mut c_SparkMax_MotorType,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetPeriodicFramePeriod(
        handle: c_SparkMax_handle,
        frameId: c_SparkMax_PeriodicFrame,
        periodMs: ::std::os::raw::c_int,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetControlFramePeriod(
        handle: c_SparkMax_handle,
        periodMs: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn c_SparkMax_GetControlFramePeriod(handle: c_SparkMax_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c_SparkMax_SetParameterFloat32(
        handle: c_SparkMax_handle,
        paramId: c_SparkMax_ConfigParameter,
        value: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetParameterInt32(
        handle: c_SparkMax_handle,
        paramId: c_SparkMax_ConfigParameter,
        value: i32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetParameterUint32(
        handle: c_SparkMax_handle,
        paramId: c_SparkMax_ConfigParameter,
        value: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetParameterBool(
        handle: c_SparkMax_handle,
        paramId: c_SparkMax_ConfigParameter,
        value: u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetParameterFloat32(
        handle: c_SparkMax_handle,
        paramId: c_SparkMax_ConfigParameter,
        value: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetParameterInt32(
        handle: c_SparkMax_handle,
        paramId: c_SparkMax_ConfigParameter,
        value: *mut i32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetParameterUint32(
        handle: c_SparkMax_handle,
        paramId: c_SparkMax_ConfigParameter,
        value: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetParameterBool(
        handle: c_SparkMax_handle,
        paramId: c_SparkMax_ConfigParameter,
        value: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPeriodicStatus0(
        handle: c_SparkMax_handle,
        rawframe: *mut c_SparkMax_PeriodicStatus0,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPeriodicStatus1(
        handle: c_SparkMax_handle,
        rawframe: *mut c_SparkMax_PeriodicStatus1,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPeriodicStatus2(
        handle: c_SparkMax_handle,
        rawframe: *mut c_SparkMax_PeriodicStatus2,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPeriodicStatus3(
        handle: c_SparkMax_handle,
        rawframe: *mut c_SparkMax_PeriodicStatus3,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPeriodicStatus4(
        handle: c_SparkMax_handle,
        rawframe: *mut c_SparkMax_PeriodicStatus4,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPeriodicStatus5(
        handle: c_SparkMax_handle,
        rawframe: *mut c_SparkMax_PeriodicStatus5,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPeriodicStatus6(
        handle: c_SparkMax_handle,
        rawframe: *mut c_SparkMax_PeriodicStatus6,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetEncoderPosition(
        handle: c_SparkMax_handle,
        position: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAltEncoderPosition(
        handle: c_SparkMax_handle,
        position: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_RestoreFactoryDefaults(
        handle: c_SparkMax_handle,
        persist: u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_FactoryWipe(handle: c_SparkMax_handle, persist: u8) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetFollow(
        handle: c_SparkMax_handle,
        followerArbId: u32,
        followerCfg: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SafeFloat(f: f32) -> f32;
}
extern "C" {
    pub fn c_SparkMax_SetpointCommand(
        handle: c_SparkMax_handle,
        value: f32,
        ctrl: c_SparkMax_ControlType,
        pidSlot: ::std::os::raw::c_int,
        arbFeedforward: f32,
        arbFFUnits: ::std::os::raw::c_int,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDRVStatus(
        handle: c_SparkMax_handle,
        drvStatus: *mut c_SparkMax_DRVStatus,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetInverted(handle: c_SparkMax_handle, inverted: u8) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetInverted(
        handle: c_SparkMax_handle,
        inverted: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSmartCurrentLimit(
        handle: c_SparkMax_handle,
        stallLimit: u8,
        freeLimit: u8,
        limitRPM: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetSmartCurrentLimit(
        handle: c_SparkMax_handle,
        stallLimit: *mut u8,
        freeLimit: *mut u8,
        limitRPM: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSecondaryCurrentLimit(
        handle: c_SparkMax_handle,
        limit: f32,
        chopCycles: ::std::os::raw::c_int,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetSecondaryCurrentLimit(
        handle: c_SparkMax_handle,
        limit: *mut f32,
        chopCycles: *mut ::std::os::raw::c_int,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetIdleMode(
        handle: c_SparkMax_handle,
        idlemode: c_SparkMax_IdleMode,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetIdleMode(
        handle: c_SparkMax_handle,
        idlemode: *mut c_SparkMax_IdleMode,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_EnableVoltageCompensation(
        handle: c_SparkMax_handle,
        nominalVoltage: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetVoltageCompensationNominalVoltage(
        handle: c_SparkMax_handle,
        nominalVoltage: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_DisableVoltageCompensation(handle: c_SparkMax_handle) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetOpenLoopRampRate(
        handle: c_SparkMax_handle,
        rate: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetOpenLoopRampRate(
        handle: c_SparkMax_handle,
        rate: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetClosedLoopRampRate(
        handle: c_SparkMax_handle,
        rate: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetClosedLoopRampRate(
        handle: c_SparkMax_handle,
        rate: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_IsFollower(
        handle: c_SparkMax_handle,
        isFollower: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetFaults(handle: c_SparkMax_handle, faults: *mut u16) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetStickyFaults(
        handle: c_SparkMax_handle,
        stickyFaults: *mut u16,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetFault(
        handle: c_SparkMax_handle,
        faultId: c_SparkMax_FaultID,
        fault: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetStickyFault(
        handle: c_SparkMax_handle,
        faultId: c_SparkMax_FaultID,
        stickyfault: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetBusVoltage(
        handle: c_SparkMax_handle,
        busVoltage: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAppliedOutput(
        handle: c_SparkMax_handle,
        appliedOutput: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSimAppliedOutput(handle: c_SparkMax_handle, appliedOutput: f32);
}
extern "C" {
    pub fn c_SparkMax_GetOutputCurrent(
        handle: c_SparkMax_handle,
        outputCurrent: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetMotorTemperature(
        handle: c_SparkMax_handle,
        motorTemperature: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_ClearFaults(handle: c_SparkMax_handle) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_BurnFlash(handle: c_SparkMax_handle) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetCANTimeout(
        handle: c_SparkMax_handle,
        timeoutMs: ::std::os::raw::c_int,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_EnableSoftLimit(
        handle: c_SparkMax_handle,
        dir: c_SparkMax_LimitDirection,
        enable: u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_IsSoftLimitEnabled(
        handle: c_SparkMax_handle,
        dir: c_SparkMax_LimitDirection,
        enabled: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSoftLimit(
        handle: c_SparkMax_handle,
        dir: c_SparkMax_LimitDirection,
        limit: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetSoftLimit(
        handle: c_SparkMax_handle,
        dir: c_SparkMax_LimitDirection,
        limit: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSensorType(
        handle: c_SparkMax_handle,
        sensorType: c_SparkMax_EncoderType,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_IDQuery(
        uniqueIdArray: *mut u32,
        uniqueIdArraySize: usize,
        numberOfDevices: *mut usize,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_IDAssign(uniqueId: u32, deviceId: u8) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_Identify(handle: c_SparkMax_handle) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_IdentifyUniqueId(uniqueId: u32) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetLimitPolarity(
        handle: c_SparkMax_handle,
        sw: c_SparkMax_LimitDirection,
        polarity: c_SparkMax_LimitPolarity,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetLimitPolarity(
        handle: c_SparkMax_handle,
        sw: c_SparkMax_LimitDirection,
        polarity: *mut c_SparkMax_LimitPolarity,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetLimitSwitch(
        handle: c_SparkMax_handle,
        sw: c_SparkMax_LimitDirection,
        limit: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_EnableLimitSwitch(
        handle: c_SparkMax_handle,
        sw: c_SparkMax_LimitDirection,
        enable: u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_IsLimitEnabled(
        handle: c_SparkMax_handle,
        sw: c_SparkMax_LimitDirection,
        enabled: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAnalogPosition(
        handle: c_SparkMax_handle,
        position: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAnalogVelocity(
        handle: c_SparkMax_handle,
        velocity: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAnalogVoltage(
        arg1: c_SparkMax_handle,
        voltage: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSimAnalogPosition(handle: c_SparkMax_handle, position: f32);
}
extern "C" {
    pub fn c_SparkMax_SetSimAnalogVelocity(handle: c_SparkMax_handle, velocity: f32);
}
extern "C" {
    pub fn c_SparkMax_SetSimAnalogVoltage(arg1: c_SparkMax_handle, voltage: f32);
}
extern "C" {
    pub fn c_SparkMax_SetAnalogPositionConversionFactor(
        arg1: c_SparkMax_handle,
        conversion: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAnalogVelocityConversionFactor(
        arg1: c_SparkMax_handle,
        conversion: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAnalogPositionConversionFactor(
        arg1: c_SparkMax_handle,
        conversion: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAnalogVelocityConversionFactor(
        arg1: c_SparkMax_handle,
        conversion: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAnalogInverted(
        arg1: c_SparkMax_handle,
        inverted: u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAnalogInverted(
        arg1: c_SparkMax_handle,
        inverted: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAnalogAverageDepth(
        handle: c_SparkMax_handle,
        depth: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAnalogAverageDepth(
        handle: c_SparkMax_handle,
        depth: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAnalogMeasurementPeriod(
        handle: c_SparkMax_handle,
        samples: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAnalogMeasurementPeriod(
        handle: c_SparkMax_handle,
        samples: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAnalogMode(
        handle: c_SparkMax_handle,
        mode: c_SparkMax_AnalogMode,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAnalogMode(
        handle: c_SparkMax_handle,
        mode: *mut c_SparkMax_AnalogMode,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetEncoderPosition(
        handle: c_SparkMax_handle,
        position: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetEncoderVelocity(
        handle: c_SparkMax_handle,
        velocity: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetPositionConversionFactor(
        handle: c_SparkMax_handle,
        conversion: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetVelocityConversionFactor(
        handle: c_SparkMax_handle,
        conversion: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPositionConversionFactor(
        handle: c_SparkMax_handle,
        conversion: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetVelocityConversionFactor(
        handle: c_SparkMax_handle,
        conversion: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAverageDepth(handle: c_SparkMax_handle, depth: u32) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAverageDepth(
        handle: c_SparkMax_handle,
        depth: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetMeasurementPeriod(
        handle: c_SparkMax_handle,
        samples: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetMeasurementPeriod(
        handle: c_SparkMax_handle,
        samples: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetCountsPerRevolution(
        handle: c_SparkMax_handle,
        cpr: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetCountsPerRevolution(
        handle: c_SparkMax_handle,
        cpr: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetEncoderInverted(
        handle: c_SparkMax_handle,
        inverted: u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetEncoderInverted(
        handle: c_SparkMax_handle,
        inverted: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAltEncoderPosition(
        handle: c_SparkMax_handle,
        position: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAltEncoderVelocity(
        handle: c_SparkMax_handle,
        velocity: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSimAltEncoderVelocity(handle: c_SparkMax_handle, velocity: f32);
}
extern "C" {
    pub fn c_SparkMax_SetAltEncoderPositionFactor(
        handle: c_SparkMax_handle,
        conversion: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAltEncoderVelocityFactor(
        handle: c_SparkMax_handle,
        conversion: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAltEncoderPositionFactor(
        handle: c_SparkMax_handle,
        conversion: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAltEncoderVelocityFactor(
        handle: c_SparkMax_handle,
        conversion: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAltEncoderAverageDepth(
        handle: c_SparkMax_handle,
        depth: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAltEncoderAverageDepth(
        handle: c_SparkMax_handle,
        depth: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAltEncoderMeasurementPeriod(
        handle: c_SparkMax_handle,
        samples: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAltEncoderMeasurementPeriod(
        handle: c_SparkMax_handle,
        samples: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAltEncoderCountsPerRevolution(
        handle: c_SparkMax_handle,
        cpr: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAltEncoderCountsPerRevolution(
        handle: c_SparkMax_handle,
        cpr: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAltEncoderInverted(
        handle: c_SparkMax_handle,
        inverted: u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAltEncoderInverted(
        handle: c_SparkMax_handle,
        inverted: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDutyCyclePosition(
        handle: c_SparkMax_handle,
        position: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDutyCycleVelocity(
        handle: c_SparkMax_handle,
        velocity: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetDutyCyclePositionFactor(
        handle: c_SparkMax_handle,
        conversion: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDutyCyclePositionFactor(
        handle: c_SparkMax_handle,
        conversion: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetDutyCycleVelocityFactor(
        handle: c_SparkMax_handle,
        conversion: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDutyCycleVelocityFactor(
        handle: c_SparkMax_handle,
        conversion: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetDutyCycleInverted(
        handle: c_SparkMax_handle,
        inverted: u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDutyCycleInverted(
        handle: c_SparkMax_handle,
        inverted: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetDutyCycleMode(
        handle: c_SparkMax_handle,
        mode: c_SparkMax_DutyCycleMode,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDutyCycleMode(
        handle: c_SparkMax_handle,
        mode: *mut c_SparkMax_DutyCycleMode,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetDutyCycleAverageDepth(
        handle: c_SparkMax_handle,
        depth: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDutyCycleAverageDepth(
        handle: c_SparkMax_handle,
        depth: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetDutyCycleSampleDelta(
        handle: c_SparkMax_handle,
        delta: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDutyCycleSampleDelta(
        handle: c_SparkMax_handle,
        delta: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetDutyCycleOffset(
        handle: c_SparkMax_handle,
        offset: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDutyCycleOffset(
        handle: c_SparkMax_handle,
        offset: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetHallSensorSampleRate(
        handle: c_SparkMax_handle,
        sampleRate: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetHallSensorSampleRate(
        handle: c_SparkMax_handle,
        sampleRate: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetHallSensorAverageDepth(
        handle: c_SparkMax_handle,
        depth: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetHallSensorAverageDepth(
        handle: c_SparkMax_handle,
        depth: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_AttemptToSetDataPortConfig(
        handle: c_SparkMax_handle,
        config: c_SparkMax_DataPortConfig,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDataPortConfig(
        handle: c_SparkMax_handle,
        config: *mut c_SparkMax_DataPortConfig,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetP(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        gain: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetI(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        gain: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetD(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        gain: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetDFilter(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        gain: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetFF(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        gain: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetIZone(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        IZone: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetOutputRange(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        min: f32,
        max: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetP(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        gain: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetI(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        gain: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetD(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        gain: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDFilter(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        gain: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetFF(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        gain: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetIZone(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        IZone: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetOutputMin(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        min: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetOutputMax(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        max: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSmartMotionMaxVelocity(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        maxVel: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSmartMotionMaxAccel(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        maxAccel: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSmartMotionMinOutputVelocity(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        minVel: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSmartMotionAccelStrategy(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        accelStrategy: c_SparkMax_AccelStrategy,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSmartMotionAllowedClosedLoopError(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        allowedError: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetSmartMotionMaxVelocity(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        maxVel: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetSmartMotionMaxAccel(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        maxAccel: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetSmartMotionMinOutputVelocity(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        minVel: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetSmartMotionAccelStrategy(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        accelStrategy: *mut c_SparkMax_AccelStrategy,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetSmartMotionAllowedClosedLoopError(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        allowedError: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetIMaxAccum(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        iMaxAccum: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetIMaxAccum(
        handle: c_SparkMax_handle,
        slotID: ::std::os::raw::c_int,
        iMaxAccum: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetIAccum(handle: c_SparkMax_handle, iAccum: f32) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetIAccum(handle: c_SparkMax_handle, iAccum: *mut f32) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetFeedbackDevice(
        handle: c_SparkMax_handle,
        sensorID: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetFeedbackDeviceID(
        handle: c_SparkMax_handle,
        id: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetFeedbackDeviceRange(
        handle: c_SparkMax_handle,
        min: f32,
        max: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAPIVersion() -> c_SparkMax_APIVersion;
}
extern "C" {
    pub fn c_SparkMax_SetLastError(handle: c_SparkMax_handle, error: c_REVLib_ErrorCode);
}
extern "C" {
    pub fn c_SparkMax_GetLastError(handle: c_SparkMax_handle) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GenerateError(
        deviceID: ::std::os::raw::c_int,
        error: c_REVLib_ErrorCode,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSimFreeSpeed(
        handle: c_SparkMax_handle,
        freeSpeed: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSimStallTorque(
        handle: c_SparkMax_handle,
        stallTorque: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetPositionPIDWrapEnable(
        handle: c_SparkMax_handle,
        enable: u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetPositionPIDMinInput(
        handle: c_SparkMax_handle,
        value: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetPositionPIDMaxInput(
        handle: c_SparkMax_handle,
        value: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPositionPIDWrapEnable(
        handle: c_SparkMax_handle,
        enabled: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPositionPIDMinInput(
        handle: c_SparkMax_handle,
        value: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPositionPIDMaxInput(
        handle: c_SparkMax_handle,
        value: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
